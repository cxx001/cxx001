<!DOCTYPE HTML>
<html lang="zh-CN">

<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="Hexo">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.0.0">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="https://cxx001.gitee.io">
    <!--SEO-->

<meta name="keywords" content="c++,effective c++" />


<meta name="description" content="
本文阅读说明孔子云：“取乎其上，得乎其中；取乎其中，得乎其下；取乎其下，则无所得矣”。
对于读书求知而言，这句古训教我们去读好书，最好是好书中的上品—-经典书。《Effective C++》就..." />


<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->

<title>
    
    《Effective C++》 全书内容提炼总结 |
    
    Hexo
</title>

<link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">


<link rel="icon" href="/favicon.ico">

    


<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7.css">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.7.0.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash.css">

    
<div class="hide">
    <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script>
</div>




    

<meta name="generator" content="Hexo 6.2.0"></head>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->
<body>
    <header class="main-header"  style="background-image:url(
    https://hexo-theme-snippet-1251680922.cos.ap-beijing.myqcloud.com/img/banner.jpg)"
     >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='John Doe'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
            <!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
            <img src="/img/branding.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
        </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                        <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="https://cxx001.gitee.io">
                        Hexo</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                        <li role="presentation" class="text-center">
                            <a href="/"><i class="fa "></i>
                                首页</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/archives/"><i class="fa "></i>
                                时间轴</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/guestbook/"><i class="fa "></i>
                                留言</a>
                        </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="《Effective C++》 全书内容提炼总结">
            
            《Effective C++》 全书内容提炼总结
            
        </h1>
        <div class="post-meta">
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a class="category-link" href="/categories/notes/">notes</a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            <a class="tag-none-link" href="/tags/c/" rel="tag">c++</a> <a class="tag-none-link" href="/tags/effective-c/" rel="tag">effective c++</a>
            
        </span>
    </span>
    
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">
            2022/12/19</span>
    </span>
    
    <span class="fa-wrap">
        <i class="fa fa-eye"></i>
        <span id="busuanzi_value_page_pv"></span>
    </span>
    
    
</div>
        
        
    </div>
    
    <div class="post-body post-content">
        <p><img src="https://cxx001.gitee.io/2022/12/19/notes/Effective%20C++/image-20220820124847894.png" alt="image-20220820124847894"></p>
<h1 id="本文阅读说明"><a href="#本文阅读说明" class="headerlink" title="本文阅读说明"></a>本文阅读说明</h1><p>孔子云：“取乎其上，得乎其中；取乎其中，得乎其下；取乎其下，则无所得矣”。</p>
<p>对于读书求知而言，这句古训教我们去读好书，最好是好书中的上品—-经典书。《Effective C++》就是这类经典书，值得反复去读，每次都能有不一样的收获。</p>
<p>有人说C++程序员可以分为两类，读过Effective C++的和没读过的。近段再次精读记录下全书纲领，每小节最后都有<code>请记住</code>精炼总结，便于日后据此回顾。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/cxx001/resources/raw/main/Effective%20C%2B%2B%E4%B8%AD%E6%96%87%E7%89%88(%E7%AC%AC%E4%B8%89%E7%89%88).pdf">本书电子版</a></p>
<br>

<h1 id="一、让自己习惯C"><a href="#一、让自己习惯C" class="headerlink" title="一、让自己习惯C++"></a>一、让自己习惯C++</h1><h2 id="1-视C-为一个语言联邦"><a href="#1-视C-为一个语言联邦" class="headerlink" title="1.  视C++为一个语言联邦"></a>1.  视C++为一个语言联邦</h2><p>C++可以看成是相关语言组成的一个集合而非单一语言，在其某个次语言中，各种守则与示例都倾向于简单、直观易懂、并且容易记住。然而当你从一个次语言移往另一个次语言，守则可能改变。每个次语言都有自己的规约。</p>
<p>为了深刻理解C++，你必须认识其主要的次语言。幸运的是总共只有4个：</p>
<ul>
<li>C</li>
<li>Object C++  也就是带类的C</li>
<li>Template C++ 这是C++的范型编程</li>
<li>STL 是个template程序库</li>
</ul>
<p><strong>请记住</strong></p>
<blockquote>
<p>C++ 高效编程守则视状况而变化，取决于你使用C++ 的哪一部分。</p>
</blockquote>
<h2 id="2-尽量用-const-enum-inline-替换-define"><a href="#2-尽量用-const-enum-inline-替换-define" class="headerlink" title="2. 尽量用 const, enum, inline 替换 #define"></a>2. 尽量用 const, enum, inline 替换 #define</h2><p>define只是在预处理器中做简单的字符替换，编译器根本就不知道define定义的宏符号。</p>
<p>使用define存在一些问题：</p>
<ul>
<li>没有作用域，只能全局的。</li>
<li>常量宏定义如果出错，编译器报错只知道常量值，根本就不知道宏名称，排错时容易让人迷惑。</li>
<li>带参数的宏使用时要特别小心运算优先级，受参数内容影响，特别容易错误。</li>
<li>没有类型检查。</li>
</ul>
<p>所以对于定义常量一般我们用const替换，有两种特殊情况值得说说。</p>
<p>第一是定义常量指针，由于常量定义通常在头文件内(以便被不同的源码引入)，因此有必要将指针和指针所指的值都声明为const，也就是常量指针常量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> authorName = <span class="string">&quot;Scott Meyers&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这种定义字符串常量，我们一般用string对象更合宜。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> authorName = <span class="string">&quot;Scott Meyers&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>第二是类里的常量定义。为了确保此常量至多只有一份，你必须让它成为一个static成员:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GamePlayer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> NumTurns = <span class="number">5</span>;  <span class="comment">// 如果编译器认为这只是声明，那么要把这个定义写到cpp中</span></span><br><span class="line">    <span class="type">int</span> scores[NumTurns];  <span class="comment">// 这种编译器可能不允许用static常量，那么我们可以用enum替换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用enum来声明数组长度值(数组在编译时编译器必须知道它的长度)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GamePlayer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123;NumTurns = <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> scores[Numturns];   <span class="comment">// 这就没问题了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面我们再看define定义带参数的函数式宏容易错误的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a和b的较大值调用f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b));</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">CALL_WITH_MAX</span>(++a, b);     <span class="comment">// a被累加两次</span></span><br><span class="line"><span class="built_in">CALL_WITH_MAX</span>(++a, B+<span class="number">10</span>);  <span class="comment">// a被累加一次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里，调用f之前，a的累加次数竟然取决于它被拿来和谁比较~</span></span><br></pre></td></tr></table></figure>

<p>我们用inline来替换的话，效率上不会比define差，都是在调用处直接展开，没有函数调用的开销。也不需要考虑宏参数都加括号和参数被计算多次等问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">callWithMax</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>对于单纯常量，最好以const 对象或 enum替换define</li>
<li>对于形似函数的宏，最好改用inline函数替换define</li>
</ul>
</blockquote>
<h2 id="3-尽可能使用const"><a href="#3-尽可能使用const" class="headerlink" title="3. 尽可能使用const"></a>3. 尽可能使用const</h2><ul>
<li><p>常量指针、指针常量、常量指针常量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* p = <span class="string">&quot;greeting&quot;</span>;   <span class="comment">// 常量指针，数据不能修改</span></span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> p = <span class="string">&quot;greating&quot;</span>;   <span class="comment">// 指针常量，指针不能修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> p = <span class="string">&quot;greating&quot;</span> <span class="comment">// 常量指针常量，指针和数据都不能修改</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>stl迭代器常量</p>
<p>迭代器的作用就像个 T* 指针。 const修饰迭代器，其实类似T* const，它是迭代器不能修改，但所指的值可以修改。如果要保证值也不能修改，那就只能用 const_iterator 迭代器了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">...</span><br><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>();</span><br><span class="line">*iter = <span class="number">10</span>;   <span class="comment">// 没问题，改变iter所指的值</span></span><br><span class="line">++iter; 	  <span class="comment">// 错误! iter指针是常量</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::const_iterator citer = vec.<span class="built_in">begin</span>();</span><br><span class="line">*citer = <span class="number">10</span>;  <span class="comment">// 错误! *citer是常量</span></span><br><span class="line">++citer;      <span class="comment">// citer指针可以改变，没问题</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>const成员函数</p>
<p>const成员函数：在其函数体内不能修改该对象的数据成员，这里本质const修饰的是函数隐式参数this。</p>
<p>const对象只能调用const成员函数，<strong>本质也一样，因为修饰的是this</strong>。(const成员函数可以被非const对象调用)</p>
<p>如果在const函数中确实想修改某些数据成员，那么可以把这些数据成员声明时用 <code>mutable</code> 修改，表示可变的。</p>
<blockquote>
<p>补充: </p>
<p>函数重载：</p>
<ol>
<li>函数的参数不同(个数、顺序)，与返回值无关</li>
<li>常量性不同，也可以重载 (常量成员函数与非常量成员函数也能重载)</li>
</ol>
<p>类型转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 除const修饰的对象类型转换用 static_cast</span></span><br><span class="line"><span class="type">double</span> somevalue = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">void</span>* p = &amp;somevalue;</span><br><span class="line"><span class="type">double</span>* pd = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>*&gt;(p);  <span class="comment">// 将 void*类型指针转换为double*类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除const对象的常量属性用 const_cast</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* pc;</span><br><span class="line"><span class="type">char</span>* p = <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(pc); <span class="comment">// 将常量指针pc转换为普通指针</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>将某些东西声明为 const 可帮助编译器识别错误用法。const 可被用于任何作用域内的对象、函数参数、函数返回值、成员函数体。</li>
<li>编译器强制实施 “const修饰对象不能被修改” ，但你编写程序时应该使用 ”概念上的常量性“。</li>
<li>当 const 和 non-const 成员函数有着一样的实现时，可以用non-const 版本调用const 版本可以避免代码重复。</li>
</ul>
</blockquote>
<h2 id="4-确定对象被使用前已先被初始化"><a href="#4-确定对象被使用前已先被初始化" class="headerlink" title="4. 确定对象被使用前已先被初始化"></a>4. 确定对象被使用前已先被初始化</h2><p>读取未初始化的值会导致不明确的行为。在某些平台上，仅仅只是读取未初始化的值，就可能让你的程序终止运行。更可能的情况是读入一些”半随机”值，污染了正在进行读取动作的那个对象，最终导致不可预测的程序行为，以及许多令人不愉快的调试过程。</p>
<p>所有我们定下一个规则，永远在使用对象之前将它初始化。这很简单，但是对于自定义类型，初始化责任就落在构造函数身上了，这里重要的是别混淆了赋值和初始化。</p>
<p>在构造函数里给成员数据赋值不是初始化，而是赋值操作。程序会先调用默认构造函数初始化，然后再调用自身构造函数赋值。这里要避开赋值操作就得用成员初始化列表的形式，这样在调用默认构造函数时直接使用成员初始化列表的值初始化，这样效率也更高。</p>
<p>自定义类型数据初始化顺序和它声明时一致，和构造函数里赋值顺序无关，所以为了不让阅读者歧义，我们约定构造函数里初始化数据时顺序和声明时保持一致。</p>
<p>当我们已经做到在对象创建时都初始化它，那么就只有一件事情需要操心了，那就是注意<strong>不同编译单元内定义的全局对象的初始化顺序</strong>（不同编译单元指不同的cpp源文件中）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">numDisks</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;  <span class="comment">// 给其它类使用的全局对象</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Directory</span>(params);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Directory::<span class="built_in">Directory</span>(params)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::<span class="type">size_t</span> disks = tfs.<span class="built_in">numDisks</span>();  <span class="comment">// 使用其它编译单元的对象</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Directory对象</span></span><br><span class="line"><span class="function">Directory <span class="title">tempDir</span><span class="params">(params)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这样上面两个编译单元的对象谁先初始化，这个编译器也不知道。</p>
<p>对于不同编译单元的全局对象初始化顺序问题，要避免我们得把全局对象包装到函数块里。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123;...&#125;;</span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> FileSystem fs;</span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123;...&#125;;</span><br><span class="line">Directory::<span class="built_in">Directory</span>(params)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::<span class="type">size_t</span> disks = <span class="built_in">tfs</span>().<span class="built_in">numDisks</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempDir</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> Directory td;</span><br><span class="line">    <span class="keyword">return</span> td;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>将全局对象封装到函数里，把直接访问全局对象改为调用函数的形式，这样就不用关心跨编译单元对象的初始化顺序问题了。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>为内置类型对象进行手工初始化，因为c++不保证初始化它们。</li>
<li>构造函数最好使用成员初始化列表，而不要在构造函数本体内使用赋值操作。初始化列表的成员变量，其顺序应该与它们声明顺序一致。</li>
<li>为避免”跨编译单元的初始化顺序”问题，请用函数包装替换全局对象。</li>
</ul>
</blockquote>
<br>

<h1 id="二、构造-x2F-析构-x2F-赋值运算"><a href="#二、构造-x2F-析构-x2F-赋值运算" class="headerlink" title="二、构造&#x2F;析构&#x2F;赋值运算"></a>二、构造&#x2F;析构&#x2F;赋值运算</h1><h2 id="5-了解C-默默编写并调用哪些函数"><a href="#5-了解C-默默编写并调用哪些函数" class="headerlink" title="5. 了解C++默默编写并调用哪些函数"></a>5. 了解C++默默编写并调用哪些函数</h2><p>当编写了一个空类，C++编译器会自动(<strong>如果它们被使用的话</strong>)给这个空类生成<strong>一个默认构造函数、一个拷贝构造函数、一个赋值操作符重载函数和一个析构函数</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果你写下这么个空类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这就好像你写下这样的代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;</span><br><span class="line">    <span class="built_in">Empty</span>() &#123;...&#125;</span><br><span class="line">    <span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp; rhs) &#123;...&#125;</span><br><span class="line">    ~<span class="built_in">Empty</span>() &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Empty&amp; rhs) &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意上面4个函数：</p>
<ol>
<li>只有它们被需要(被调用)，它们才会真正被编译器创建出来。</li>
<li>只要被我重定义了的，编译器就不会再自动生成它们。注意：如果我重定义了任何构造函数则默认构造函数就不会自动创建了，而如果只重定义了默认构造函数，则上面剩余函数编译器还是会自动生成。</li>
</ol>
</blockquote>
<p>上面自动生成的拷贝构造函数和赋值操作符函数其内部实现如出一辙，但是有下面3种特殊情况，编译器会拒绝生成赋值操作符函数。</p>
<ol>
<li>带有<code>&amp;</code> 引用的成员。</li>
<li>带有<code>const</code>的成员。</li>
<li>某个基类将赋值操作符函数声明为private，那么其派生类编译器也会拒绝生成赋值操作符函数。</li>
</ol>
<p>1、2情况示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NameObject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NameObject</span>(std::string&amp; name, <span class="type">const</span> T&amp; value);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string&amp; nameValue;</span><br><span class="line">    <span class="type">const</span> T objectValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 考虑下面会发生什么事：</span></span><br><span class="line"><span class="function">std::string <span class="title">newDog</span><span class="params">(<span class="string">&quot;Persephone&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">oldDog</span><span class="params">(<span class="string">&quot;Satch&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">NameObject&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(newDog, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">NameObject&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(oldDog, <span class="number">36</span>)</span></span>;</span><br><span class="line">p = s;  <span class="comment">// 这是不允许的，1. 引用只能指向引用的对象不能修改 2. const修饰成员不能被修改</span></span><br></pre></td></tr></table></figure>

<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>编译器可以暗自为class创建default构造函数、copy构造函数、copy assignment操作符，析构函数。</li>
</ul>
</blockquote>
<h2 id="6-若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#6-若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="6. 若不想使用编译器自动生成的函数，就该明确拒绝"></a>6. 若不想使用编译器自动生成的函数，就该明确拒绝</h2><p>如果某个场景需要某个类对象是唯一独一份的，不想外部拷贝这个对象。</p>
<p>直接想到的是限制它的拷贝构造函数和赋值操作符函数，即不让外部调用它们。</p>
<p>那第一种方案就是重定义它们并声明为<code>private</code>属性（<strong>注意不要实现它们，目标是防止自己内部或friend函数调用</strong>）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HomeForSale</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 只声明不实现，目标是防止自己内部或friend函数调用</span></span><br><span class="line">    <span class="built_in">HomeForSale</span>(<span class="type">const</span> HomeForSale&amp;);</span><br><span class="line">    HomeForSale&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HomeForSale&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方式是放基类里去声明它们为<code>private</code>属性，然后只需要继承它，那么派生类默认生成的拷贝构造函数和赋值操作符函数会去调用基类里对应的函数。从而达到同样效果(注意多重继承问题)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Uncopyable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">Uncopyable</span>() &#123;&#125;;</span><br><span class="line">	~<span class="built_in">Uncopyable</span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Uncopyable</span>(<span class="type">const</span> Uncopyable&amp;);</span><br><span class="line">	Uncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Uncopyable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HomeForSale</span> : <span class="keyword">private</span> Uncopyable</span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>请记住</strong></p>
<blockquote>
<p>为阻止编译器自动生成函数机制，可将相应的成员函数声明为<code>private</code>并且不予实现。或者继承像上面<code>Uncopyable</code>这样的基类也是一种做法。</p>
</blockquote>
<h2 id="7-为多态基类声明virtual析构函数"><a href="#7-为多态基类声明virtual析构函数" class="headerlink" title="7. 为多态基类声明virtual析构函数"></a>7. 为多态基类声明virtual析构函数</h2><p>在多态场景中，基类指针指向派生类对象，<code>delete</code>基类指针，基类的析构函数要加<code>virtual</code>，不然只会销毁派生类中基类部分而自身内的成员没被销毁，于是造成一个诡异的局部销毁对象，导致内存泄漏、败坏数据结构。</p>
<p>如果一个类不含<code>virtual</code>函数，通常表示它并不意图被用做一个基类使用。当类不企图被当作基类，令其析构函数为<code>virtual</code>往往是个馊主意（平白多一个虚表指针空间）。<strong>记住虚函数一般用于多态场景的基类中。</strong></p>
<p>许多人的心得是：只有当类内至少含有一个<code>virtual</code>函数，才为它声明<code>virtual</code>析构函数。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>带多态性质的基类应该声明一个<code>virtual</code>析构函数。如何类带有任何<code>virtual</code>函数，它就应该拥有一个<code>virtual</code>析构函数。</li>
<li>类的设计目的如果不是作为基类使用，或不是为了具备多态性，就不该声明<code>virtual</code>析构函数。</li>
</ul>
</blockquote>
<h2 id="8-别让异常逃离析构函数"><a href="#8-别让异常逃离析构函数" class="headerlink" title="8. 别让异常逃离析构函数"></a>8. 别让异常逃离析构函数</h2><p>析构函数抛出异常<strong>可能会带来不明确的行为</strong>。因此我们如果一定要在析构函数内执行可能失败的操作，就必须要用<code>try...catch</code>截取异常，不让异常从析构函数抛出去导致不明确行为发生。</p>
<p>截取异常正确做法一般有2种情况：</p>
<ol>
<li>直接吞下异常或者结束程序。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DBConn::~<span class="built_in">DBConn</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        db.<span class="built_in">close</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="comment">// std::abort();    //自己选择要么记录错误什么也不做，要么让程序终止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>可能失败的操作提供对外接口，使外部有机会对可能失败的情况做出反应。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DBConn::~<span class="built_in">DBConn</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span>    <span class="comment">// 给外部一个处理有可能错误的机会</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        db.<span class="built_in">close</span>();</span><br><span class="line">        closed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">DBConn</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!closed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                db.<span class="built_in">close</span>();</span><br><span class="line">            &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">                <span class="comment">// std::abort();    //自己选择要么记录错误什么也不做，要么让程序终止</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">    <span class="type">bool</span> closed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吐下它们或者结束程序。</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么类应该提供一个普通函数(而非在析构函数中)执行该操作。</li>
</ul>
</blockquote>
<h2 id="9-绝不在构造和析构过程中调用virtual函数"><a href="#9-绝不在构造和析构过程中调用virtual函数" class="headerlink" title="9. 绝不在构造和析构过程中调用virtual函数"></a>9. 绝不在构造和析构过程中调用virtual函数</h2><p>这条规则是这么一个场景：在多态的基类构造或析构函数中调用重写的<code>virtual</code>函数，那么在派生类对象构造或析构时，调用的函数是基类的，并不是派生类重写后的。</p>
<p>因为在派生类构造时，先调基类的构造，此时派生类对象还不存在，并没有多态属性。析构也是同理，先把派生类释放了，再析构基类时，派生类对象也不存在了。</p>
<p>所以基类构造&#x2F;析构永远不要调用<code>virtual</code>函数，可行的方案是把<code>virtual</code>去掉，派生类通过传参调用。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>在构造和析构期间不要调用<code>virtual</code>函数，因为这类调用从不下降至派生类。</li>
</ul>
</blockquote>
<h2 id="10-令operator-x3D-返回一个-reference-to-this"><a href="#10-令operator-x3D-返回一个-reference-to-this" class="headerlink" title="10. 令operator&#x3D; 返回一个 reference to *this"></a>10. 令operator&#x3D; 返回一个 reference to *this</h2><p>赋值操作符必须返回一个reference指向操作符的左侧实参。这是一个约定协议，并无强制性。如果不遵循代码也不会报错。然而所有内置类型和标志程序库提供的类型如<code>string``vector``trl::shared_ptr</code>等都遵循这个约定。因此除非你有一个标新立异的好理由，不然还是随众吧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Widget&amp; rhs)   <span class="comment">// 赋值相关的运行也适用这个约定+=，-=，*=等</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">int</span> rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>请记住</strong></p>
<blockquote>
<p>令赋值操作符返回一个reference to *this。</p>
</blockquote>
<h2 id="11-在operator-x3D-中处理”自我赋值”"><a href="#11-在operator-x3D-中处理”自我赋值”" class="headerlink" title="11. 在operator&#x3D; 中处理”自我赋值”"></a>11. 在operator&#x3D; 中处理”自我赋值”</h2><p>重载赋值操作符时，要注意自我赋值的处理。像下面这样自我赋值时就会导致返回的指针指向一个已被删除的对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Widget w; w = w;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BitMap* pb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确的写法有3种方式：</p>
<blockquote>
<ol>
<li>在开始处验证自我赋值</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<ol start="2">
<li>记录旧对象，改变调用顺序</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Bitmap* pOrig = pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">delete</span> pOrig;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<ol start="3">
<li>创建副本做数据交换</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Widget <span class="built_in">temp</span>(rhs);   <span class="comment">// 为rhs数据创建副本</span></span><br><span class="line">    <span class="built_in">swap</span>(temp);         <span class="comment">// 将*this数据和副本的数据做交换</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>确保当对象自我赋值时<code>operator=</code>有良好行为。其中技术包括比较来源对象和目标对象的地址、精心周到的语句顺序、以及copy-and-swap。</li>
<li>确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。</li>
</ul>
</blockquote>
<h2 id="12-复制对象时勿忘其每一个成分"><a href="#12-复制对象时勿忘其每一个成分" class="headerlink" title="12. 复制对象时勿忘其每一个成分"></a>12. 复制对象时勿忘其每一个成分</h2><p>这里主要注意复制派生类对象时(<strong>拷贝构造函数和赋值操作符函数</strong>)，要<strong>主动调用其基类对应的复制函数</strong>。</p>
<p>先看下面不规范示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityCustomer</span>: <span class="keyword">public</span> Customer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">PriorityCustomer</span>(cosnt PriorityCustomer&amp; rhs);</span><br><span class="line">    PriorityCustomer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PriorityCustomer::<span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">: <span class="built_in">priority</span>(rhs.priority)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PriorityCustomer&amp; PriorityCustomer::<span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这种只复制了派生类中的成员，由于没有指定实参给基类的拷贝构造函数，则会调用默认不带参的构造函数来构造基类成员。</p>
<p>正确写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PriorityCustomer::<span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">: <span class="built_in">Customer</span>(rhs),      <span class="comment">// 调用基类构造函数</span></span><br><span class="line">  <span class="built_in">priority</span>(rhs.priority)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PriorityCustomer&amp; PriorityCustomer::<span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Customer::<span class="keyword">operator</span>=(rhs);  <span class="comment">// 调用基类赋值操作</span></span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果上面两个复制函数重复代码很多，也可以考虑把重复部分封装到一个如：init的私有函数中，给两者调用。</strong></p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>复制函数(拷贝构造函数和赋值操作符函数)应该确保复制对象内的所有成员变量及所有基类成分。</li>
<li>不要尝试以某个复制函数实现另一个复制函数。应该将共同部分放进第三个函数中，并由两个复制函数共同调用。</li>
</ul>
</blockquote>
<br>

<h1 id="三、资源管理"><a href="#三、资源管理" class="headerlink" title="三、资源管理"></a>三、资源管理</h1><h2 id="13-以对象管理资源"><a href="#13-以对象管理资源" class="headerlink" title="13. 以对象管理资源"></a>13. 以对象管理资源</h2><p>为了防止资源泄漏，我们管理资源的释放一般不人为维护，而是<strong>通过对象构造时引用资源，析构时释放资源来管理。</strong>这样管理资源的对象我们称之为<code>RAII</code>(Resource Acquisition Is Initialization)对象。如：<strong>智能指针</strong>就是这样的思路。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>为防止资源泄漏，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。</li>
<li>两个常被使用的RAII对象分别是shared_ptr和auto_ptr。前者通常是较佳选择，因为其copy行为比较直观。若选auto_prt，复制动作会使被复制对象变为null。</li>
</ul>
</blockquote>
<h2 id="14-在资源管理类中小心coping行为"><a href="#14-在资源管理类中小心coping行为" class="headerlink" title="14. 在资源管理类中小心coping行为"></a>14. 在资源管理类中小心coping行为</h2><p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。(参考不同类型智能指针行为)</li>
<li>普遍而常见的RAII对象的复制行为是：转移资源、抑制copying、施行引用计数法。（同样可参考不同类型智能指针实现）</li>
</ul>
</blockquote>
<h2 id="15-在资源管理类中提供对原始资源的访问"><a href="#15-在资源管理类中提供对原始资源的访问" class="headerlink" title="15. 在资源管理类中提供对原始资源的访问"></a>15. 在资源管理类中提供对原始资源的访问</h2><p>对于RAII类我们一般要提供对原始资源的访问。有两种方式：显示转换和隐式转换。</p>
<p>显示转换(提供一个接口get获取)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RAII类Font</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Font</span><span class="params">(FontHandle fh)</span> : f(fh) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Font</span>() &#123;<span class="built_in">releaseFont</span>(f);&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">FontHander <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> f;&#125;  <span class="comment">// 显示转换函数</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FontHandle f;    <span class="comment">// 原始资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeFontSize</span><span class="params">(FontHnadle f, <span class="type">int</span> newSize)</span></span>;</span><br><span class="line"><span class="function">Font <span class="title">f</span><span class="params">(getFont())</span></span>;</span><br><span class="line"><span class="type">int</span> newFontSize;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">changeFontSize</span>(f.<span class="built_in">get</span>(), newFontSize); <span class="comment">// 显示获取f的原始资源</span></span><br></pre></td></tr></table></figure>



<p>隐式转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">FontHandler</span><span class="params">()</span> <span class="type">const</span>    <span class="comment">// 隐式转换函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> f;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function">Font <span class="title">f</span><span class="params">(getFont())</span></span>;</span><br><span class="line"><span class="type">int</span> newFontSize;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">changeFontSize</span>(f, newFontSize);   <span class="comment">// 将Font隐式转换为FontHandler</span></span><br></pre></td></tr></table></figure>

<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>RAII往往要求访问原始资源，所以每一个RAII类应该提供一个“取得其所管理之资源”的办法。</li>
<li>对原始资源的访问可能经由显示转换或隐式转换。一般而言显示转换比较安全，但隐式转换对客户比较方便。</li>
</ul>
</blockquote>
<h2 id="16-成对使用new和delete时要采取相同形式"><a href="#16-成对使用new和delete时要采取相同形式" class="headerlink" title="16. 成对使用new和delete时要采取相同形式"></a>16. 成对使用new和delete时要采取相同形式</h2><p>如果new对象，对应delelte对象，如果new数组，对应delete数组(加[])。这点很容易，不过注意一种情况，对数组使用了typedef重命名后，就比较隐蔽了。所以约定尽量不要对数组形式做typedef动作。这很容易达成，因为C++标准库含有string,vector等template，可将数组的需求降至几乎为零。</p>
<p><strong>请记住</strong></p>
<blockquote>
<p>如果你在new表达式中使用[]，必须在相应的delete表达式中也使用[]。如果你在new表达式中不使用[]，一定不要在相应的delete表达式中使用[]。</p>
</blockquote>
<h2 id="17-以独立语句将new对象置入智能指针"><a href="#17-以独立语句将new对象置入智能指针" class="headerlink" title="17. 以独立语句将new对象置入智能指针"></a>17. 以独立语句将new对象置入智能指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure>

<p>编译器在调用<code>processWidget</code>之前，必须首先核算即将被传递的各个实参。上面第二实参只是一个单纯的对<code>priority</code>函数的调用，但第一实参<code>std::tr1::shared_ptr&lt;Widget&gt;(new Widget)</code>由两部分组成：</p>
<ul>
<li>执行<code>new Widget</code>表达式</li>
<li>调用<code>shared_ptr构造函数</code></li>
</ul>
<p>于是在调用<code>processWidget</code>之前，编译器必须创建代码，做以下三件事：</p>
<ul>
<li>调用<code>priority</code></li>
<li>执行<code>new Widget</code>表达式</li>
<li>调用<code>shared_ptr构造函数</code></li>
</ul>
<p>c++编译器以什么样的次序完成这些事情呢？弹性很大。不过可以确定的是<code>new Widget</code>一定执行在<code>share_ptr构造函数</code>之前，因为这个表达式的结果还要被传递作为<code>shard_ptr构造函数</code>的一个实参，但对<code>priority函数</code>的调用则可以排在第一或第二或第三执行。如果编译器选择第二顺位执行它，最终获得这样的操作序列：</p>
<ol>
<li>执行<code>new Widget</code>表达式</li>
<li>调用<code>priority</code></li>
<li>调用<code>shared_ptr构造函数</code></li>
</ol>
<p>问题来了，如果2执行失败，抛异常了，那么1 new的内存还没来得及置入智能指针中，就导致内存泄漏了。</p>
<p>解决上面问题办法很简单，就是分离语句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">tr1::shared_ptr&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line"><span class="built_in">processWidget</span>(pw, <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure>

<p>以上之所以行得通，因为编译器对于跨语句的各项操作没有重新排序的自由(只有在语句内它拥有那个自由度)。</p>
<p><strong>请记住</strong></p>
<blockquote>
<p>以独立语句将new对象置入智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄漏。</p>
</blockquote>
<br>

<h1 id="四、-设计与声明"><a href="#四、-设计与声明" class="headerlink" title="四、 设计与声明"></a>四、 设计与声明</h1><h2 id="18-让接口容易被正确使用，不易被误用"><a href="#18-让接口容易被正确使用，不易被误用" class="headerlink" title="18. 让接口容易被正确使用，不易被误用"></a>18. 让接口容易被正确使用，不易被误用</h2><p><strong>理想上，如果客户企图使用某个接口而却没有获得他所预期的行为，这个代码就不该通过编译；如果代码通过了编译，它的行为就该是客户所想要的。</strong>尽量不要在运行期才发现问题。</p>
<p>示例一 日期的class设计构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> month, <span class="type">int</span> day, <span class="type">int</span> year);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面接口设计很容易让客户至少犯下两个错误。</p>
<ol>
<li>他们也许会以错误的次序传递参数。</li>
<li>他们可能传递一个无效的月份或者天数。</li>
</ol>
<p>正确的设计是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限制类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Day</span><span class="params">(<span class="type">int</span> d)</span> : val(d) &#123;</span>&#125;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Month</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Month</span><span class="params">(<span class="type">int</span> m)</span> : val(m) &#123;</span>&#125;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Year</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Year</span><span class="params">(<span class="type">int</span> y)</span> : val(y) &#123;</span>&#125;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">const</span> Month&amp; m, <span class="type">const</span> Day&amp; d, <span class="type">const</span> Year&amp; y);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Month(<span class="number">12</span>), Day(<span class="number">1</span>), Year(<span class="number">2022</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进一步限制参数的值有效性设计，如：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Month</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Month <span class="title">Jan</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">Month</span>(<span class="number">1</span>);&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> Month <span class="title">Feb</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">Month</span>(<span class="number">2</span>);&#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">static</span> Month <span class="title">Dec</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">Month</span>(<span class="number">12</span>);&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Month</span><span class="params">(<span class="type">int</span> m)</span></span>;</span><br><span class="line">    ...                           </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用, 这样月份的值就由类里边约定好了</span></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Month::Dec(), Day(<span class="number">1</span>), year(<span class="number">2022</span>))</span></span>;</span><br></pre></td></tr></table></figure>



<p>示例二：通用行为接口一致性，与标准、内置类型尽量保持一致。STL容器的接口就十分一致，这使得它们非常容易被使用。例如每个STL容器都有一个名为size的成员函数，它会告诉调用者目前容器内有多少对象。</p>
<p>示例三：接口返回指针应该返回智能指针，不应该对外返回原始指针，客户还要关系指针释放操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">createInvestment</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>shared_ptr智能指针还一个特性，就是在创建时还可以指定自定义析构行为。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1 是原始指针 参数2 引用计数为0时执行函数deleteFunc</span></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">retVal</span><span class="params">(<span class="keyword">static_cast</span>&lt;Investment*&gt;(<span class="number">0</span>), deleteFunc)</span></span>;</span><br></pre></td></tr></table></figure>

<p>接口返回智能指针还消除另一个潜在的客户错误，就是跨dll传递问题。这个问题发生于对象在动态库中被new创建，却在另一个动态库内被delete销毁。在许多平台上，这类问题会导致运行期错误。而使用shared_ptr就没有这个问题，因为当引用计数为0时会追踪调用原始那个动态库上的销毁。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>好的接口很容易被正确使用，不容易被误用。你应该在你的所在接口中努力达成这些性质。</li>
<li>”促进正确使用“ 的办法包括接口的一致性，以及与内置类型的行为兼容。</li>
<li>”阻止误用“ 的办法包括建立新类型、限制类型上的操作(private)、束缚对象值，以及消除客户的资源管理责任。</li>
<li>tr1::share_ptr支持定制型删除器。这可防范dll问题，可被用来自动解除互斥锁(RAII类设计管理锁)等等。</li>
</ul>
</blockquote>
<h2 id="19-设计class犹如设计type"><a href="#19-设计class犹如设计type" class="headerlink" title="19. 设计class犹如设计type"></a>19. 设计class犹如设计type</h2><p>类本质是自定义的类型，要像设计内置类型一样设计类。重载函数和操作符、控制内存的分配和归还、定义对象的初始化和终结……全都在你手上。</p>
<p>设计优秀的类是一项艰巨的工作，甚至类的成员函数效率都有可能受到它们“如何被声明”的影响。那么如何设计高效的类呢？下面提出了一些问题，你的回答往往导致你的设计规范：</p>
<ul>
<li><strong>新type的对象应该如何被创建和销毁？</strong>这会影响到你的构造函数和析构函数以及内存分配函数和释放函数(operator new, operator [], operator delete和operator delete[]) 的设计。(见第8章)</li>
<li><strong>对象的初始化和对象的赋值该有什么样的差别？</strong>这个答案决定你的构造函数和赋值操作符的行为。(见条款4)</li>
<li><strong>新type的对象如果以值传递，意味着什么？</strong>记住copy构造函数决定了你以值传递的行为。</li>
<li><strong>什么是新type的合法值？</strong>对class外部传入的参数一定要做错误检测工作。</li>
<li><strong>你的新type要考虑继承或被继承影响么？</strong>如果你继承已有的classes，你就受到那些classes的设计的束缚，特别是受到它们的函数是<code>virtual</code>或<code>non-virtual</code>的影响。如果你允许其它classes继承你的class,那会影响你所声明的函数，尤其是析构函数是否加<code>virtual</code>。(见条款7、34、36)</li>
<li><strong>你的新type需要什么样的转换？</strong>你是否希望你的type和其它types之间可以转换，是隐式转换或显示转换。或者不允许隐式转换，只允许<code>explicit</code>的构造函数存在，就得写出专门负责执行转换的函数。(条款15有显示&#x2F;隐式转换函数范例)</li>
<li><strong>什么样的操作符和函数对新type是合理的？</strong>这个问题答案决定你将为你的class声明哪些函数。其中哪些该是成员函数，哪些不该。(见条款23，24，46)</li>
<li><strong>什么样的标准函数应该驳回？</strong>这些正是你必须声明为private的，而且不去实现。(见条款6)</li>
<li><strong>谁该取用新type的成员？</strong>这个提问可以帮助你决定哪些成员为public，哪些为protected，哪些为private。它也帮助你决定哪些classes或functions应该是friends，以及将它们嵌套于另一个之内是否合理。</li>
<li><strong>新type的内部约束？</strong>它对效率、异常安全性(见条款29)以及资源使用(如多任务锁和动态内存)提供何种保证？你在这些方面提供的保证将为你的class实现代码加上相应的约束条件。</li>
<li><strong>你的新type有多么一般化？</strong>或许你其实并非定义一个新type，而是定义一整个types家族。果真如此你就不该定义一个新class，而是应该定义一个新的class template。</li>
<li><strong>你真的需要一个新type吗？</strong>如果只是定义新的派生类以便为既有的class添加机能，那么说不定单纯定义一个或多个非成员函数或templates，更能够达到目标。</li>
</ul>
<p>这些问题不容易回答，所以定义出高效的classes是一种挑战。然而如果能够设计出至少像C++内置类型一样好的用户自定义classes，一切汗水便都值得。</p>
<p><strong>请记住</strong></p>
<blockquote>
<p>Class的设计就是type的设计。在定义一个新type之前，请确定你已经考虑过上面所有讨论主题。</p>
</blockquote>
<h2 id="20-传引用替代传值-函数参数"><a href="#20-传引用替代传值-函数参数" class="headerlink" title="20. 传引用替代传值(函数参数)"></a>20. 传引用替代传值(函数参数)</h2><p>函数参数都是以实际实参的副本为初值，而调用端所获得的亦是函数返回值的一个副本。这些副本是由对象的copy构造函数产出。</p>
<p>值传递会调用对象的copy构造函数，使用完又调用析构函数。如果比较复杂对象，还有嵌套子对象，这样值传参是昂贵费时的。通过引用传递，底层实际是传递的对象指针，这样对象的copy构造函数和析构函数都不会调用。</p>
<p><strong>请记住</strong></p>
<blockquote>
<p>尽量以引用传递替换值传递。前者通常比较高效，并可避免切割问题(派生对象给基类)。</p>
<p>以上规则并不适用与内置类型，以及STL的迭代器和函数对象。对它们而言，值传递往往比较适当。</p>
</blockquote>
<h2 id="21-必须返回对象时，别返回引用-函数返回值"><a href="#21-必须返回对象时，别返回引用-函数返回值" class="headerlink" title="21. 必须返回对象时，别返回引用(函数返回值)"></a>21. 必须返回对象时，别返回引用(函数返回值)</h2><p><strong>请记住</strong></p>
<blockquote>
<p>绝不要返回指针或引用指向一个栈区对象(函数返回后销毁了)，或返回引用指向一个堆区对象(增加内存泄漏风险)，或返回指针或引用指向一个static对象而由可能同时需要多个这样的对象(条款4已经为“在单线程环境中合理返回引用指向一个static对象”提供了一份设计示例)。</p>
</blockquote>
<h2 id="22-将成员变量声明为private"><a href="#22-将成员变量声明为private" class="headerlink" title="22. 将成员变量声明为private"></a>22. 将成员变量声明为private</h2><p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>切记将成员变量声明为private。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供class作者以充分的实现弹性。</li>
<li>protected并不比public更具封装性。从封装角度讲，其实只有两种访问权限：private(提供封装)和其它(不提供封装)。</li>
</ul>
</blockquote>
<h2 id="23-宁以non-member、non-friend替换member函数"><a href="#23-宁以non-member、non-friend替换member函数" class="headerlink" title="23. 宁以non-member、non-friend替换member函数"></a>23. 宁以non-member、non-friend替换member函数</h2><p>首先要知道，class里member函数越多，意味着能访问private成员变量的函数越多，封装性越低。如果要你在一个member函数和一个non-member,non-friend函数之间做抉择，而且两者都能实现相同的机能，那么，导致较大封装性的是后者，因为它并不增加能够访问class内的private成分的函数数量。</p>
<p>这个条款多见应用场景是<strong>工具函数的封装</strong>，头文件还可以根据功能分类出多个并加上namespace保护。头文件按功能分类成多个，使用时才可以按需只导入自己需要的。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>宁可拿non-member、non-friend函数替换member函数。这样做可以增加封装性、包裹弹性和机能扩展性。</li>
</ul>
</blockquote>
<h2 id="24-若所有参数皆需类型转换，请为此采用non-member函数"><a href="#24-若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="24. 若所有参数皆需类型转换，请为此采用non-member函数"></a>24. 若所有参数皆需类型转换，请为此采用non-member函数</h2><p>这点书中示例感觉有点牵强，就举例了一个<code>operator*</code>函数为了满足交换律，所以把<code>operator*</code>封装到了class之外。就得出此条款感觉前后并没有必然联系~ 相关条款46。</p>
<p>todo: 待后续再读解惑~ </p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>如果你需要为某个函数的所有参数进行类型转换，那么这个函数必须是个non-member。</li>
</ul>
</blockquote>
<h2 id="25-考虑写出一个不抛异常的swap函数"><a href="#25-考虑写出一个不抛异常的swap函数" class="headerlink" title="25. 考虑写出一个不抛异常的swap函数"></a>25. 考虑写出一个不抛异常的swap函数</h2><p>怎么写一个高效且不抛异常的swap？一般而言这两点是一起的，因为高效率的swap几乎总是基于对内置类型的操作，而内置类型上的操作绝不会抛出异常。</p>
<p>首先看看std标准库提供的swap算法，大概下面这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp;b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要类型T支持copy构造函数和copy操作符就行。它并不高效，涉及了3个对象的复制。所以针对自定义类我们常常要定制swap，看看下面示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetImpl</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; v;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs);</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        *pImpl = *(rhs.pImpl);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   WidgetImpl* pImpl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察Widget对象置换，其实只要置换pImpl指针就行了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Widget内部增加swap定制接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(pImpl, other.pImpl);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时为std::swap添加这个定制版本。STL容器也是这么干的，同时提供了public swap成员函数和std::swap定制版本。</span></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;  <span class="comment">// 声明下面Widget是定制版本</span></span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还一种情况，如果上面Widget和WidgetImpl都是模板类而非类的话。那就不能std里添加定制swap了(编译不通过)，需要用non-member函数替代。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff &#123; <span class="comment">// 加命名空间是个好习惯</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WidgetImpl</span> &#123;...&#125;</span><br><span class="line">    <span class="comment">// 模板类，内含swap成员函数 </span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Widget</span> &#123;...&#125;;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// non-member函数的swap</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>当std::swap对你的类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常。</li>
<li>如果你提供一个member swap，也该提供一个non-member swap用来调用前者。对于classes(而非templates),也请提供定制std::swap。</li>
<li>调用swap时应针对std::swap使用using声明，然后调用swap并且不带任何”命名空间修饰”。</li>
<li>为自定义类型进行std::swap定制是好的，但是往std中新增templates是不允许的。</li>
</ul>
</blockquote>
<br>

<h1 id="五、实现"><a href="#五、实现" class="headerlink" title="五、实现"></a>五、实现</h1><h2 id="26-变量尽可能在使用时定义"><a href="#26-变量尽可能在使用时定义" class="headerlink" title="26. 变量尽可能在使用时定义"></a>26. 变量尽可能在使用时定义</h2><p>提前定义变量，有可能导致变量并没有使用(如中间抛异常了)，而平白多了一个构造和析构成本。</p>
<p>但是循环怎么办？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式A</span></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    w = xxx;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式B</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    Widget w = xxx;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做法A：1个构造 + 1个析构  +  n个赋值操作</p>
<p>做法B：n个构造函数  +  n个析构函数</p>
<p>打破本条款选择A的依据：</p>
<p>（1）你知道赋值成本比“构造+析构”成本低。</p>
<p>（2）你正在处理代码中效率高度敏感的部分。</p>
<p>否则你应该使用做法B，维持变量尽可能在使用时定义的原则。</p>
<p><strong>请记住</strong></p>
<blockquote>
<p>尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。</p>
</blockquote>
<h2 id="27-尽量少做转型动作"><a href="#27-尽量少做转型动作" class="headerlink" title="27. 尽量少做转型动作"></a>27. 尽量少做转型动作</h2><p>C语言风格类型转换(老式)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(T)expression   // 显示强转</span><br><span class="line"> </span><br><span class="line">T(expression)   // 构造隐式转换</span><br></pre></td></tr></table></figure>

<p>C++新式转换，提倡统一都用新式风格，职能分类，更安全，更清晰。</p>
<ul>
<li><p>const_cast<T>(expression)  用于将对象的常量性移除。也是唯一有此能力的C++-style转型操作符。</T></p>
</li>
<li><p>dynamic_cast<T>(expression)  一般用于安全向下转型，如基类到派生类。要谨慎，可能效率低下。</T></p>
</li>
<li><p>static_cast<T>(expression)  用来强制隐式转换，一般用于相关联类型转换，没有类型检测。如将int转double，派生类转基类(安全)，基类转派生类(不安全)等。</T></p>
</li>
<li><p>reinterpret_cast<T>(expression)  一般用于不相干类型转换，没有限制。如int* 转int，int转函数指针等。常用于转换函数指针，即可以将一种类型的函数指针转换为另一种类型的函数指针。</T></p>
</li>
</ul>
<p>转型破环了类型系统。那可能导致任何种类的麻烦，有些容易识别，有些非常隐晦。所以尽量少做转型操作。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_cast。如果有个设计需要转型动作，试着发展无需转型的替代设计。</li>
<li>如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需要将转型操作放进客户代码中。</li>
<li>宁可使用C++-style转型，不要使用旧式转型。前者很容易识别出来，而且也比较有着分门别类的职掌。</li>
</ul>
</blockquote>
<h2 id="28-尽量避免返回handles指向对象内部成分"><a href="#28-尽量避免返回handles指向对象内部成分" class="headerlink" title="28. 尽量避免返回handles指向对象内部成分"></a>28. 尽量避免返回handles指向对象内部成分</h2><p>handers是指：对象内的子对象的引用、指针或迭代器。返回子对象的引用、指针、迭代器会降低封装性，外部能越级访问深层级的对象并修改属性。</p>
<p>这并不意味着你绝对不可以让成员函数返回handle。有时候你必须那么做。例如operator[]就允许你获取strings和vectors的元素。尽管如此，这样的函数毕竟是例外，不是常态。</p>
<p><strong>请记住</strong></p>
<blockquote>
<p>避免返回handles(包括引用、指针、迭代器)指向对象内部。遵守这条条款可增加封装性，帮助const成员函数的行为像个const，并将发生”虚吊号码牌“的可能性降至最低。</p>
</blockquote>
<h2 id="29-为”异常安全”而努力是值得的"><a href="#29-为”异常安全”而努力是值得的" class="headerlink" title="29. 为”异常安全”而努力是值得的"></a>29. 为”异常安全”而努力是值得的</h2><p>我们要时刻要求自己写的函数都是异常安全函数。</p>
<p>异常安全函数有两个条件：</p>
<ol>
<li>不泄漏任何资源。</li>
<li>不允许数据败坏。</li>
</ol>
<p>同时，异常安全函数业内分了3个级别保证，你至少满足其中之一。</p>
<ol>
<li>基本承诺：如果抛出异常，程序内的任何事物仍然保持在有效状态下。</li>
<li>强烈保证：如果抛出异常，程序状态不改变。如果函数成功，就是完全成功，如果函数失败，程序会回到调用函数之前的状态。</li>
<li>不抛异常保证：承诺绝不抛出异常，所有操作都是作用于内置类型身上。</li>
</ol>
<p>一般而言，我们都应该尽量做到强烈保证这个级别。而最高级别很多时候很难做到，任何使用动态内存的东西如果内存不足都有可能抛出异常。</p>
<p>下面是为编写异常安全函数而努力的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span>;  <span class="comment">// 改变背景图片</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;    <span class="comment">// 多线程环境，互斥锁</span></span><br><span class="line">    Image* bgImage;  <span class="comment">// 当前背景图片</span></span><br><span class="line">    <span class="type">int</span> imageChanges; <span class="comment">// 背景图片改变次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是我们最常规思路的实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">delete</span> bgImage;</span><br><span class="line">    ++imageChanges;</span><br><span class="line">    bgImage = <span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc);</span><br><span class="line">    <span class="built_in">unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个常规思路的实现，如果new Image抛异常，lock资源泄漏，bgImage，imageChanges数据也招到破坏。不满足异常安全函数条件任何一个。下面我们来看怎么解决这两个问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    std::tr1::shared_ptr&lt;Image&gt; bgImage;  <span class="comment">// 智能指针</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;   <span class="comment">// 封装锁，见条款14</span></span><br><span class="line">    bgImage.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc));</span><br><span class="line">    ++imageChanges;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做到这里还只能说满足基本承诺，如果Image构造函数抛异常(这里抛异常由编译器内部实现)，有可能破环外部引用的imgSrc数据源(todo:这里有点牵强~感觉做到这一步已经是强烈保证了！)。</p>
<p>还记得我们前面写过一个不抛异常的swap么？就可以用在这里，我们让改变背景图片的操作先在副本对象中操作，都正确操作完后，在用swap交换数据，这样就保证了即使失败了也不会影响原有数据状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PMImpl</span> &#123;</span><br><span class="line">    std::tr1::shared_ptr&lt;Image&gt; bgImage;</span><br><span class="line">    <span class="type">int</span> imageChanges;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    std::tr1::shared_ptr&lt;PMImpl&gt; pImpl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    std::<span class="function">tr1::shared_ptr&lt;PMImpl&gt; <span class="title">pNew</span><span class="params">(<span class="keyword">new</span> PMImpl(*pImpl))</span></span>; <span class="comment">// 副本对象</span></span><br><span class="line">    pNew-&gt;bgImage.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc));</span><br><span class="line">    ++pNew-&gt;imageChanges;</span><br><span class="line">    <span class="built_in">swap</span>(pImpl, pNew);  <span class="comment">// 交互数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>强烈保证并非时刻都显得实际，也要衡量空间、效率成本。当强烈保证不切实际时，你就必须保证提供基本保证。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>异常安全函数即使发生异常也不会泄漏资源或允许任何数据结构破坏。这样的函数有3中可能的保证：基本型、强烈型、不抛异常型。</li>
<li>强烈保证往往能够以swap来实现出来，但强烈保证并非对所有函数都可实现或具备现实意义。</li>
<li>函数提供的“异常安全保证”通常最高只等于其所调用的各个函数的异常安全保证中的最低者。</li>
</ul>
</blockquote>
<h2 id="30-透彻了解inline的里里外外"><a href="#30-透彻了解inline的里里外外" class="headerlink" title="30. 透彻了解inline的里里外外"></a>30. 透彻了解inline的里里外外</h2><p>inline行为发生在编译期间，编译器是否要进行inline，不是取决于函数带不带inline，有时带了inline也不一定会inline(virtual函数，运行时才知道调用哪个)，没带也可能inline(实现在头文件中)。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>将大多数inline限制在<strong>小型</strong>、<strong>被频繁调用</strong>的函数身上。这可使日后的调试过程和二进制升级更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。</li>
<li>不要只因为函数模板出现在头文件中定义，就将它们声明为inline。</li>
</ul>
</blockquote>
<h2 id="31-将文件间的编译依赖关系降至最低"><a href="#31-将文件间的编译依赖关系降至最低" class="headerlink" title="31. 将文件间的编译依赖关系降至最低"></a>31. 将文件间的编译依赖关系降至最低</h2><p>直接看示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相关头文件引入</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;date.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;address.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;</span><br><span class="line">    Date theBirthDate;</span><br><span class="line">    Address theAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面Person定义文件和其包含的文件之间形成了一种编译依赖关系。如果这些头文件中任何一个被改变，或这些头文件所依赖的其他头文件有任何改变，那么每一个包含Person class的文件就得重新编译。这样的连串编译依赖关系会对许多项目造成难以形容的灾难。</p>
<p>解决这个问题的<strong>本质是让类的接口与实现分离</strong>(加快编译速度)。通常有两种做法：</p>
<p>第一种拆分两个类，一个用于声明，一个用于实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class 只是声明这个类，没有定义信息，可以使用类的引用和指针(大小固定)，不能有定义。减少编译依赖手段。</span></span><br><span class="line"><span class="comment">// include 则是把整个类导入，包含了定义信息，也注入了依赖相关，增加了编译时间。 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonImpl</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::tr1::shared_ptr&lt;PersonImpl&gt; pImpl;  <span class="comment">// 指向实现类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Person.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PersonImpl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Person::<span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr)</span><br><span class="line">    : <span class="built_in">pImpl</span>(<span class="keyword">new</span> <span class="built_in">PersonImpl</span>(name, birthday, addr))</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Person::name</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pImpl-&gt;<span class="built_in">name</span>();  <span class="comment">// simunps的fileManger封装就是类似这种做法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将实现分开后，即使修改了实现部分逻辑，对包含了Person接口类的其它类也没有影响，不需要重新编译。</p>
<p>第二种是用接口类。</p>
<p>这种类的目的是详细一一描述派生类的接口，因此它通常没有成员变量，也没有构造函数，只有一个virtual析构函数以及一组纯虚函数声明。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口定义，外部使用通过基类的create接口即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>();</span><br><span class="line">    <span class="type">static</span> std::<span class="function">tr1::shared_ptr&lt;Person&gt; <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::string&amp; name, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> Date&amp; birthday, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> Address&amp; addr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Person&gt; <span class="title">Person::create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; name, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Date&amp; birthday, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Address&amp; addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::tr1::<span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> <span class="built_in">RealPerson</span>(name, birthday, addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealPerson</span> : Person &#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">RealPerson</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr)</span><br><span class="line">     : <span class="built_in">theName</span>(name), <span class="built_in">theBirthDate</span>(birthday), <span class="built_in">theAddress</span>(addr)</span><br><span class="line">     &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">RealPerson</span>() &#123;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;</span><br><span class="line">    Date theBirthDate;</span><br><span class="line">    Address theAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>支持编译依赖最小化的一般构想是：依赖声明式的头文件，不要依赖定义式的头文件。(声明与定义拆两个类，外部只include声明的类头文件) 基于此构想有两种手段：接口与实现拆分两个类和接口类。</li>
<li>程序库头文件应该以“完全且仅有声明式的形式存在。就是include的类都是声明式的类，其真实实现在另一个类中。</li>
</ul>
</blockquote>
<br>

<h1 id="六、继承与面向对象设计"><a href="#六、继承与面向对象设计" class="headerlink" title="六、继承与面向对象设计"></a>六、继承与面向对象设计</h1><h2 id="32-公有继承"><a href="#32-公有继承" class="headerlink" title="32. 公有继承"></a>32. 公有继承</h2><p>公有继承：继承过来的基类成员访问属性不变。</p>
<p>保护继承：继承过来的基类中的私有成员访问属性不变，公有成员和保护成员变为保护成员。</p>
<p>私有继承：继承过来的基类中的私有成员属性不变，公有成员和保护成员变为私有成员。</p>
<p>不管是哪种继承方式，派生类中成员可以访问基类的公有成员和保护成员，无法访问私有成员。而继承方式影响的是派生类继承成员的<strong>访问属性</strong>。</p>
<p><strong>请记住</strong></p>
<blockquote>
<p>public继承：适用于base classes身上的每一件事情一定也适用与derived classes身上，因为每一个derived class对象也都是一个base class对象。</p>
</blockquote>
<h2 id="33-避免遮掩继承而来的名称"><a href="#33-避免遮掩继承而来的名称" class="headerlink" title="33. 避免遮掩继承而来的名称"></a>33. 避免遮掩继承而来的名称</h2><p>派生类中函数会遮掩基类中的同名函数。从名称查找来看，像是基类中对应的同名函数没被继承过来一样。简单来说就是作用域问题，派生类覆盖基类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.<span class="built_in">mf1</span>();      <span class="comment">// 没问题，调用Derived::mf1</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);     <span class="comment">// 报错！Derived::mf1遮掩了同名的Base::mf1</span></span><br><span class="line">d.<span class="built_in">mf2</span>();      <span class="comment">// 没问题，调用Base::mf2</span></span><br><span class="line">d.<span class="built_in">mf3</span>();      <span class="comment">// 没问题，调用Derived::mf3</span></span><br><span class="line">d.<span class="built_in">mf3</span>(x);     <span class="comment">// 报错，Derived::mf3遮掩了Base::mf3</span></span><br></pre></td></tr></table></figure>

<p>如果不想被派生类同名函数把基类中所有其它重载函数都遮掩了，可以使用using声明。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用using后，上面两处报错的都可以找到Base::mf1/Base::mf3了。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::mf1;     <span class="comment">//Base class中名为mf1和mf3的所有东西，</span></span><br><span class="line">    <span class="keyword">using</span> Base::mf3;     <span class="comment">//在Derived中都可见</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转交函数，一般用于私有继承中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span>  <span class="comment">// 转交函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	Base::<span class="built_in">mf1</span>();    <span class="comment">// 派生类函数调用基类对应函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不想要外边访问基类中任何成员，可以用私有继承实现(private)。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>derived class 内的名称会遮掩base class 内的名称。在public继承下从来没有人希望如此。所以这点要特别注意(使用using)。</li>
<li>为了让被遮掩的名称再见天日，可使用using声明式或转交函数。</li>
</ul>
</blockquote>
<h2 id="34-区分接口继承和实现继承"><a href="#34-区分接口继承和实现继承" class="headerlink" title="34. 区分接口继承和实现继承"></a>34. 区分接口继承和实现继承</h2><p>业内默认约定基类中的成员函数用途：</p>
<ul>
<li>纯虚函数：derived class只想继承其声明，实现由derived class自己实现。</li>
<li>虚函数：derived class希望同时继承函数的接口和实现，但又希望能够覆写它们所继承的实现。</li>
<li>普通函数：derived class只想继承函数的接口和实现，并且不允许我自己再覆写。</li>
</ul>
<p>依据上面约定你应该就知道成员函数属性应该怎么声明了。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>接口继承和实现继承不同。在public继承之下，derived class总是继承base class的接口。</li>
<li>纯虚函数只具体指定接口继承。</li>
<li>虚函数具体指定接口继承及默认的实现继承。</li>
<li>普通函数具体指定接口继承以及强制性实现继承。</li>
</ul>
</blockquote>
<h2 id="35-考虑virtual函数以外的其他选择"><a href="#35-考虑virtual函数以外的其他选择" class="headerlink" title="35. 考虑virtual函数以外的其他选择"></a>35. 考虑virtual函数以外的其他选择</h2><p>条款34刚说了，在我们希望同时继承函数的接口和实现，但又希望能够覆写它们所继承的实现时用virtual函数。</p>
<p>而这里是这种场景的一些其它流派主张思想。</p>
<p>第一种，Non-Virtual Interface(NVI)，主张virtual函数应该几乎总是private。这个较好的设计是用一个non-vitual函数去调用一个private virtual函数。这样我们就提供了在调用private virtual函数前后做一些额外操作空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这里inline只是为了演示示例</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span>    <span class="comment">// 普通成员函数派生类不要重新定义它，见条款36</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...                    <span class="comment">// 做一些事前工作</span></span><br><span class="line">        <span class="type">int</span> retVal = <span class="built_in">doHealthValue</span>();</span><br><span class="line">        ...                    <span class="comment">// 做一些事后工作</span></span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">doHealthValue</span><span class="params">()</span> <span class="type">const</span>   <span class="comment">// 虚函数，派生类可重写</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种，把这个虚函数提到类外边以一个普通函数存在，然后类的构造函数接收一个函数指针指向这个函数。把实现从类成员中剥离出去。— Strategy设计模式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HealthCalcFunc)</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>; <span class="comment">// 函数指针形式</span></span><br><span class="line">    <span class="comment">// 另一种使用tr1::function更灵活，它是一个类模板，其成员变量是一个函数指针。</span></span><br><span class="line">    <span class="comment">// 函数指针只支持指向外部普通函数，而function对象还支持类成员函数可以(结合bind，绑定this)。</span></span><br><span class="line">    <span class="comment">// typedef std::tr1::function&lt;int (const GameCharacter&amp;)&gt; HealthCalcFunc;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span> : healthFunc(hcf)</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的好处是：</p>
<ul>
<li>同一个类之下不同的对象可以有不同的defaultHealthCalc实现。</li>
<li>某个类对象的defaultHealthCalc可在运行期变更。</li>
</ul>
<p>todo: 本条款具体使用场景还是没有深刻理解其好处，待后续遇到再回顾~</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>virtual 函数的替代方案包括NVI手法和Strategy设计模式的多种形式。NVI手法自身是一个特殊形式的Template Method设计模式。</li>
<li>将机能从成员函数移到class外部函数，带来的一个缺点是，这个非成员函数无法访问class的非公有成员。</li>
<li>tr1::function对象的行为就像一般函数指针。比函数指针能多接纳一些特别的函数。</li>
</ul>
</blockquote>
<h2 id="36-绝不重新定义继承而来的非虚函数"><a href="#36-绝不重新定义继承而来的非虚函数" class="headerlink" title="36. 绝不重新定义继承而来的非虚函数"></a>36. 绝不重新定义继承而来的非虚函数</h2><p>好习惯约定！</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>绝对不要重新定义继承而来的non-virtual函数。</li>
</ul>
</blockquote>
<h2 id="37-绝不重新定义继承而来的缺省参数值"><a href="#37-绝不重新定义继承而来的缺省参数值" class="headerlink" title="37. 绝不重新定义继承而来的缺省参数值"></a>37. 绝不重新定义继承而来的缺省参数值</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">ShapeColor</span> &#123;Red, Green, Blue&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>:<span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Green)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shape* pr = <span class="keyword">new</span> Rectangle;</span><br><span class="line">pr-&gt;<span class="built_in">draw</span>(); </span><br></pre></td></tr></table></figure>

<p>上面代码我们都知道最后的pr-&gt;draw调用的是Rectangle里覆写后的draw，这很正常没什么问题。</p>
<p>诡异的是缺省的参数却是用的Red，而不是自己的Green。</p>
<p>导致这个结果的原因是编译器优化的手段，缺省参数是静态绑定的(运行之前确定)，而virtual函数是动态绑定的(运行时确定)。所有上面pr-&gt;draw的调用就出现接口是用的派生类的，而缺省参数用的基类的。</p>
<p>这种表现会给阅读代码的人带来歧义，所以：</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定的，而virtual函数是你唯一应该覆写的东西，却是动态绑定。</li>
</ul>
</blockquote>
<h2 id="38-类的子对象"><a href="#38-类的子对象" class="headerlink" title="38. 类的子对象"></a>38. 类的子对象</h2><p>区分类的继承，B继承A，我们可以说<strong>B是A</strong>，而B中包含A子对象，我们一般说<strong>B中有A</strong>，而不能说B是A了。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>子对象的意义和public继承完全不同。</li>
</ul>
</blockquote>
<h2 id="39-明智而审慎地使用private继承"><a href="#39-明智而审慎地使用private继承" class="headerlink" title="39. 明智而审慎地使用private继承"></a>39. 明智而审慎地使用private继承</h2><p>这条目前认为没什么记录的，就是前面讲的私有继承。</p>
<h2 id="40-明智而审慎地使用多重继承"><a href="#40-明智而审慎地使用多重继承" class="headerlink" title="40. 明智而审慎地使用多重继承"></a>40. 明智而审慎地使用多重继承</h2><p>多重继承，两个常见问题：</p>
<ol>
<li>C继承A和B，如果A、B里有相同的成员，那么C直接调用这些成员就会有歧义，不知道调用A的还是B的。所以正确调用要明确指明，C.A::xxxFunc();</li>
<li>多层继承中，B、C继承A，D继承B和C，那么常规D中有两份A，如果不想要两份就得用virtual(虚基类里会增加一个指针大小)，虚继承。</li>
</ol>
<p>多重继承我的建议是能避免就尽量避免。不能避免你就要清楚它带来的问题和内部实现成本消耗细节。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>多重继承比单一继承复杂。它可能导致新的歧义性，以及对virtual继承的需要。</li>
<li>virtual继承会增加大小、速度、初始化及赋值复杂度等成本。如果virtual base classe不带任何数据，将是最具实用价值的情况。</li>
<li>多重继承的确有正当用途。其中一个场景涉及public继承某个Interface class和private继承某个协助实现的class的两相组合。</li>
</ul>
</blockquote>
<br>



<h1 id="七、模板与泛型编程"><a href="#七、模板与泛型编程" class="headerlink" title="七、模板与泛型编程"></a>七、模板与泛型编程</h1><h2 id="41-了解隐式接口和编译期多态"><a href="#41-了解隐式接口和编译期多态" class="headerlink" title="41. 了解隐式接口和编译期多态"></a>41. 了解隐式接口和编译期多态</h2><p>隐式接口：函数模板，类型不清楚，对我们来说接口是隐藏的。</p>
<p>显示接口：我们常规的头文件接口声明就是显示接口，明确了返回值，参数。</p>
<hr>
<p>编译期多态：编译时实例化模板确定哪个重载函数被调用。</p>
<p>运行期多态：运行时哪一个virtual函数该被绑定。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>class和template都支持接口和多态。</li>
<li>对class而言接口是显示的。多态则是通过virtual函数发生于运行期。</li>
<li>对template而言，接口是隐式的。多态则通过template实例化和函数重载解析，发生于编译器。</li>
</ul>
</blockquote>
<h2 id="42-了解typename的双重意义"><a href="#42-了解typename的双重意义" class="headerlink" title="42. 了解typename的双重意义"></a>42. 了解typename的双重意义</h2><p>模版声明有两种形式：</p>
<ol>
<li>template<class t></class></li>
<li>template<typename t></typename></li>
</ol>
<p>这里声明模版参数时，它们的意义完全相同。</p>
<p>不过对于typename在模版中除了声明模版参数外还有几处特别的用处要注意！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print2nd</span><span class="params">(<span class="type">const</span> C&amp; container)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  C::const_iterator* x;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个新名词要了解，嵌套从属类型：即属于模版类型C下的类型，形式：<code>C::xxx</code>。</p>
<p>上面对应的就是C::const_iterator，这里是有歧义的，C::const_iterator是一个类型了还是一个变量了，如果作为类型上面就是定义一个指针x，如果作为变量就是乘x。对于这种嵌套从属类型，编译器一般默认当变量处理。如果要当类型处理就必须在其前面加关键字<code>typename</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> C::const_iterator* x;  <span class="comment">// 这样就显示告诉编译器，C::const_iterator是一个自定义类型</span></span><br></pre></td></tr></table></figure>

<p>另外对于嵌套从属类型前面加typename，有两处特例不能加。即不能出现在基类和成员初始化列表的嵌套从属类型里(除此之外都要加)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&lt;T&gt;::Nested  <span class="comment">// 不能加typename</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  	<span class="function"><span class="keyword">explicit</span> <span class="title">Derived</span><span class="params">(<span class="type">int</span> x)</span> : Base&lt;T&gt;::Nested(x)  // 不能加typename</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">       <span class="keyword">typename</span> Base&lt;T&gt;::Nested temp;   <span class="comment">// 这里要加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>声明template参数时，前缀关键字class和typename可互换，意义一样。</li>
<li>请使用关键字typename标识嵌套从属类型，但不得在基类或成员初始化列表内使用。</li>
</ul>
</blockquote>
<h2 id="43-注意处理模版化基类内的名称"><a href="#43-注意处理模版化基类内的名称" class="headerlink" title="43. 注意处理模版化基类内的名称"></a>43. 注意处理模版化基类内的名称</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span> : <span class="keyword">public</span> MsgSender&lt;T&gt;  <span class="comment">// 模版化基类</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  	...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      	...</span><br><span class="line">      	<span class="built_in">sendClear</span>(info);  <span class="comment">// 如果这个接口属于基类的，这里也不认识，因为基类是什么这时编译器不知道</span></span><br><span class="line">       	...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像上面的sendClear接口模版化基类里是否存在，编译器是不确定的，所以这种编译会报错。有下面3种方式解决这种问题，就是明确告诉编译器假设它存在。</p>
<ol>
<li>通过<code>this-&gt;sendClear(info);</code>调用，假设sendClear在this中。</li>
<li>调用前加using声明<code>using MsgSender&lt;T&gt;::sendClear;</code>，明确告诉编译器sendClear在模版基类中。</li>
<li>调用时明白指明，<code>MsgSender&lt;T&gt;::sendClear(info);</code></li>
</ol>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>可在派生类模版内通过<code>this-&gt;</code>指明基类模版的成员名称(1)，或者由一个明白写出的属于基类的修饰符完成(2, 3)。</li>
</ul>
</blockquote>
<h2 id="44-将与参数无关的代码抽离template"><a href="#44-将与参数无关的代码抽离template" class="headerlink" title="44. 将与参数无关的代码抽离template"></a>44. 将与参数无关的代码抽离template</h2><p><strong>template是一个节省时间和避免代码重复的一个奇方妙法。</strong>不再需要键入20个类似的class而每一个带有15个成员函数，你只需键入一个class template，留给编译器去实例化那20个你需要的相关class和300个函数。(它们只有在被使用时才会实例化)</p>
<p>template虽然给我们提供了方便，但是注意如果使用不当，很容易导致代码膨胀(执行文件变大)。其结果有可能源码看起来合身而整齐，但目标码却不是那么回事。在template代码中，重复是隐藏的，所以你必须训练自己去感受当template被实例化多次时可能发生的重复。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;  <span class="comment">// 这里T称为模版的类型参数，n是非类型参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  	...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化</span></span><br><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">5</span>&gt; sm1;</span><br><span class="line">sml.<span class="built_in">invert</span>();</span><br><span class="line"></span><br><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">10</span>&gt; sm2;</span><br><span class="line">sm2.<span class="built_in">invert</span>();</span><br></pre></td></tr></table></figure>

<p>上面这段模版封装，多次实例化，其中invert也会实例多份，虽然它们二进制实现一样。这就是隐晦的重复代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixbase</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  	...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">(std::<span class="type">size_t</span> matrixSize)</span></span>;</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqureMatrix</span> : <span class="keyword">public</span> SquareMatrixbase&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  	<span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::invert;</span><br><span class="line">  	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  	...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	<span class="keyword">this</span>-&gt;<span class="built_in">invert</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把重复逻辑移到基类中，所有模版类共有，这样就减少了代码膨胀了。</p>
<p>本条款想表达的是使用template时要注意多次实例化后可能带来的代码重复，要尽量避免这种重复代码。这就是我的理解。</p>
<p>TODO: 翻译的请记住条款描述得有点抽象，没深刻理解～待日后回顾重新理解！</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>template生成多个class和多个函数，所以任何template代码都不该与某个造成膨胀的template参数产生相依关系。</li>
<li>因非类型模版参数而造成的代码膨胀，往往可消除，做法是以函数参数或class成员变量替换template参数。</li>
<li>因类型参数而造成的代码膨胀，往往可以降低，做法是让带有完全相同二进制实现的代码共享，如放基类中。</li>
</ul>
</blockquote>
<h2 id="45-使用成员函数模版接受所有兼容类型"><a href="#45-使用成员函数模版接受所有兼容类型" class="headerlink" title="45. 使用成员函数模版接受所有兼容类型"></a>45. 使用成员函数模版接受所有兼容类型</h2><p>本条款想要表达的是我们封装的模版所有操作行为要和普通类保持一致。即隐式行为要一致。如不同类型可隐式相互转换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPrt</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">SmartPrt</span>(<span class="type">const</span> SmartPrt&amp; other);  <span class="comment">//正常的copy构造函数，取消编译器自动生成</span></span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;   <span class="comment">// 泛化的copy构造函数(成员函数模版)，接受不同类型对象转换</span></span><br><span class="line">  	<span class="built_in">SmartPrt</span>(<span class="type">const</span> SmartPrt&lt;U&gt;&amp; other) : <span class="built_in">heldPtr</span>(other.<span class="built_in">get</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      	...</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> heldPtr;&#125;;</span><br><span class="line">  	...</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  	T* heldPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过注意泛化的成员函数(即成员函数模版)并不会影响编译器自动生成类默认函数规则。所以如果你要完全自定义类行为，默认产生的函数除了泛化版本，对应的正常化版本也要声明。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>请使用成员函数模版生成可接受所有兼容类型的函数。</li>
<li>如果你声明成员函数模版用于泛化copy构造函数或赋值操作符，你还是需要声明对应正常的copy构造函数和赋值操作符函数。</li>
</ul>
</blockquote>
<h2 id="46-需要类型转换时请为模版定义非成员函数"><a href="#46-需要类型转换时请为模版定义非成员函数" class="headerlink" title="46. 需要类型转换时请为模版定义非成员函数"></a>46. 需要类型转换时请为模版定义非成员函数</h2><p>对应条款24，这里只是模版实现。规则一致，但它们写法上有所区别了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">Rational</span>(<span class="type">const</span> T&amp; numerator = <span class="number">0</span>,</span><br><span class="line">    				 <span class="type">const</span> T&amp; denominator = <span class="number">1</span>);</span><br><span class="line">  	<span class="function"><span class="type">const</span> T <span class="title">numerator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  	<span class="function"><span class="type">const</span> T <span class="title">denominator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要隐式转换的接口定义为非成员函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>* (<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line">                             <span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function">Rational&lt;<span class="type">int</span>&gt; <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Rational&lt;<span class="type">int</span>&gt; result = oneHalf * <span class="number">2</span>;  <span class="comment">// 这里会编译错误，2不能隐式转换</span></span><br></pre></td></tr></table></figure>

<p>上面只是把24条款示例改为模版实现，然而模版版本是编译不过的，因为编译器并不知道2要转换为什么。编译器推断不了模版的隐式转换。</p>
<p>对于模版我们只能通过friend和inline特性来实现非成员函数的定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  	...</span><br><span class="line">    <span class="comment">// 这里Rational是Rational&lt;T&gt;的简写形式，在类模版内部可以简写。</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs,</span><br><span class="line">                                   	<span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">      	<span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">                       	lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以编译，连接通过了。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>当我们编写一个class template，而它所提供的函数要支持隐式转换时，请将这些函数定义为class template内部的friend函数。</li>
</ul>
</blockquote>
<h2 id="47-请使用traits-class表现类型信息"><a href="#47-请使用traits-class表现类型信息" class="headerlink" title="47. 请使用traits class表现类型信息"></a>47. 请使用traits class表现类型信息</h2><p>TODO: 本条款主要是标准库中大量使用(如stl迭代器)，目前还不太理解其深层含义，待日后再一次回顾理解～</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>Traits class 使得类型相关信息在编译器可用。它们以template和template特化完成实现。</li>
<li>整合重载技术后，traits class有可能在编译期对类型执行if…else测试。(重载是编译期确定，if是运行期确定)</li>
</ul>
</blockquote>
<h2 id="48-认识template元编程"><a href="#48-认识template元编程" class="headerlink" title="48. 认识template元编程"></a>48. 认识template元编程</h2><p>47条款的示例就是使用的模版元编程技术，<strong>它是一种把运行期的代码转移到编译期完成的技术</strong>。这种技术可能永远不会成为主流，但是如果你是一个程序库开发员，那这种技术就是家常便饭了。</p>
<p>通过模版或重载技术，把如if这种运行期的判断转换为编译期重载函数自动匹配。</p>
<p>它有两个特点：</p>
<ol>
<li>它让某些事情更容易。如果没有它，那些事情将是困难的，甚至不可能的。</li>
<li>由于它将工作从运行期转移到编译期。这可更早发现错误，而且更高效、较小的可执行文件、较短的运行期、较少的内存需求。不过它会使编译时间变长。</li>
</ol>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>模版元编程可将工作由运行期转移到编译期，因而得以实现早期错误发现和更高的执行效率。</li>
<li>模版元编程可被用来生成客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码。</li>
</ul>
</blockquote>
<h1 id="八、定制new和delete"><a href="#八、定制new和delete" class="headerlink" title="八、定制new和delete"></a>八、定制new和delete</h1><h2 id="49-了解new-handler的行为"><a href="#49-了解new-handler的行为" class="headerlink" title="49. 了解new-handler的行为"></a>49. 了解new-handler的行为</h2><p>new-handler就是当new抛异常之前，它会先调用一个客户指定的错误处理函数。通过<code>set_new_handler</code>标准库函数指定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当new无法分配足够内存时，被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outOfMem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	std::cerr &lt;&lt; <span class="string">&quot;Unable to satisfy request for memory\n&quot;</span>;</span><br><span class="line">  	std::<span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	std::<span class="built_in">set_new_handler</span>(outOfMem);</span><br><span class="line">  	<span class="type">int</span>* pBigDataArray = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100000000L</span>];</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面异常处理是全局的，但有时候你可能需要为不同类处理不同异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">outOfMem</span><span class="params">()</span></span>;</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">outOfMem</span><span class="params">()</span></span>;</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">X* p1 = <span class="keyword">new</span> X;  <span class="comment">// 如果X错误，你希望调用X的错误函数</span></span><br><span class="line">Y* p2 = <span class="keyword">new</span> Y;	<span class="comment">// 如果Y错误，你希望调用Y的错误函数</span></span><br></pre></td></tr></table></figure>

<p>C++并不支持class的专属new-hander，但也可以通过其它形式自己实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RAII对象，保证new_handler还原</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewHandlerHolder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">NewHandlerHolder</span><span class="params">(std::new_handler nh)</span> : handler(nh) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">NewHnadlerHolder</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">set_new_handler</span>(handler);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::new_handler handler;</span><br><span class="line">    <span class="comment">// 阻止copiying</span></span><br><span class="line">    <span class="built_in">NewHandlerHolder</span>(<span class="type">const</span> NewHandlerHolder&amp;);</span><br><span class="line">    NewHandlerHolder&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NewHandlerHolder&amp;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewHandlerSupport</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::new_handler <span class="title">set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::new_handler currentHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::new_handler</span><br><span class="line">NewHandlerSupport&lt;T&gt;::<span class="built_in">set_new_hnadler</span>(std::new_handler p) <span class="keyword">throw</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::new_handler oldHandler = currentHandler;</span><br><span class="line">    currentHandler = p;</span><br><span class="line">    <span class="keyword">return</span> oldHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span>* NewHandlerSupport&lt;T&gt;::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"><span class="title">throw</span><span class="params">(std::bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// new如果失败，则先会调用currentHandler，然后set_new_handler会返回上一次的handler。</span></span><br><span class="line">    <span class="comment">// NewHandlerHolder这个RAII对象则在析构时会把上面返回的上一次new_handler设置回去。</span></span><br><span class="line">    <span class="function">NewHandlerHolder <span class="title">h</span><span class="params">(std::set_new_handler(currentHandler))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::new_handler NewHandlerSupport&lt;T&gt;::currentHandler = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用，只要继承封装的NewHandlerSupport&lt;T&gt;，就能够实现针对类自己的new_handler了。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> NewHandlerSupport&lt;Widget&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">Widget::<span class="built_in">set_new_handler</span>(xxxx); <span class="comment">// xxxx是new失败执行的回调函数</span></span><br><span class="line">Widget* w = <span class="keyword">new</span> Widget; <span class="comment">// 如果失败，先会调用xxxx，然后会还原new_handler回调函数。</span></span><br></pre></td></tr></table></figure>

<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>set_new_handler允许客户指定一个函数，在内存分配无法获得满足时被调用。</li>
<li>让new不抛异常是一个颇为局限的工具，因为它只是保证了内存分配时不抛异常，后续调用构造函数还是可能抛出异常。&#x3D;&gt; new做了两件事：1. 分配内存 2. 调用类的构造函数。</li>
</ul>
</blockquote>
<h2 id="50-了解new和delete的合理替换时机"><a href="#50-了解new和delete的合理替换时机" class="headerlink" title="50. 了解new和delete的合理替换时机"></a>50. 了解new和delete的合理替换时机</h2><p>什么时候我们需要替换编译器提供的new或delete呢？下面是三个最常见的理由：</p>
<ol>
<li><strong>用来检测运用上的错误。</strong>如new的一段内存，delete时失败了导致内存泄漏。又或多次delete导致不确定行为。</li>
<li><strong>为了提升性能。</strong>编译器默认提供的new&#x2F;delete是大众的，均衡的，不针对特定场景特定优化。如需要大量申请&#x2F;释放内存场景(碎片)，我们习知的有内存池技术。</li>
<li><strong>为了收集使用上的统计数据。</strong>统计任何时刻内存分配情况等。</li>
</ol>
<p>但是要自定义一个合适的new&#x2F;delete并非易事，如<strong>内存对齐(对齐指令执行效率最高)，可移植性、线程安全</strong>….等等细节。所以我的建议是在你确定要自定义new&#x2F;delete之前，请先确定你程序瓶颈是否真的由默认new&#x2F;delete引起，而且现在也有商业产品可以替代编译器自带的内存管理器。或者也有一些开源的产品可以使用，如Boost的Pool就是对于常见的分配大量小型对象很有帮助。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>有许多理由需要写个自定义的new和delete，包括改善性能、对堆区运用错误进行调试、收集堆区使用信息。</li>
</ul>
</blockquote>
<h2 id="51-编写new和delete时需固守常规"><a href="#51-编写new和delete时需固守常规" class="headerlink" title="51. 编写new和delete时需固守常规"></a>51. 编写new和delete时需固守常规</h2><p>上面条款说了什么时候需要自定义new&#x2F;delete，本节则告诉你写自定义new&#x2F;delete需要遵守的一般规范。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>operator new 1. 应该内含一个无限循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用new-handler。2. 它也应该有能力处理0字节申请。3. Class的专属版本则还应该处理“比正确大小更大的申请”(被继承后, new 派生对象，这时可以走编译器默认new操作)。</li>
<li>operator delete应该在收到null指针时不做任何事情。Class专属版本还应该处理“比正确大小更大的申请”(同上)。</li>
</ul>
</blockquote>
<h2 id="52-new与delete成对出现"><a href="#52-new与delete成对出现" class="headerlink" title="52. new与delete成对出现"></a>52. new与delete成对出现</h2><p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>当你写一个operator new, 请确定也写出了对应的operator delete。如果没有这样做，你的程序可能会发生隐晦而时断时续的内存泄漏。</li>
<li>当你声明new和delete，请确定不要无意识地(非故意)遮掩了它们的正常版本。</li>
</ul>
</blockquote>
<br>



<h1 id="九、杂项讨论"><a href="#九、杂项讨论" class="headerlink" title="九、杂项讨论"></a>九、杂项讨论</h1><h2 id="53-不要轻忽编译器的警告"><a href="#53-不要轻忽编译器的警告" class="headerlink" title="53. 不要轻忽编译器的警告"></a>53. 不要轻忽编译器的警告</h2><p>记住后期很多无休止调试就是由于你前期没有重视编译警告引起的。尽管一般认为，写出一个在最高警告级别下也无任何警告信息的程序是理想的，然而如果你对某些警告信息有深刻理解，你倒是可以选择忽略它。不管怎样说，在你打发某个警告信息之前，请确定你了解它意图说出的精确意义。这很重要！</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>严肃对待编译器发出的警告信息。努力在你的编译器的最高警告级别下争取无任何警告的荣誉。</li>
<li>不要过度依赖编译器的报警能力，因为不同的编译器对待事情的态度并不相同。一旦移植到另一个编译器上，你原本依赖的警告信息有可能消失。</li>
</ul>
</blockquote>
<h2 id="54-熟悉TR1在内的标准程序库"><a href="#54-熟悉TR1在内的标准程序库" class="headerlink" title="54. 熟悉TR1在内的标准程序库"></a>54. 熟悉TR1在内的标准程序库</h2><p>TR1是C++标准程序库第一次扩充，包含14个新组件，统统都放在std::tr1命名空间下。</p>
<ol>
<li>智能指针tr1::shared_ptr和tr1::weak_ptr。</li>
<li>tr1::function，可表示任何函数，是一个模板。在条款35中有使用。</li>
<li>tr1::bind，同样35示范中有它用法。</li>
<li>hash table，用来实现set, multiset, map和multi-map容器的hash版本。</li>
<li>正则表达式。</li>
<li>tr1::tuple，标准库中的pair template的新一代制品，可持有任意个数的对象(pair只能持有两个对象)。</li>
<li>tr1::array，是一个STL化的数组。</li>
<li>tr1::mem_fn，生成指向成员的指针的包装对象。</li>
<li>tr1::reference_wrapper, 一个让引用的行为更像对象的设施。  </li>
<li>随机数生成工具。</li>
<li>数学特殊函数。</li>
<li>C99兼容扩充。</li>
<li>Type traits，见条款47。</li>
<li>tr1::result_of，这是一个模板，用来推导函数调用的返回类型。</li>
</ol>
<p>这些实现一般很多实现在boost库中都有！</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>C++标准程序库的主要功能由STL、iostreams、locales组成。并包含C99标准程序库。</li>
<li>TR1添加了智能指针、一般化函数指针、hash-based容器、正则表达式以及另外10个组件的支持。</li>
<li>TR1自身只是一份规范。为获得TR1提供的好处，你需要一份实现。一个好的实现来源是Boost。</li>
</ul>
</blockquote>
<h2 id="55-让自己熟悉Boost"><a href="#55-让自己熟悉Boost" class="headerlink" title="55. 让自己熟悉Boost"></a>55. 让自己熟悉Boost</h2><p>你正在寻找一个高质量、源码开放、平台独立、编译器独立的程序库吗？看看Boost吧。有兴趣加入一个由雄心勃勃充满才干的C++开发人员组成的社群，致力发展当前最高技术水平的程序库吗？看看Boost吧！想要一瞥未来的C++可能长相吗？看看Boost吧！<a target="_blank" rel="noopener" href="https://www.boost.org/">官网地址</a></p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>Boost是一个社群，也是一个网站。致力于免费、源码开放、同僚复审的C++程序库开发。Boost在C++标准化过程中扮演深具影响力的角色。</li>
<li>Boost提供了许多TR1组件的实现，以及其他许多程序库。</li>
</ul>
</blockquote>
<br>



<h1 id="十、本书之外"><a href="#十、本书之外" class="headerlink" title="十、本书之外"></a>十、本书之外</h1><p>《Effective C++》一书覆盖我认为对于以编程为业的C++程序员最重要的一般性准则。如果你有兴趣更强化各种高效做法，我推荐你再试试另外两本书：《More Effective C++》和《Effective STL》。</p>
<p>《More Effective C++》覆盖了另一些编程准则，以及对于性能和异常的广泛讨论。它也描述了重要的C++编程技术如智能指针、引用计数和代理对象等等。</p>
<p>《Effective STL》是一本和《Effective C++》一样的准则导向书籍，专注于对STL的高效运用。</p>

    </div>
    
    <div class="post-footer">
        <div>
            
            转载声明：
            商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">cxx</a>
            
            
        </div>
        <div>
            
        </div>
    </div>
</article>
<div class="article-nav prev-next-wrap clearfix">
    
    <a href="/2022/12/21/notes/boost%E5%BA%93%E4%BD%BF%E7%94%A8/" class="pre-post btn btn-default" title='boost库使用'>
        <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
        <span class="hidden-xs">
            boost库使用</span>
    </a>
    
    
    <a href="/2022/12/06/resources/" class="next-post btn btn-default" title='资源列表'>
        <span class="hidden-lg">下一篇</span>
        <span class="hidden-xs">
            资源列表</span><i class="fa fa-angle-right fa-fw"></i>
    </a>
    
</div>

<div id="comments">
    
    <script src="https://giscus.app/client.js"
        data-repo="cxx001/myblog-comment"
        data-repo-id="R_kgDOHvvgeg"
        data-category="General"
        data-category-id="DIC_kwDOHvvges4CZehr"
        data-mapping="title"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light"
        data-lang="zh-CN"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
    </script>

</div>

                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">
            文章目录
        </h3>
        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AC%E6%96%87%E9%98%85%E8%AF%BB%E8%AF%B4%E6%98%8E"><span class="toc-text">本文阅读说明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC"><span class="toc-text">一、让自己习惯C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%A7%86C-%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6"><span class="toc-text">1.  视C++为一个语言联邦</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B0%BD%E9%87%8F%E7%94%A8-const-enum-inline-%E6%9B%BF%E6%8D%A2-define"><span class="toc-text">2. 尽量用 const, enum, inline 替换 #define</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const"><span class="toc-text">3. 尽可能使用const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">4. 确定对象被使用前已先被初始化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%9E%84%E9%80%A0-x2F-%E6%9E%90%E6%9E%84-x2F-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97"><span class="toc-text">二、构造&#x2F;析构&#x2F;赋值运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BA%86%E8%A7%A3C-%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="toc-text">5. 了解C++默默编写并调用哪些函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D"><span class="toc-text">6. 若不想使用编译器自动生成的函数，就该明确拒绝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8Evirtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">7. 为多态基类声明virtual析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">8. 别让异常逃离析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0"><span class="toc-text">9. 绝不在构造和析构过程中调用virtual函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E4%BB%A4operator-x3D-%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA-reference-to-this"><span class="toc-text">10. 令operator&#x3D; 返回一个 reference to *this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E5%9C%A8operator-x3D-%E4%B8%AD%E5%A4%84%E7%90%86%E2%80%9D%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC%E2%80%9D"><span class="toc-text">11. 在operator&#x3D; 中处理”自我赋值”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%8B%BF%E5%BF%98%E5%85%B6%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%88%90%E5%88%86"><span class="toc-text">12. 复制对象时勿忘其每一个成分</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-text">三、资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90"><span class="toc-text">13. 以对象管理资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83coping%E8%A1%8C%E4%B8%BA"><span class="toc-text">14. 在资源管理类中小心coping行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">15. 在资源管理类中提供对原始资源的访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E6%88%90%E5%AF%B9%E4%BD%BF%E7%94%A8new%E5%92%8Cdelete%E6%97%B6%E8%A6%81%E9%87%87%E5%8F%96%E7%9B%B8%E5%90%8C%E5%BD%A2%E5%BC%8F"><span class="toc-text">16. 成对使用new和delete时要采取相同形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86new%E5%AF%B9%E8%B1%A1%E7%BD%AE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">17. 以独立语句将new对象置入智能指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E"><span class="toc-text">四、 设计与声明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E8%AE%A9%E6%8E%A5%E5%8F%A3%E5%AE%B9%E6%98%93%E8%A2%AB%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8D%E6%98%93%E8%A2%AB%E8%AF%AF%E7%94%A8"><span class="toc-text">18. 让接口容易被正确使用，不易被误用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E8%AE%BE%E8%AE%A1class%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1type"><span class="toc-text">19. 设计class犹如设计type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E4%BC%A0%E5%BC%95%E7%94%A8%E6%9B%BF%E4%BB%A3%E4%BC%A0%E5%80%BC-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-text">20. 传引用替代传值(函数参数)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E5%88%AB%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">21. 必须返回对象时，别返回引用(函数返回值)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BAprivate"><span class="toc-text">22. 将成员变量声明为private</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%AE%81%E4%BB%A5non-member%E3%80%81non-friend%E6%9B%BF%E6%8D%A2member%E5%87%BD%E6%95%B0"><span class="toc-text">23. 宁以non-member、non-friend替换member函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8non-member%E5%87%BD%E6%95%B0"><span class="toc-text">24. 若所有参数皆需类型转换，请为此采用non-member函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0"><span class="toc-text">25. 考虑写出一个不抛异常的swap函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">五、实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E5%8F%98%E9%87%8F%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%9C%A8%E4%BD%BF%E7%94%A8%E6%97%B6%E5%AE%9A%E4%B9%89"><span class="toc-text">26. 变量尽可能在使用时定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-%E5%B0%BD%E9%87%8F%E5%B0%91%E5%81%9A%E8%BD%AC%E5%9E%8B%E5%8A%A8%E4%BD%9C"><span class="toc-text">27. 尽量少做转型动作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-%E5%B0%BD%E9%87%8F%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9Ehandles%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E6%88%90%E5%88%86"><span class="toc-text">28. 尽量避免返回handles指向对象内部成分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-%E4%B8%BA%E2%80%9D%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E2%80%9D%E8%80%8C%E5%8A%AA%E5%8A%9B%E6%98%AF%E5%80%BC%E5%BE%97%E7%9A%84"><span class="toc-text">29. 为”异常安全”而努力是值得的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-%E9%80%8F%E5%BD%BB%E4%BA%86%E8%A7%A3inline%E7%9A%84%E9%87%8C%E9%87%8C%E5%A4%96%E5%A4%96"><span class="toc-text">30. 透彻了解inline的里里外外</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E5%B0%86%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E9%99%8D%E8%87%B3%E6%9C%80%E4%BD%8E"><span class="toc-text">31. 将文件间的编译依赖关系降至最低</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1"><span class="toc-text">六、继承与面向对象设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="toc-text">32. 公有继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E9%81%BF%E5%85%8D%E9%81%AE%E6%8E%A9%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-text">33. 避免遮掩继承而来的名称</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="toc-text">34. 区分接口继承和实现继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E8%80%83%E8%99%91virtual%E5%87%BD%E6%95%B0%E4%BB%A5%E5%A4%96%E7%9A%84%E5%85%B6%E4%BB%96%E9%80%89%E6%8B%A9"><span class="toc-text">35. 考虑virtual函数以外的其他选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E9%9D%9E%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">36. 绝不重新定义继承而来的非虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%80%BC"><span class="toc-text">37. 绝不重新定义继承而来的缺省参数值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-%E7%B1%BB%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1"><span class="toc-text">38. 类的子对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8private%E7%BB%A7%E6%89%BF"><span class="toc-text">39. 明智而审慎地使用private继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-text">40. 明智而审慎地使用多重继承</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="toc-text">七、模板与泛型编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E4%BA%86%E8%A7%A3%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81"><span class="toc-text">41. 了解隐式接口和编译期多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E4%BA%86%E8%A7%A3typename%E7%9A%84%E5%8F%8C%E9%87%8D%E6%84%8F%E4%B9%89"><span class="toc-text">42. 了解typename的双重意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-%E6%B3%A8%E6%84%8F%E5%A4%84%E7%90%86%E6%A8%A1%E7%89%88%E5%8C%96%E5%9F%BA%E7%B1%BB%E5%86%85%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-text">43. 注意处理模版化基类内的名称</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-%E5%B0%86%E4%B8%8E%E5%8F%82%E6%95%B0%E6%97%A0%E5%85%B3%E7%9A%84%E4%BB%A3%E7%A0%81%E6%8A%BD%E7%A6%BBtemplate"><span class="toc-text">44. 将与参数无关的代码抽离template</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-%E4%BD%BF%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88%E6%8E%A5%E5%8F%97%E6%89%80%E6%9C%89%E5%85%BC%E5%AE%B9%E7%B1%BB%E5%9E%8B"><span class="toc-text">45. 使用成员函数模版接受所有兼容类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%97%B6%E8%AF%B7%E4%B8%BA%E6%A8%A1%E7%89%88%E5%AE%9A%E4%B9%89%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">46. 需要类型转换时请为模版定义非成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47-%E8%AF%B7%E4%BD%BF%E7%94%A8traits-class%E8%A1%A8%E7%8E%B0%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-text">47. 请使用traits class表现类型信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-%E8%AE%A4%E8%AF%86template%E5%85%83%E7%BC%96%E7%A8%8B"><span class="toc-text">48. 认识template元编程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%AE%9A%E5%88%B6new%E5%92%8Cdelete"><span class="toc-text">八、定制new和delete</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#49-%E4%BA%86%E8%A7%A3new-handler%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-text">49. 了解new-handler的行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50-%E4%BA%86%E8%A7%A3new%E5%92%8Cdelete%E7%9A%84%E5%90%88%E7%90%86%E6%9B%BF%E6%8D%A2%E6%97%B6%E6%9C%BA"><span class="toc-text">50. 了解new和delete的合理替换时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-%E7%BC%96%E5%86%99new%E5%92%8Cdelete%E6%97%B6%E9%9C%80%E5%9B%BA%E5%AE%88%E5%B8%B8%E8%A7%84"><span class="toc-text">51. 编写new和delete时需固守常规</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-new%E4%B8%8Edelete%E6%88%90%E5%AF%B9%E5%87%BA%E7%8E%B0"><span class="toc-text">52. new与delete成对出现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%9D%82%E9%A1%B9%E8%AE%A8%E8%AE%BA"><span class="toc-text">九、杂项讨论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E4%B8%8D%E8%A6%81%E8%BD%BB%E5%BF%BD%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E8%AD%A6%E5%91%8A"><span class="toc-text">53. 不要轻忽编译器的警告</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-%E7%86%9F%E6%82%89TR1%E5%9C%A8%E5%86%85%E7%9A%84%E6%A0%87%E5%87%86%E7%A8%8B%E5%BA%8F%E5%BA%93"><span class="toc-text">54. 熟悉TR1在内的标准程序库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-%E8%AE%A9%E8%87%AA%E5%B7%B1%E7%86%9F%E6%82%89Boost"><span class="toc-text">55. 让自己熟悉Boost</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E6%9C%AC%E4%B9%A6%E4%B9%8B%E5%A4%96"><span class="toc-text">十、本书之外</span></a></li></ol>
        
    </div>
</aside>
                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>
<a id="back-to-top" class="icon-btn hide">
    <i class="fa fa-chevron-up"></i>
</a>
    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
    访问量:
    <strong id="busuanzi_value_site_pv">
        <i class="fa fa-spinner fa-spin"></i>
    </strong>
    &nbsp; | &nbsp;
    访客数:
    <strong id="busuanzi_value_site_uv">
        <i class="fa fa-spinner fa-spin"></i>
    </strong>
    
</div>
            </div>
            <div class="col-sm-12">
                <span>Copyright &copy;
                    2022
                    
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<script src="/js/app.js?rev=@@hash.js"></script>

</body>
</html>