{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://cxx001.gitee.io"},"pages":[],"posts":[{"title":"windows11安装Linux子系统","slug":"tools/windows11安装Linux子系统","date":"2022-10-24T08:02:33.000Z","updated":"2022-10-24T09:06:12.596Z","comments":true,"path":"2022/10/24/tools/windows11安装Linux子系统/","link":"","permalink":"https://cxx001.gitee.io/2022/10/24/tools/windows11%E5%AE%89%E8%A3%85Linux%E5%AD%90%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"Windows在10之后自带了虚拟机子系统功能，可以和本地磁盘共享，默认挂载到&#x2F;mnt&#x2F;目录下面。比起传统的VM方便多了。下面是搭建流程： 一 开启子系统服务控制面板 -&gt; 程序 -&gt; 程序与功能 -&gt; 启动或关闭Windows功能，勾选下面截图3个选项，确定后重启。 二 Microsoft Store下载Linux系统 安装完，用自带连接就可以直接访问了。 如果启动提示WSL2错误:根据报错说明提示需要安装： 适用于 x64 计算机的 WSL2 Linux 内核更新包 点此下载 三 其它辅助设置 自带连接工具默认登录的是非root用户，第一次切换root要设置root密码。 sudo passwd root 自带连接工具默认登录的是非root用户，改默认root用户。 查找ubuntu*.exe在哪里，一般是c盘下(find /mnt/c/ -name ubuntu*.exe)。 /mnt/c/Users/KL179/AppData/Local/Microsoft/WindowsApps/ubuntu2004.exe 进入ubuntu2004.exe目录，执行下面命令修改默认登录用户 ./ubuntu2004.exe config --default-user root 第三方ssh连接工具访问Linux子系统 安装ssh服务、设置sshkey、启动服务 123456789# 安装sshsudo apt-get install openssh-server openssh-client# 第一次可能需要设置sshkey这样启动ssh-keygen -A/etc/init.d/ssh start# 启动ssh服务service ssh start 允许root用户登录和允许密码访问 打开ssh配置文件: vi /etc/ssh/sshd_config 添加: PermitRootLogin yes 允许root用户登录 PasswordAuthentication yes 设置为yes允许密码验证","categories":[{"name":"tools","slug":"tools","permalink":"https://cxx001.gitee.io/categories/tools/"}],"tags":[{"name":"windows安装linux子系统","slug":"windows安装linux子系统","permalink":"https://cxx001.gitee.io/tags/windows%E5%AE%89%E8%A3%85linux%E5%AD%90%E7%B3%BB%E7%BB%9F/"}],"keywords":[{"name":"tools","slug":"tools","permalink":"https://cxx001.gitee.io/categories/tools/"}]},{"title":"Docker基础使用","slug":"tools/docker使用","date":"2022-10-21T08:45:10.000Z","updated":"2022-10-21T08:48:42.511Z","comments":true,"path":"2022/10/21/tools/docker使用/","link":"","permalink":"https://cxx001.gitee.io/2022/10/21/tools/docker%E4%BD%BF%E7%94%A8/","excerpt":"","text":"概要Docker由下面3个东西组成: 镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。 容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。 安装参考：CentOS Docker 安装 | 菜鸟教程 (runoob.com) 我的测试环境是CentOS7，使用的官方安装脚本自动安装。 1curl -sSL https://get.daocloud.io/docker | sh 安装完成后，重启docker服务。 1234docker version # 查看版本systemctl status docker # 查看docker状态systemctl start docker # 启动dockersystemctl restart docker # 重启docker 常用命令123456789101112131415161718192021222324252627282930docker # 查看docker所有命令docker xxx --help # 查看xxx命令详情docker search 镜像名 # 从远程仓库搜索镜像docker pull 镜像名 # 从远程仓库拉镜像到本地docker image list/docker images # 查看已有镜像列表docker tag 镜像ID 新镜像名[:新tag名] # 镜像改名/改tag名docker rmi [-f] 镜像ID # 删除镜像(要先删除镜像引起的容器)# 创建容器 docker run [-it -d -p -name -v] 常用可选参数docker run -it 镜像名 [shell命令] # 前台运行创建新容器exit # 退出容器docker run -d 镜像名 [shell命令] # 后台运行创建新容器docker run -d -p 5000:5000 镜像名 命令 # 将容器内5000端口映射到宿主机的5000端口，多个就依次加-p xx:xx就行了。默认是绑定tcp端口，如果udp直接加后面就行了:-p 5000:5000/udp。这个设置是直接改容器的本地配置(inspect)，永久生效,后面直接docker start就行了。docker run -v 宿主机目录:容器目录 镜像名 命令 # -v将宿主机目录挂载到容器某个目录下，这样宿主机就可以与容器共享目录了。docker ps # 查看正在运行的容器docker ps -a #查看所有的容器docker losgs [-f] 容器ID # 查看运行的容器内标准输出日志, -f类似tail -f一样docker stop 容器ID # 停止容器docker start 容器ID # 启动一个已经停止的容器docker restart 容器ID # 重启容器docker rm [-f] 容器ID # 删除容器docker container prune # 删除所有处于终止状态的容器docker attach 容器ID #进入一个启动的后台容器，这种方式进入exit退出会导致容器也会退出docker exec -it 容器ID /bin/bash #同上，这种方式进入exit退出，容器不会退出，推荐这种docker export 容器ID &gt; xxx.tar # 导出容器docker import xxx.tar 镜像名 # 把xxx.tar(也可以是URL)以镜像形式导入 通过容器提交镜像以及推送镜像流程我们本地一个容器如果想要提交到docker仓库供别人pull下载使用。操作流程如下(和git使用类似)： 注册docker仓库账号 地址: Docker Hub 本地提交容器为镜像 1docker commit -m &quot;描述日志&quot; -a &quot;作者&quot; 容器ID 新镜像名 登录docker hub 1docker login 推送到远程仓库 1docker push 镜像名[:tag名] 别人使用 1docker pull 镜像名[:tag名]","categories":[{"name":"tools","slug":"tools","permalink":"https://cxx001.gitee.io/categories/tools/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://cxx001.gitee.io/tags/docker/"}],"keywords":[{"name":"tools","slug":"tools","permalink":"https://cxx001.gitee.io/categories/tools/"}]},{"title":"C++动态库使用","slug":"c++/C++动态库使用","date":"2022-09-14T08:54:33.000Z","updated":"2022-09-14T09:52:40.255Z","comments":true,"path":"2022/09/14/c++/C++动态库使用/","link":"","permalink":"https://cxx001.gitee.io/2022/09/14/c++/C++%E5%8A%A8%E6%80%81%E5%BA%93%E4%BD%BF%E7%94%A8/","excerpt":"","text":"前言Windows与Linux下面的动态链接库区别1. 文件后缀不同Linux动态库的后缀是 .so 文件，而window则是 .dll 文件。 2. 文件格式不同（a）Linux下是ELF格式，即Executable and Linkable Format 在ELF之下，共享库中所有的全局函数和变量在默认情况下都可以被其它模块使用，即ELF默认导出所有的全局符号。 （b）Windows下面是PE格式的文件，即Portable Executable Format DLL文件和EXE文件实际上是一个概念，都是PE格式的二进制文件。DLL需要显示地“告诉”编译器需要导出某个符号，否则编译器默认所有的符号都不导出。 3. 动态链接库的文件个数不一样Linux的动态链接库就只有一个 .so 文件，还有与之对应的头文件，而在Windows下面的动态库有两个文件， 一个是引入库（.LIB）文件， 一个是动态库（.DLL）文件， 需要的头文件（.h）文件 （1）LIB引入库文件包含被DLL导出的函数名称和位置，对于导入库而言，其实际的执行代码位于动态库中，导入库只包含了地址符号表等，确保程序找到对应函数的一些基本地址信息。 （2）DLL文件包含实际的函数和数据，应用程序使用LIB文件链接到所需要使用的DLL文件，库中的函数和数据并不复制到可执行文件中，因此在应用程序的可执行文件中，存放的不是被调用的函数代码，而是DLL中所要调用的函数的内存地址，这样当一个或多个应用程序运行是再把程序代码和被调用的函数代码链接起来，从而节省了内存资源。 Windows上动态库使用1. 创建动态库windows上创建动态库一般有两种方式： 使用_declspec 显示声明要导出的对象 。 和平时写程序一样，源码中不需要显示声明导出，导出放在def文件中声明。 首先介绍下使用_declspec 来创建动态库的过程： （1）新建一个空项目或者是使用DLL模板都可以。(个人习惯用干净的空项目) （2）修改项目属性输出类型改为dll。 （3）正常添加.h与.cpp文件，.h中要导出的函数前添加_declspec(dllexport)声明即可。 （4）重新生成，在工程目录即可生成对应的dllapi.lib与dllapi.dll文件。 再来看看使用def文件声明导出的方式： （1）添加def文件 （2）def文件中声明要导出的函数 123LIBRARYEXPORTS add （3）重新生成，和第一种显示声明方式一样生成了.lib和.dll2个文件。 2. 使用动态库windows上使用动态库一般有2种方式： 隐式调用(IDE上设置) 显示调用 下面分别介绍下详细的使用流程 隐式调用使用流程 （1）创建控制台测试工程，并建立一个依赖目录，将动态库的.h和.lib放在这个目录下，同时将.dll放在exe可执行程序同级目录。 （2）配置 项目-&gt;属性-&gt;配置属性-&gt;VC++ 目录-&gt; 在“包含目录”里添加头文件DllAPI.h所在的目录 。 项目-&gt;属性-&gt;配置属性-&gt;VC++ 目录-&gt; 在“库目录”里添加依赖文件dllapi.lib所在的目录。 项目-&gt;属性-&gt;配置属性-&gt;链接器-&gt;输入-&gt; 在“附加依赖项”里添加dllapi.lib 。 你也可以在代码中添加一行设置库的链接，#pragma comment(lib, &quot;dllapi.lib&quot;)，这样就不需要2、3配置了。 （3）测试运行 显示调用使用流程 只需要将.dll放在exe可执行程序同级目录就行了，IDE不需要额外设置。注意要使用这个dll中的方法其创建时必须要_declspec 显示导出，使用时只要这个dll文件就行了，.h和.lib不需要。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &quot;Windows.h&quot; // 动态库加载、释放等接口头文件#include &quot;tchar.h&quot; // _T头文件，设置支持Unicode编码typedef int(*Dllfun)(int, int); // 待使用接口的函数指针int main()&#123; // 加载动态库 HINSTANCE hdll = LoadLibrary(_T(&quot;dllapi.dll&quot;)); if (hdll == NULL) &#123; return -1; &#125; // 获取动态库中导出的函数指针 Dllfun funName = (Dllfun)GetProcAddress(hdll, &quot;add&quot;); if (funName == NULL) &#123; FreeLibrary(hdll); return -1; &#125; // 调用、释放 int ret = funName(1, 2); FreeLibrary(hdll); std::cout &lt;&lt; &quot;result = &quot; &lt;&lt; ret &lt;&lt; &quot;\\n&quot;;&#125; Linux上动态库使用Linux上创建动态库很简单，不需要显示声明导出的函数，它会默认导出。在Linux上使用动态库也有2种方式： 编译器链接 库文件加载 1. 编译器链接使用流程 编写源文件。 将一个或几个源文件编译链接，生成libxxx.so。 通过 -L&lt;path&gt; -lxxx 的gcc选项链接生成的libxxx.so。 把libxxx.so放入链接库的标准路径，或指定 LD_LIBRARY_PATH，才能运行链接了libxxx.so的程序。 (1) 编写源文件，生成so共享库 建立一个源文件：add.c，代码如下： 1234int add(int x, int y)&#123; return x + y;&#125; 编译生成libadd.so： 1gcc -fPIC -shared -o libadd.so add.c 我们会得到libadd.so。 实际上上述过程分为编译和链接两步， -fPIC是编译选项，PIC是 Position Independent Code 的缩写，表示要生成位置无关的代码，这是动态库需要的特性； -shared是链接选项，告诉gcc生成动态库而不是可执行文件。 上述的一行命令等同于： 12gcc -c -fPIC add.cgcc -shared -o libadd.so add.o （2）为动态库编写接口文件 12#pragma onceint add(int x, int y); （3）测试，链接动态库生成可执行文件 建立一个使用add函数的test.c，代码如下： 123456789#include &lt;stdio.h&gt;#include &quot;add.h&quot;int main(int argc, char *argv[])&#123; int ret = add(1, 2); printf(&quot;ret= %d.\\n&quot;, ret); return 0;&#125; gcc test.c -L. -ladd 生成a.out，其中-ladd表示要链接libadd.so。-L.表示搜索要链接的库文件时包含当前路径。 注意，如果同一目录下同时存在同名的动态库和静态库，比如 libadd.so 和 libadd.a 都在当前路径下，则gcc会优先链接动态库。 （4） 运行 运行 ./a.out 会得到以下的错误提示。 1./a.out: error while loading shared libraries: libadd.so: cannot open shared object file: No such file or directory 找不到libadd.so，原来Linux是通过 /etc/ld.so.cache 文件搜寻要链接的动态库的。而 /etc/ld.so.cache 是 ldconfig 程序读取 /etc/ld.so.conf 文件生成的。（注意， /etc/ld.so.conf 中并不必包含 /lib 和 /usr/lib，ldconfig程序会自动搜索这两个目录） 如果我们把 libadd.so 所在的路径添加到 /etc/ld.so.conf 中，再以root权限运行 ldconfig 程序，更新 /etc/ld.so.cache ，a.out运行时，就可以找到 libadd.so。 因此我们可以为a.out指定 LD_LIBRARY_PATH运行，如下： 1LD_LIBRARY_PATH=. ./a.out 程序就能正常运行了。LD_LIBRARY_PATH=. 是告诉 a.out，先在当前路径寻找链接的动态库。 或者修改LD_LIBRARY_PATH环境变量，指定为当前目录也可以，如下： 1export LD_LIBRARY_PATH=$&#123;pwd&#125;:$&#123;LD_LIBRARY_PATH&#125; 然后直接执行./a.out也可以运行了。 2. 库文件加载使用流程像window调用库文件一样，在linux下，也有相应的API因为加载库文件而存在。它们主要是以下几个函数： 使用源码如下： 1234567891011121314151617181920212223242526272829303132333435363738// test2.c#include &lt;stdio.h&gt;#include &lt;dlfcn.h&gt; int main(int argc, char *argv[])&#123; void * libm_handle = NULL; int (*add_method)(int, int); char *errorInfo; int result; // dlopen 函数还会自动解析共享库中的依赖项。这样，如果您打开了一个依赖于其他共享库的对象，它就会自动加载它们。 // 函数返回一个句柄，该句柄用于后续的 API 调用 libm_handle = dlopen(&quot;libadd.so&quot;, RTLD_LAZY ); // 如果返回 NULL 句柄，表示无法找到对象文件，过程结束。否则的话，将会得到对象的一个句柄，可以进一步询问对象 if (!libm_handle)&#123; // 如果返回 NULL 句柄,通过dlerror方法可以取得无法访问对象的原因 printf(&quot;Open Error:%s.\\n&quot;,dlerror()); return 0; &#125; // 使用 dlsym 函数，尝试解析新打开的对象文件中的符号。您将会得到一个有效的指向该符号的指针，或者是得到一个 NULL 并返回一个错误 add_method = dlsym(libm_handle,&quot;add&quot;); errorInfo = dlerror();// 它会在发生前面的错误时返回一个字符串，同时将其从内存中清空； 在没有错误发生时返回 NULL if (errorInfo != NULL)&#123; printf(&quot;Dlsym Error:%s.\\n&quot;,errorInfo); return 0; &#125; // 执行“cosf”方法 result = (*add_method)(1, 2); printf(&quot;result = %d.\\n&quot;,result); // 调用 ELF 对象中的目标函数后，通过调用 dlclose 来关闭对它的访问 dlclose(libm_handle); return 0;&#125; 编译，运行./test2可以看到结果为3。 1gcc test2.c -o test2 -ldl","categories":[{"name":"c++","slug":"c","permalink":"https://cxx001.gitee.io/categories/c/"}],"tags":[{"name":"动态库使用","slug":"动态库使用","permalink":"https://cxx001.gitee.io/tags/%E5%8A%A8%E6%80%81%E5%BA%93%E4%BD%BF%E7%94%A8/"}],"keywords":[{"name":"c++","slug":"c","permalink":"https://cxx001.gitee.io/categories/c/"}]},{"title":"CMake使用","slug":"notes/cmake","date":"2022-09-08T09:35:55.000Z","updated":"2022-09-08T09:39:47.388Z","comments":true,"path":"2022/09/08/notes/cmake/","link":"","permalink":"https://cxx001.gitee.io/2022/09/08/notes/cmake/","excerpt":"","text":"概叙你或许听过好几种 Make 工具，例如 GNU Make ，QT 的 qmake ，微软的 MS nmake，BSD Make（pmake），Makepp，等等。这些 Make 工具遵循着不同的规范和标准，所执行的 Makefile 格式也千差万别。这样就带来了一个严峻的问题：如果软件想跨平台，必须要保证能够在不同平台编译。而如果使用上面的 Make 工具，就得为每一种标准写一次 Makefile ，这将是一件让人抓狂的工作。 CMake就是针对上面问题所设计的工具：它首先允许开发者编写一种平台无关的 CMakeLists.txt 文件来定制整个编译流程，然后再根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件，如 Unix 的 Makefile 或 Windows 的 Visual Studio 工程。 入门示例这是一个对输入的数求平方根的示例，用编译配置开关控制是调用系统数学函数(sqrt)还是自定义函数(mysqrt)。主要包含设置版本号、配置头文件(可选项开关)、添加静态库的使用。 1. 目录结构 build目录自己创建，内容执行cmake命令自动生成 MathFunctions目录是自定义的数学函数库(会编译成静态库) tuorial.cpp主入口文件 2. cmake命令使用 配置环境 测试环境：windows11 需要安装CMake 和 MinGW，MinGW 就是 GCC 的 Windows 移植版本。 构建命令，只需要第一次执行一次 cmake -G”MinGW Makefiles” .. 构建系统是需要指定 CMakeLists.txt 所在路径，此时在 build 目录下，所以用 .. 表示 CMakeLists.txt 在上一级目录。 Windows 下，CMake 默认使用微软的 MSVC 作为编译器，我想使用 MinGW 编译器，可以通过 -G 参数来进行指定，只有第一次构建项目时需要指定。 执行完会在 build 目录下会生成 Makefile 文件。 编译、链接可执行程序 cmake –build . –build 指定编译生成的文件存放目录，其中就包括可执行文件，. 表示存放到当前目录 执行完会在 build 目录下生成一个 Tutorial.exe 可执行文件 设置配置的可选项开关 cmake -DUSE_MYMATH&#x3D;OFF .. 把USE_MYMATH设置为OFF，此设置将存储在缓存中，以便用户不需要在每次构建项目时设置该值。 3. 源码所有细节看详细注释 123456789101112131415161718192021222324252627282930313233343536373839404142// tutorial.cpp#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &quot;TutorialConfig.h&quot;// USE_MYMATH 编译开关#ifdef USE_MYMATH #include &quot;MathFunctions.h&quot;#endif/* argv[0] Tutorial.exe argv[1] 外部输入第一个参数*/int main(int argc, char* argv[])&#123; if (argc &lt; 2) &#123; // 版本号使用示例 // Tutorial_VERSION_MAJOR 主版本号 Tutorial_VERSION_MINOR 次版本号 std::cout &lt;&lt; argv[0] &lt;&lt; &quot; Version &quot; &lt;&lt; Tutorial_VERSION_MAJOR &lt;&lt; &quot;.&quot; &lt;&lt; Tutorial_VERSION_MINOR &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; number&quot; &lt;&lt; std::endl; return 2; &#125; // 将输入字符串转换为double const double inputValue = std::stod(argv[1]); // 编译开关控制调用系统sqrt还是自己的mysqrt #ifdef USE_MYMATH const double outputValue = mysqrt(inputValue); #else const double outputValue = sqrt(inputValue); #endif std::cout &lt;&lt; &quot;The square root of &quot; &lt;&lt; inputValue &lt;&lt; &quot; is &quot; &lt;&lt; outputValue &lt;&lt; std::endl; return 0;&#125; 123// MathFunctions.hdouble mysqrt(double value); 12345678// mysqrt.cpp#include &quot;MathFunctions.h&quot;double mysqrt(double value)&#123; return 1.0;&#125; 12345678// TutorialConfig.h.in// 编译配置文件, 执行cmake --build . 会自定生成对应.h头文件#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@ // 主版本号#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@ // 次版本号#cmakedefine USE_MYMATH // 使用使用自定义库的编译开关 12345678910111213141516171819202122232425262728293031323334353637383940# 外层主CMakeLists.txt# 指定cmake最低版本cmake_minimum_required(VERSION 3.15)# 设置项目名称和版本号# 这里项目名称会自定映射到 PROJECT_NAME 宏上# 这里的版本号会自定映射到 Tutorial_VERSION_MAJOR=1 Tutorial_VERSION_MINOR=0 这两个宏上(TutorialConfig.h.in中配置)project(Tutorial VERSION 1.0)# 配置头文件将版本号传递给源代码, TutorialConfig.h.in编译时自定生成TutorialConfig.h需要这么配置下生效configure_file(TutorialConfig.h.in TutorialConfig.h)# 指定c++标准(现在新版本的cmake默认是c++14标准, 如果没有使用更高特性这里可以不用指定)set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# 可选项配置, USE_MYMATH定义在TutorialConfig.h.in配置中, 默认缺省值是 ON# 修改：build目录下 cmake -DUSE_MYMATH=OFF ..option(USE_MYMATH &quot;Use tutorial provided math implementation&quot; ON)# 如果开了则使用自定义库，否则用系统的if(USE_MYMATH) add_subdirectory(MathFunctions) # 指定库所在目录, 此目录应包含库的CMakeLists.txt和代码文件 list(APPEND EXTRA_LIBS MathFunctions) # APPEND表示将元素MathFunctions追加到列表EXTRA_LIBS中endif()# 设置变量SRC_LIST的值tutorial.cpp(值可以多个空格隔开)SET(SRC_LIST tutorial.cpp)# 用来生成可执行文件，需要指定生成可执行文件的名称和相关源文件add_executable($&#123;PROJECT_NAME&#125; $&#123;SRC_LIST&#125;) # 将库文件(静态库)添加到可执行文件中target_link_libraries($&#123;PROJECT_NAME&#125; PUBLIC $&#123;EXTRA_LIBS&#125;) # 指定目标头文件目录target_include_directories($&#123;PROJECT_NAME&#125; PUBLIC $&#123;PROJECT_BINARY_DIR&#125; ) 123456789# 自定义库CMakeLists.txt# 用来生成库文件(静态库)，需要指定生成库文件的名称和相关源文件add_library(MathFunctions mysqrt.cpp)# 指定目标头文件目录target_include_directories(MathFunctions INTERFACE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125; ) 4. 执行结果 进阶1. 安装程序 程序写完，我们可以通过命令把可执行文件和头文件安装到指定目录。 接着上面工程，在两个CMakeLists.txt文件最后添加安装设置。 123# 指定安装路径install (TARGETS Tutorial DESTINATION bin)install (FILES &quot;$&#123;PROJECT_BINARY_DIR&#125;/TutorialConfig.h&quot; DESTINATION include) 123# 指定 MathFunctions 库的安装路径install (TARGETS MathFunctions DESTINATION bin) # 目标文件install (FILES MathFunctions.h DESTINATION include) # 头文件 执行命令： cmake --install . --prefix &quot;C:\\Users\\KL179\\Desktop\\cmake_test\\install&quot; 2. 测试程序 在根目录的CMakeLists.txt(主)最后添加测试用例。 测试用例主要就是两个接口： add_test 添加用例 set_tests_properties 验证结果 1234567891011121314151617181920212223# 启用测试enable_testing()# 测试程序是否成功运行add_test (test_run Tutorial 8)# 测试帮助信息是否可以正常提示add_test (test_usage Tutorial)# PASS_REGULAR_EXPRESSION 用来测试上面输出是否包含后面跟着的字符串（即测试结果验证）set_tests_properties (test_usage PROPERTIES PASS_REGULAR_EXPRESSION &quot;Usage: .* base exponent&quot;)# 定义一个宏，用来简化测试工作macro (do_test arg1 result)add_test (test_$&#123;arg1&#125; Tutorial $&#123;arg1&#125;)set_tests_properties (test_$&#123;arg1&#125; PROPERTIES PASS_REGULAR_EXPRESSION $&#123;result&#125;)endmacro (do_test)# 使用该宏进行一系列的数据测试do_test (1 &quot;is 1&quot;)do_test (4 &quot;is 2&quot;)do_test (16 &quot;is 4&quot;) 运行ctest执行(或者make test) 3. 支持gdb配置让 CMake 支持 gdb 的设置也很容易，只需要指定 Debug 模式下开启 -g 选项： 12345set(CMAKE_BUILD_TYPE &quot;Debug&quot;)set(CMAKE_CXX_FLAGS_DEBUG &quot;$ENV&#123;CXXFLAGS&#125; -O0 -Wall -g -ggdb&quot;)set(CMAKE_CXX_FLAGS_RELEASE &quot;$ENV&#123;CXXFLAGS&#125; -O3 -Wall&quot;) 4. 检测接口是否存在一般是使用平台相关特性时，下面我们以检测系统是否有sqrt函数为例。 首先在主CMakeLists.txt文件里configure_file之前添加下面设置： 123# 检查系统是否支持 sqrt 函数include ($&#123;CMAKE_ROOT&#125;/Modules/CheckFunctionExists.cmake)check_function_exists (sqrt HAVE_SQRT) 接下来修改 TutorialConfig.h.in 文件，预定义HAVE_SQRT宏变量。 1#cmakedefine HAVE_SQRT 最后就可以使用HAVE_SQRT来判断了。 1234567// tutorial.cpp里添加测试示例#ifdef HAVE_SQRT std::cout &lt;&lt; &quot;check_function_exists sqrt is exist&quot; &lt;&lt; std::endl;#else std::cout &lt;&lt; &quot;check_function_exists sqrt is noexist&quot; &lt;&lt; std::endl;#endif 5. 生成安装包生成各种平台上的安装包，包括二进制安装包和源码安装包。为了完成这个任务，我们需要用到 CPack ，它同样也是由 CMake 提供的一个工具，专门用于打包。 注意：CPack打包依赖 NSIS 需要安装。 只需要在顶层的 CMakeLists.txt 文件尾部添加下面几行： 12345678910# 导入 InstallRequiredSystemLibraries 模块，以便之后导入 CPack 模块include (InstallRequiredSystemLibraries)# 设置一些 CPack 相关变量，包括版权信息和版本信息set (CPACK_RESOURCE_FILE_LICENSE &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/License.txt&quot;)set (CPACK_PACKAGE_VERSION_MAJOR &quot;$&#123;Tutorial_VERSION_MAJOR&#125;&quot;)set (CPACK_PACKAGE_VERSION_MINOR &quot;$&#123;Tutorial_VERSION_MINOR&#125;&quot;)# 导入 CPack 模块include (CPack) 然后命令行执行cmake打包命令就可以打包了。 生成二进制安装包： 1cpack -C CPackConfig.cmake 生成源码安装包 1cpack -C CPackSourceConfig.cmake 生成的安装包，双击安装执行截图如下：","categories":[{"name":"notes","slug":"notes","permalink":"https://cxx001.gitee.io/categories/notes/"}],"tags":[{"name":"cmake","slug":"cmake","permalink":"https://cxx001.gitee.io/tags/cmake/"},{"name":"CMakeLists.txt","slug":"CMakeLists-txt","permalink":"https://cxx001.gitee.io/tags/CMakeLists-txt/"}],"keywords":[{"name":"notes","slug":"notes","permalink":"https://cxx001.gitee.io/categories/notes/"}]},{"title":"提炼《跟我一起写 Makefile》教程","slug":"notes/makefile","date":"2022-09-06T02:13:30.000Z","updated":"2022-09-07T00:27:39.153Z","comments":true,"path":"2022/09/06/notes/makefile/","link":"","permalink":"https://cxx001.gitee.io/2022/09/06/notes/makefile/","excerpt":"","text":"提炼《跟我一起写 Makefile》教程 支持原创，请移步原作者博客： http://blog.csdn.net/haoel/article/details/2886 一、makefile总序1. makefile文件格式1234target...:prerequisites... command ... ... target: 是一个目标文件，也可以是执行文件。还可以是一个标签。（Label） prerequisites: 依赖项，就是要生成那个target所需要的文件或是目标。 command: make需要执行的命令。（任意的Shell命令，必须以Tab开头） 2. makefile执行原理 prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。 3. 定义、使用变量12345objects = main.o kbd.o command.o display.o \\ # 定义变量(类似c/c++中的宏) insert.o search.o files.o utils.oedit : $(objects) # 变量使用 4. make自动推导只要make看到一个[.o]文件(目标文件是.o文件)，它就会自动的把[.c]文件加在依赖关系中，所以依赖中可以省略。 123456789101112131415161718objects = main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.o edit : $(objects) cc -o edit $(objects) main.o : defs.h kbd.o : defs.h command.h command.o : defs.h command.h display.o : defs.h buffer.h insert.o : defs.h buffer.h search.o : defs.h buffer.h files.o : defs.h buffer.h command.h utils.o : defs.h .PHONY : clean clean : rm edit $(objects) 不用自动推导前写法： 12345678910111213141516171819202122objects = main.o kbd.o command.o display.o \\ insert.osearch.o files.o utils.o edit : $(objects) cc -o edit $(objects) main.o : main.c defs.h cc -c main.c kbd.o : kbd.c defs.h command.h cc -c kbd.c command.o : command.c defs.h command.h cc -c command.c display.o : display.c defs.h buffer.h cc -c display.c insert.o : insert.c defs.h buffer.h cc -c insert.c search.o : search.c defs.h buffer.h cc -c search.c files.o : files.c defs.h buffer.h command.h cc -c files.c utils.o : utils.c defs.h cc -c utils.c clean : rm edit $(objects) 注意在Makefile中的命令，必须要以[Tab]键开始。 5. 引用其它的makefile文件在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。 在include前面可以有一些空字符，但是绝不能是[Tab]键开始。include和可以用一个或多个空格隔开。举个例子，你有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了e.mk和f.mk，那么，下面的语句： include foo.make *.mk $(bar) 等价于： include foo.make a.mk b.mk c.mk e.mk f.mk make命令开始时，会查找include所指出的其它Makefile，并把其内容安置在当前的位置。就好像C&#x2F;C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找： 121.如果make执行时，有“-I”或“--include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。2.如果目录/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。 如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如： 1-include&lt;filename&gt; 其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。 6. make的工作方式GNU的make工作时的执行步骤入下：（想来其它的make也是类似） 读入所有的Makefile。(全局环境变量MAKEFILES的值做include操作) 读入被include的其它Makefile。 初始化文件中的变量。 推导隐晦规则，并分析所有规则。 为所有的目标文件创建依赖关系链。 根据依赖关系，决定哪些目标要重新生成。 执行生成命令。 1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。 二、makefile常用规则1. 指定依赖文件搜索目录首先在当前目录查找，找不到会去VPATH变量中找。例如： 1VPATH = src:../headers 上面的的定义指定两个目录，“src”和“..&#x2F;headers”，make会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方） 另外还一个小写vpath，这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。 它的使用方法有三种： vpath &lt; pattern&gt; &lt; directories&gt; 为符合模式&lt; pattern&gt;的文件指定搜索目录。 vpath &lt; pattern&gt; 清除符合模式&lt; pattern&gt;的文件的搜索目录。 vpath 清除所有已被设置好了的文件搜索目录。 vapth使用方法中的&lt; pattern&gt;需要包含“%”字符。“%”的意思是匹配零或若干字符，例如，“%.h”表示所有以“.h”结尾的文件。&lt; pattern&gt;指定了要搜索的文件集，而&lt; directories&gt;则指定了的文件集的搜索的目录。例如： vpath %.h ../headers 该语句表示，要求make在“..&#x2F;headers”目录下搜索所有以“.h”结尾的文件。（如果某文件在当前目录没有找到的话） 2. 伪目标前面示例中最后的clean就是一个伪目标，“伪目标”并不是一个文件，只是一个标签，不会像其它目标一样生成“clean”这个文件。所以伪目标下的命令执行，我们只有通过显示地指明这个“目标”才能让其生效(make clean)。 当然，“伪目标”的取名不能和其它目标文件重名，不然其就失去了“伪目标”的意义了。为了避免这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。 伪目标常规使用 123.PHONY: clean clean: rm *.o temp 如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中 12345678910111213all : prog1 prog2 prog3 .PHONY : all prog1 : prog1.o utils.o cc -o prog1 prog1.o utils.o prog2 : prog2.o cc -o prog2 prog2.o prog3 : prog3.o sort.o utils.o cc -o prog3 prog3.o sort.o utils.o 我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于伪目标的特性是，总是被执行的，所以其依赖的那三个目标就总是不如“all”这个目标新。所以，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。“.PHONY : all”声明了“all”这个目标为“伪目标”。 从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖 123456789.PHONY: cleanall cleanobj cleandiff cleanall : cleanobj cleandiff rm program cleanobj : rm *.o cleandiff : rm *.diff 3. 静态模式静态模式可以更加容易地定义多目标的规则(如果我们的“%.o”有几百个)，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法： 12345&lt;targets...&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt; &lt;commands&gt;... targets 定义了一系列的目标文件，可以有通配符。是目标的一个集合。 target-parrtern 是指明了targets的模式，也就是的目标集模式。 prereq-parrterns 是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。 示例一: 123456789101112objects = foo.o bar.o all: $(objects) $(objects): %.o: %.c $(CC) -c $(CFLAGS) $&lt; -o $@ 我们的目标从$object中获取，“%.o”表明要所有以“.o”结尾的目标，也就是“foo.o bar.o”，也就是变量$object集合的模式，而依赖模式“%.c”则取模式“%.o”的“%”，也就是“foo bar”，并为其加下“.c”的后缀，于是，我们的依赖目标就是“foo.c bar.c”。而命令中的“$&lt;”和“$@”则是自动化变量，“$&lt;”表示所有的依赖目标集（也就是“foo.c bar.c”），“$@”表示目标集（也就是foo.o bar.o”）。上面的规则展开后等价于下面的规则：foo.o : foo.c $(CC) -c $(CFLAGS) foo.c -o foo.obar.o : bar.c $(CC) -c $(CFLAGS) bar.c -o bar.o 4. 自动生成依赖性在 Makefile 中， 我们的依赖关系可能会需要包含一系列的头文件，如果是一个比较大型的工程，你必需清楚哪些 C 文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改 Makefile，这是一个很没有维护性的工作。 为了避免这种繁重而又容易出错的事情，我们可以使用C&#x2F;C++编译的一个功能。大多数的C&#x2F;C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。 注意如果你使用GNU的C/C++编译器，你得用“-MM”参数，不然，“-M”参数会把一些标准库的头文件也包含进来。 自动生成源文件(xxx.c)对应的依赖关系文件(xxx.d)的makefile 12345%.d: %.c @set -e; rm -f $@; #删除.d文件 $(CC) -MM $(CPPFLAGS) $&lt; &gt; $@.; #生成.d随机编号的临时文件 sed &#x27;s,\\.o[ :]*,\\1.o $@ : ,g&#x27; &lt; $@.&gt; $@; #替换随机编号 rm -f $@. ##删除临时文件 在主makefile中引入上面自动生成的依赖关系makefile（也就是.d文件） 1234sources = foo.c bar.cinclude $(sources:.c=.d)# $(sources:.c=.d)中的“.c=.d”的意思是做一个替换，把变量$(sources)所有[.c]的字串都替换成[.d] 5. 定义命令包把多条命令定义成一个变量，后续可以使用这个变量来替代一组命令。语法以define开始，以endef结束，如： 12345678define run-yacc #命令包的名字yacc $(firstword $^) #运行Yacc程序mv y.tab.c $@ #文件改名endef#命令包使用foo.c : foo.y $(run-yacc) #和使用变量一样 三、使用变量1. 定义变量几种形式123456789101112131415161718# 1. 简单的使用“=”号，在“=”左侧是变量，右侧是变量的值，不关心变量定义顺序。foo = $(bar)bar = $(ugh)ugh = Huh?all:echo $(foo)# 2. 必须从上到下定义，关心变量定义顺序使用&quot;:=&quot;y := $(x) bar #y的值是“bar”，而不是“foo bar”了x := foo# 3. “?=” 表示如果变量被定义过则什么也不做，没有定义过则定义FOO ?= bar# 4. “+=” 给变量追加值objects = main.o foo.o bar.o utils.oobjects += another.o 四、条件判断下面的例子，判断$(CC)变量是否“gcc”，如果是的话，则使用GNU函数编译目标。 123456789libs_for_gcc = -lgnunormal_libs =foo: $(objects)ifeq ($(CC),gcc)$(CC) -o foo $(objects) $(libs_for_gcc)else$(CC) -o foo $(objects) $(normal_libs)endif 条件表达式的语法为： 1234567891011&lt;conditional-directive&gt;&lt;text-if-true&gt;endif或者&lt;conditional-directive&gt;&lt;text-if-true&gt;else&lt;text-if-false&gt;endif 五、使用函数1. 函数使用$(&lt;function&gt; &lt;arguments&gt; ) 这里，就是函数名，make支持的函数不多。是函数的参数，参数间以逗号“,”分隔，而函数名和参数之间以“空格”分隔。函数调用以“$”开头，以圆括号或花括号把函数名和参数括起。这和使用变量很类似。 示例：把空格替换为逗号 12345comma:= ,empty:=space:= $(empty) $(empty)foo:= a b cbar:= $(subst $(space),$(comma),$(foo)) #bar的值变为a,b,c 2. 字符串处理函数12345$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt; )名称：字符串替换函数——subst。功能：把字串&lt;text&gt;中的&lt;from&gt;字符串替换成&lt;to&gt;。返回：函数返回被替换过后的字符串。 12345$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt; )名称：模式字符串替换函数——patsubst。功能：查找&lt;text&gt;中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式&lt;pattern&gt;，如果匹配的话，则以&lt;replacement&gt;替换。这里，&lt;pattern&gt;可以包括通配符“%”，表示任意长度的字串。如果&lt;replacement&gt;中也包含“%”，那么，&lt;replacement&gt;中的这个“%”将是&lt;pattern&gt;中的那个“%”所代表的字串。（可以用“\\”来转义，以“\\%”来表示真实含义的“%”字符）返回：函数返回被替换过后的字符串。 12345$(strip &lt;string&gt; )名称：去空格函数——strip。功能：去掉&lt;string&gt;字串中开头和结尾的空字符。返回：返回被去掉空格的字符串值。 12345$(findstring &lt;find&gt;,&lt;in&gt; )名称：查找字符串函数——findstring。功能：在字串&lt;in&gt;中查找&lt;find&gt;字串。返回：如果找到，那么返回&lt;find&gt;，否则返回空字符串。 123456$(filter &lt;pattern...&gt;,&lt;text&gt; )名称：过滤函数——filter。功能：以&lt;pattern&gt;模式过滤&lt;text&gt;字符串中的单词，保留符合模式&lt;pattern&gt;的单词。可以有多个模式。返回：返回符合模式&lt;pattern&gt;的字串。 123456$(filter-out &lt;pattern...&gt;,&lt;text&gt; )名称：反过滤函数——filter-out。功能：以&lt;pattern&gt;模式过滤&lt;text&gt;字符串中的单词，去除符合模式&lt;pattern&gt;的单词。可以有多个模式。返回：返回不符合模式&lt;pattern&gt;的字串。 12345$(sort &lt;list&gt; )名称：排序函数——sort。功能：给字符串&lt;list&gt;中的单词排序（升序）。返回：返回排序后的字符串。 1234567$(word &lt;n&gt;,&lt;text&gt; )名称：取单词函数——word。功能：取字符串&lt;text&gt;中第&lt;n&gt;个单词。（从一开始）返回：返回字符串&lt;text&gt;中第&lt;n&gt;个单词。如果&lt;n&gt;比&lt;text&gt;中的单词数要大，那么返回空字符串。示例：$(word 2, foo bar baz)返回值是“bar”。 12345678$(wordlist &lt;s&gt;,&lt;e&gt;,&lt;text&gt; )名称：取单词串函数——wordlist。功能：从字符串&lt;text&gt;中取从&lt;s&gt;开始到&lt;e&gt;的单词串。&lt;s&gt;和&lt;e&gt;是一个数字。返回：返回字符串&lt;text&gt;中从&lt;s&gt;到&lt;e&gt;的单词字串。如果&lt;s&gt;比&lt;text&gt;中的单词数要大，那么返回空字符串。如果&lt;e&gt;大于&lt;text&gt;的单词数，那么返回从&lt;s&gt;开始，到&lt;text&gt;结束的单词串。示例： $(wordlist 2, 3, foo bar baz)返回值是“bar baz”。 12345678$(words &lt;text&gt; )名称：单词个数统计函数——words。功能：统计&lt;text&gt;中字符串中的单词个数。返回：返回&lt;text&gt;中的单词数。示例：$(words, foo bar baz)返回值是“3”。备注：如果我们要取&lt;text&gt;中最后的一个单词，我们可以这样：$(word $(words &lt;text&gt; ),&lt;text&gt; )。 1234567$(firstword &lt;text&gt; )名称：首单词函数——firstword。功能：取字符串&lt;text&gt;中的第一个单词。返回：返回字符串&lt;text&gt;的第一个单词。示例：$(firstword foo bar)返回值是“foo”。备注：这个函数可以用word函数来实现：$(word 1,&lt;text&gt; )。 3. 文件名操作函数1234567$(dir &lt;names...&gt; )名称：取目录函数——dir。功能：从文件名序列&lt;names&gt;中取出目录部分。目录部分是指最后一个反斜杠（“/”）之前的部分。如果没有反斜杠，那么返回“./”。返回：返回文件名序列&lt;names&gt;的目录部分。示例： $(dir src/foo.c hacks)返回值是“src/ ./”。 1234567$(notdir &lt;names...&gt; )名称：取文件函数——notdir。功能：从文件名序列&lt;names&gt;中取出非目录部分。非目录部分是指最后一个反斜杠（“/”）之后的部分。返回：返回文件名序列&lt;names&gt;的非目录部分。示例： $(notdir src/foo.c hacks)返回值是“foo.c hacks”。 123456$(suffix &lt;names...&gt; )名称：取后缀函数——suffix。功能：从文件名序列&lt;names&gt;中取出各个文件名的后缀。返回：返回文件名序列&lt;names&gt;的后缀序列，如果文件没有后缀，则返回空字串。示例：$(suffix src/foo.c src-1.0/bar.c hacks)返回值是“.c .c”。 1234567$(basename &lt;names...&gt; )名称：取前缀函数——basename。功能：从文件名序列&lt;names&gt;中取出各个文件名的前缀部分。返回：返回文件名序列&lt;names&gt;的前缀序列，如果文件没有前缀，则返回空字串。示例：$(basename src/foo.c src-1.0/bar.c hacks)返回值是“src/foo src-1.0/bar hacks”。 123456$(addsuffix &lt;suffix&gt;,&lt;names...&gt; )名称：加后缀函数——addsuffix。功能：把后缀&lt;suffix&gt;加到&lt;names&gt;中的每个单词后面。返回：返回加过后缀的文件名序列。示例：$(addsuffix .c,foo bar)返回值是“foo.c bar.c”。 123456$(addprefix &lt;prefix&gt;,&lt;names...&gt; )名称：加前缀函数——addprefix。功能：把前缀&lt;prefix&gt;加到&lt;names&gt;中的每个单词后面。返回：返回加过前缀的文件名序列。示例：$(addprefix src/,foo bar)返回值是“src/foo src/bar”。 12345678$(join &lt;list1&gt;,&lt;list2&gt; )名称：连接函数——join。功能：把&lt;list2&gt;中的单词对应地加到&lt;list1&gt;的单词后面。如果&lt;list1&gt;的单词个数要比&lt;list2&gt;的多，那么，&lt;list1&gt;中的多出来的单词将保持原样。如果&lt;list2&gt;的单词个数要比&lt;list1&gt;多，那么，&lt;list2&gt;多出来的单词将被复制到&lt;list2&gt;中。返回：返回连接过后的字符串。示例：$(join aaa bbb , 111 222 333)返回值是“aaa111 bbb222 333”。 4. foreach函数格式：$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt; ) 这个函数的意思是，把参数中的单词逐一取出放到参数所指定的变量中，然后再执行所包含的表达式。每一次会返回一个字符串，循环过程中，所返回的每个字符串会以空格分隔，最后当整个循环结束时，所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。 示例： 12345names := a b c dfiles := $(foreach n,$(names),$(n).o)上面的例子中，$(name)中的单词会被挨个取出，并存到变量“n”中，“$(n).o”每次根据“$(n)”计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以，$(files)的值是“a.o b.o c.o d.o”。 5. if 函数格式： 12345$(if &lt;condition&gt;,&lt;then-part&gt; )或是$(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt; ) 结合参考：《四、条件判断》 6. call 函数call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以用call函数来向这个表达式传递参数。其语法是： $(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;...) 当 make执行这个函数时，参数中的变量，如$(1)，$(2)，$(3)等，会被参数，，依次取代。而的返回值就是 call函数的返回值。例如： reverse &#x3D; $(1) $(2) foo &#x3D; $(call reverse,a,b) 那么，foo的值就是“a b”。当然，参数的次序是可以自定义的，不一定是顺序的，如： reverse &#x3D; $(2) $(1)foo &#x3D; $(call reverse,a,b) 此时的foo的值就是“b a”。 7. origin 函数格式：$(origin &lt;variable&gt; ) 告诉你你的这个变量是哪里来的。 其所有返回值情况： “undefined” 从来没有定义过 “default” 是一个默认的定义，比如“CC”这个变量 “environment” 是一个环境变量，并且当Makefile被执行时，“-e”参数没有被打开 “file” 这个变量被定义在Makefile中 “command line” 这个变量是被命令行定义的 “override” 是被override指示符重新定义的 “automatic” 是一个命令运行中的自动化变量 8. shell 函数shell函数把执行操作系统命令后的输出作为函数返回。 注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。 9. 控制make的函数调试信息，类似error、warning日志输出。 $(error &lt;text ...&gt; ) $(warning &lt;text ...&gt; ) 六、如何使用make命令一般来说，最简单的就是直接在命令行下输入make命令，make命令会找当前目录的makefile来执行，一切都是自动的。但也有时你也许只想让 make重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。本章节就是讲述如何使用make命令的。 1. make的返回值123450 —— 表示成功执行。1 —— 如果make运行时出现任何错误，其返回1。2 —— 如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。 2. 指定makefile前面我们说过，GNU make找寻默认的Makefile的规则是在当前目录下依次找三个文件——“GNUmakefile”、“makefile”和“Makefile”。其按顺序找这三个文件，一旦找到，就开始读取这个文件并执行。 我们也可以给make命令指定一个特殊名字的Makefile。要达到这个功能，我们要使用make的“-f”或是“–file”参数（“– makefile”参数也行）。例如，我们有个makefile的名字是“hchen.mk”，那么，我们可以这样来让make来执行这个文件： make –f hchen.mk 3. 指定目标一般来说，make的最终目标是makefile中的第一个目标，而其它目标一般是由这个目标连带出来的。这是make的默认行为。当然，一般来说，你的 makefile中的第一个目标是由许多个目标组成，你可以指示make，让其完成你所指定的目标。要达到这一目的很简单，在make命令后直接跟目标的名字就可以完成。 常见的指定目标操作： 12345678“all” 这个伪目标是所有目标的目标，其功能一般是编译所有的目标。“clean” 这个伪目标功能是删除所有被make创建的文件。“install” 这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。“print” 这个伪目标的功能是例出改变过的源文件。“tar” 这个伪目标功能是把源程序打包备份。也就是一个tar文件。“dist” 这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。“TAGS” 这个伪目标功能是更新所有的目标，以备完整地重编译使用。“check”和“test” 这两个伪目标一般用来测试makefile的流程。 4. 检查规则1234567891011121314151617181920212223242526有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用make命令的下述参数：“-n”“--just-print”“--dry-run”“--recon”不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试makefile很有用处。“-t”“--touch”这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。“-q”“--question”这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。“-W &lt;file&gt;”“--what-if=&lt;file&gt;”“--assume-new=&lt;file&gt;”“--new-file=&lt;file&gt;”这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件所发生的规则命令。 5. make 参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159下面列举了所有GNU make 3.80版的参数定义。其它版本和产商的make大同小异，不过其它产商的make的具体参数还是请参考各自的产品文档。“-b”“-m”这两个参数的作用是忽略和其它版本make的兼容性。“-B”“--always-make”认为所有的目标都需要更新（重编译）。“-C &lt;dir&gt;”“--directory=&lt;dir&gt;”指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make –C ~hchen/test –C prog”等价于“make –C ~hchen/test/prog”。“—debug[=&lt;options&gt;]”输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是&lt;options&gt;的取值：a —— 也就是all，输出所有的调试信息。（会非常的多）b —— 也就是basic，只输出简单的调试信息。即输出不需要重编译的目标。v —— 也就是verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等。i —— 也就是implicit，输出所以的隐含规则。j —— 也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等。m —— 也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息。“-d”相当于“--debug=a”。“-e”“--environment-overrides”指明环境变量的值覆盖makefile中定义的变量的值。“-f=&lt;file&gt;”“--file=&lt;file&gt;”“--makefile=&lt;file&gt;”指定需要执行的makefile。“-h”“--help”显示帮助信息。“-i”“--ignore-errors”在执行时忽略所有的错误。“-I &lt;dir&gt;”“--include-dir=&lt;dir&gt;”指定一个被包含makefile的搜索目标。可以使用多个“-I”参数来指定多个目录。“-j [&lt;jobsnum&gt;]”“--jobs[=&lt;jobsnum&gt;]”指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的“-j”参数，那么仅最后一个“-j”才是有效的。（注意这个参数在MS-DOS中是无用的）“-k”“--keep-going”出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。“-l &lt;load&gt;”“--load-average[=&lt;load]”“—max-load[=&lt;load&gt;]”指定make运行命令的负载。“-n”“--just-print”“--dry-run”“--recon”仅输出执行过程中的命令序列，但并不执行。“-o &lt;file&gt;”“--old-file=&lt;file&gt;”“--assume-old=&lt;file&gt;”不重新生成的指定的&lt;file&gt;，即使这个目标的依赖文件新于它。“-p”“--print-data-base”输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出一堆信息。如果你只是想输出信息而不想执行 makefile，你可以使用“make -qp”命令。如果你想查看执行makefile前的预设变量和规则，你可以使用“make –p –f /dev/null”。这个参数输出的信息会包含着你的makefile文件的文件名和行号，所以，用这个参数来调试你的makefile会是很有用的，特别是当你的环境变量很复杂的时候。“-q”“--question”不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说明有错误发生。“-r”“--no-builtin-rules”禁止make使用任何隐含规则。“-R”“--no-builtin-variabes”禁止make使用任何作用于变量上的隐含规则。“-s”“--silent”“--quiet”在命令运行时不输出命令的输出。“-S”“--no-keep-going”“--stop”取消“-k”选项的作用。因为有些时候，make的选项是从环境变量“MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效。“-t”“--touch”相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。“-v”“--version”输出make程序的版本、版权等关于make的信息。“-w”“--print-directory”输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用。“--no-print-directory”禁止“-w”选项。“-W &lt;file&gt;”“--what-if=&lt;file&gt;”“--new-file=&lt;file&gt;”“--assume-file=&lt;file&gt;”假定目标&lt;file&gt;需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“-n”那么就像运行UNIX的“touch”命令一样，使得&lt;file&gt;的修改时间为当前时间。“--warn-undefined-variables”只要make发现有未定义的变量，那么就输出警告信息。 七、隐含规则1. 使用隐含规则12foo : foo.o bar.occ –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS) 我们可以注意到，这个Makefile中并没有写下如何生成foo.o和bar.o这两目标的规则和命令。因为make的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成命令。 2. 常用的隐含规则1、编译C程序的隐含规则。“.o”的目标的依赖目标会自动推导为“.c”，并且其生成命令是“$(CC) –c $(CPPFLAGS) $(CFLAGS)” 2、编译C++程序的隐含规则。“.o” 的目标的依赖目标会自动推导为“.cc”或是“.C”，并且其生成命令是“$(CXX) –c $(CPPFLAGS) $(CFLAGS)”。（建议使用“.cc”作为C++源文件的后缀，而不是“.C”） 3、编译Pascal程序的隐含规则。“.o”的目标的依赖目标会自动推导为“.p”，并且其生成命令是“$(PC) –c $(PFLAGS)”。 4、编译Fortran&#x2F;Ratfor程序的隐含规则。“.o”的目标的依赖目标会自动推导为“.r”或“.F”或“.f”，并且其生成命令是:“.f” “$(FC) –c $(FFLAGS)”“.F” “$(FC) –c $(FFLAGS) $(CPPFLAGS)”“.f” “$(FC) –c $(FFLAGS) $(RFLAGS)” 5、预处理Fortran&#x2F;Ratfor程序的隐含规则。“.f”的目标的依赖目标会自动推导为“.r”或“.F”。这个规则只是转换Ratfor或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：“.F” “$(FC) –F $(CPPFLAGS) $(FFLAGS)”“.r” “$(FC) –F $(FFLAGS) $(RFLAGS)” 6、编译Modula-2程序的隐含规则。“.sym” 的目标的依赖目标会自动推导为“.def”，并且其生成命令是：“$(M2C) $(M2FLAGS) $(DEFFLAGS)”。“&lt;n.o&gt;” 的目标的依赖目标会自动推导为“.mod”，并且其生成命令是：“$(M2C) $(M2FLAGS) $(MODFLAGS)”。 7、汇编和汇编预处理的隐含规则。“.o” 的目标的依赖目标会自动推导为“.s”，默认使用编译品“as”，并且其生成命令是：“$(AS) $(ASFLAGS)”。“.s” 的目标的依赖目标会自动推导为“.S”，默认使用C预编译器“cpp”，并且其生成命令是：“$(AS) $(ASFLAGS)”。 8、链接Object文件的隐含规则。“” 目标依赖于“.o”，通过运行C的编译器来运行链接程序生成（一般是“ld”），其生成命令是：“$(CC) $(LDFLAGS) .o $(LOADLIBES) $(LDLIBS)”。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则： x : y.o z.o 并且“x.c”、“y.c”和“z.c”都存在时，隐含规则将执行如下命令： cc -c x.c -o x.occ -c y.c -o y.occ -c z.c -o z.occ x.o y.o z.o -o xrm -f x.orm -f y.orm -f z.o 如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。 9、Yacc C程序时的隐含规则。 “.c”的依赖文件被自动推导为“n.y”（Yacc生成的文件），其生成命令是：“$(YACC) $(YFALGS)”。（“Yacc”是一个语法分析器，关于其细节请查看相关资料） 10、Lex C程序时的隐含规则。“.c”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX) $(LFALGS)”。（关于“Lex”的细节请查看相关资料） 11、Lex Ratfor程序时的隐含规则。“.r”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX) $(LFALGS)”。 12、从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。“.ln” （lint生成的文件）的依赖文件被自动推导为“n.c”，其生成命令是：“$(LINT) $(LINTFALGS) $(CPPFLAGS) -i”。对于“.y”和“.l”也是同样的规则。 3. 隐含规则使用的变量在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的“-R”或“–no– builtin-variables”参数来取消你所定义的变量对隐含规则的作用。 我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如“CC”；一种是参数相的关，如“CFLAGS”。下面是所有隐含规则中会用到的变量： 1、关于命令的变量。 AR 函数库打包程序。默认命令是“ar”。AS汇编语言编译程序。默认命令是“as”。CCC语言编译程序。默认命令是“cc”。CXXC++语言编译程序。默认命令是“g++”。CO从 RCS文件中扩展文件程序。默认命令是“co”。CPPC程序的预处理器（输出是标准输出设备）。默认命令是“$(CC) –E”。FCFortran 和 Ratfor 的编译器和预处理程序。默认命令是“f77”。GET从SCCS文件中扩展文件的程序。默认命令是“get”。LEXLex方法分析器程序（针对于C或Ratfor）。默认命令是“lex”。PCPascal语言编译程序。默认命令是“pc”。YACCYacc文法分析器（针对于C程序）。默认命令是“yacc”。YACCRYacc文法分析器（针对于Ratfor程序）。默认命令是“yacc –r”。MAKEINFO转换Texinfo源文件（.texi）到Info文件程序。默认命令是“makeinfo”。TEX从TeX源文件创建TeX DVI文件的程序。默认命令是“tex”。TEXI2DVI从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是“texi2dvi”。WEAVE转换Web到TeX的程序。默认命令是“weave”。CWEAVE转换C Web 到 TeX的程序。默认命令是“cweave”。TANGLE转换Web到Pascal语言的程序。默认命令是“tangle”。CTANGLE转换C Web 到 C。默认命令是“ctangle”。RM删除文件命令。默认命令是“rm –f”。 2、关于命令参数的变量 下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。 ARFLAGS函数库打包程序AR命令的参数。默认值是“rv”。ASFLAGS汇编语言编译器参数。（当明显地调用“.s”或“.S”文件时）。CFLAGSC语言编译器参数。CXXFLAGSC++语言编译器参数。COFLAGSRCS命令参数。CPPFLAGSC预处理器参数。（ C 和 Fortran 编译器也会用到）。FFLAGSFortran语言编译器参数。GFLAGSSCCS “get”程序参数。LDFLAGS链接器参数。（如：“ld”）LFLAGSLex文法分析器参数。PFLAGSPascal语言编译器参数。RFLAGSRatfor 程序的Fortran 编译器参数。YFLAGSYacc文法分析器参数。 八、make其它使用对于上述所有的make的细节，我们不但可以利用make这个工具来编译我们的程序，还可以利用make来完成其它的工作，因为规则中的命令可以是任何Shell之下的命令，所以，在Unix下，你不一定只是使用程序语言的编译器，你还可以在Makefile中书写其它的命令，如：tar、awk、mail、sed、cvs、compress、ls、rm、yacc、rpm、 ftp……等等，等等，来完成诸如**”程序打包”、”程序备份”、”制作程序安装包”、”提交代码”、”使用程序模板”、”合并文件”**等等五花八门的功能，文件操作，文件管理，编程开发设计，或是其它一些异想天开的东西。","categories":[{"name":"notes","slug":"notes","permalink":"https://cxx001.gitee.io/categories/notes/"}],"tags":[{"name":"makefile","slug":"makefile","permalink":"https://cxx001.gitee.io/tags/makefile/"},{"name":"make","slug":"make","permalink":"https://cxx001.gitee.io/tags/make/"}],"keywords":[{"name":"notes","slug":"notes","permalink":"https://cxx001.gitee.io/categories/notes/"}]},{"title":"Linux共享内存","slug":"project/Linux共享内存","date":"2022-08-23T06:20:55.000Z","updated":"2022-09-07T00:27:39.175Z","comments":true,"path":"2022/08/23/project/Linux共享内存/","link":"","permalink":"https://cxx001.gitee.io/2022/08/23/project/Linux%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/","excerpt":"","text":"基础在linux系统开发当中，时常需要在多个进程之间交换数据，在多个进程之间交换数据，有很多方法，但最高效的方法莫过于共享内存。 linux共享内存是通过tmpfs这个文件系统来实现的，tmpfs文件系的目录为&#x2F;dev&#x2F;shm，&#x2F;dev&#x2F;shm是驻留在内存 RAM 当中的，因此读写速度与读写内存速度一样，&#x2F;dev&#x2F;shm的容量默认尺寸为系统内存大小的一半大小，使用df -h命令可以看到。但实际上它并不会真正的占用这块内存，如果&#x2F;dev&#x2F;shm&#x2F;下没有任何文件，它占用的内存实际上就是0字节，仅在使用shm_open文件时，&#x2F;dev&#x2F;shm才会真正占用内存。 在Linux系统使用共享内存，一般用到以下几个函数： 12345678910// 用于创建或者打开共享内存文件int shm_open(const char *name, int oflag, mode_t mode);// 将打开的文件映射到内存void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);// 取消内存映射int munmap(void *addr, size_t length);// 删除/dev/shm目录的文件int shm_unlink(const char *name);// 重置文件大小int ftruncate(int fd, off_t length); 示例1. 共享内存相关操作封装SimuShareMem.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#ifndef __SIMU_SHARE_MEM_#define __SIMU_SHARE_MEM_enum &#123; SIMU_MAX_SHM_BLOCK_QUEUE_LEN = 1024, // 队列长度 SIMU_MAX_SHM_BLOCK_BUFF_LEN = 2048 // 缓冲区数据长度&#125;;// 共享内存块typedef struct TagSimuShareMemBlock&#123; int ReadDataPtr; // 读下标 int WriteDataptr; // 写下标 unsigned long nCoverCount; // 写覆盖次数(好像不准确) unsigned long nRepeatCount; // 读重复次数(没用到) unsigned long nDataType[SIMU_MAX_SHM_BLOCK_QUEUE_LEN]; // 数据类型 unsigned long nDataLen[SIMU_MAX_SHM_BLOCK_QUEUE_LEN]; // 数据长度 char szData[SIMU_MAX_SHM_BLOCK_QUEUE_LEN][SIMU_MAX_SHM_BLOCK_BUFF_LEN]; // 数据区 &#125;SimuShareMemBlock_t;// 共享全双工节点typedef struct TagSimuShareMemNode &#123; int nReadShmfd; // 读共享内存文件句柄 int nWriteShmfd; // 写共享内存文件句柄 SimuShareMemBlock_t* pReadShm; // 读共享内存区块 SimuShareMemBlock_t* pWriteShm; // 写共享内存区块 char szReadShmName[128]; // 读共享内存块名称 char szWriteShmName[128]; // 写共享内存块名称&#125;SimuShareMemNode_t;// 共享内存数据typedef struct TagSimuShareMemData&#123; int nDataType; unsigned long ulDataLen; char* pData; unsigned long ulTsl; unsigned long ulTs2;&#125;SimuShareMemData_t;int CreateShareMemNode(SimuShareMemNode_t* pNode, const char* szWriteShmName, const char* szReadShmName);int OpenShareMemNode(SimuShareMemNode_t* pNode, const char* szWriteShmName, const char* szReadShmName);int CloseShareMemNode(SimuShareMemNode_t* pNode); // 取消内存映射int UnlinkShareMem(const char* szWriteShmName, const char* szReadShmName); // 删除/dev/shm目录的文件int IsNewShareMemData(SimuShareMemNode_t* pNode);int ReadShareMemData(SimuShareMemNode_t* pNode, SimuShareMemData_t* pShmData);int WriteShareMemData(SimuShareMemNode_t* pNode, int nDataType, const char* pData, unsigned long ulDataLen);#endif SimuShareMem.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242//#ifdef LINUX_PLATFORM#include &quot;SimuShareMem.h&quot;#include &lt;stdbool.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/mman.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;static SimuShareMemBlock_t* CreateShareMemBlock(int* pFd, const char* szBlockName);static SimuShareMemBlock_t* OpenShareMemBlock(int* pFd, const char* szBlockName);SimuShareMemBlock_t* CreateShareMemBlock(int* pFd, const char* szBlockName)&#123; SimuShareMemBlock_t* pBlock = NULL; int hFd = 0; if (pFd == NULL || szBlockName == NULL) &#123; return NULL; &#125; // 打开文件如果没有就创建, 存在则打开失败返回-1 hFd = shm_open(szBlockName, O_CREAT|O_EXCL|O_RDWR, S_IRWXU|S_IRWXG); if (hFd == -1) &#123; if (errno == EEXIST) &#123; hFd = shm_open(szBlockName, O_RDWR, S_IRWXU); if (hFd == -1) &#123; return NULL; &#125; &#125; else &#123; return NULL; &#125; &#125; // 重置文件大小 if (ftruncate(hFd, sizeof(SimuShareMemBlock_t)) == -1) &#123; close(hFd); return NULL; &#125; // 将打开的文件映射到内存 pBlock = (SimuShareMemBlock_t*)mmap(NULL, sizeof(SimuShareMemBlock_t), PROT_READ|PROT_WRITE, MAP_SHARED, hFd, 0); if (pBlock == NULL) &#123; close(hFd); return NULL; &#125; *pFd = hFd; return pBlock; // 共享内存地址&#125;SimuShareMemBlock_t* OpenShareMemBlock(int* pFd, const char* szBlockName)&#123; SimuShareMemBlock_t* pBlock = NULL; int hFd = shm_open(szBlockName, O_RDWR, S_IRWXU); if (hFd == -1) &#123; return NULL; &#125; pBlock = (SimuShareMemBlock_t*)mmap(NULL, sizeof(SimuShareMemBlock_t), PROT_READ|PROT_WRITE, MAP_SHARED, hFd, 0); if (pBlock == NULL) &#123; close(hFd); return NULL; &#125; *pFd = hFd; return pBlock;&#125;int CreateShareMemNode(SimuShareMemNode_t* pNode, const char* szWriteName, const char* szReadName)&#123; bool bError = false; if (pNode == NULL || szWriteName == NULL || szReadName == NULL) &#123; return -1; &#125; strcpy(pNode-&gt;szWriteShmName, szWriteName); strcpy(pNode-&gt;szReadShmName, szReadName); pNode-&gt;nReadShmfd = 0; pNode-&gt;nWriteShmfd = 0; do &#123; pNode-&gt;pReadShm = CreateShareMemBlock(&amp;pNode-&gt;nReadShmfd, pNode-&gt;szReadShmName); if (pNode-&gt;pReadShm == NULL) &#123; bError = true; break; &#125; pNode-&gt;pReadShm-&gt;nCoverCount = 0; pNode-&gt;pReadShm-&gt;nRepeatCount = 0; pNode-&gt;pReadShm-&gt;ReadDataPtr = 0; pNode-&gt;pReadShm-&gt;WriteDataptr = 0; pNode-&gt;pWriteShm = CreateShareMemBlock(&amp;pNode-&gt;nWriteShmfd, pNode-&gt;szWriteShmName); if (pNode-&gt;pWriteShm == NULL) &#123; bError = true; break; &#125; pNode-&gt;pWriteShm-&gt;nCoverCount = 0; pNode-&gt;pWriteShm-&gt;nRepeatCount = 0; pNode-&gt;pWriteShm-&gt;ReadDataPtr = 0; pNode-&gt;pWriteShm-&gt;WriteDataptr = 0; &#125; while(0); if(bError) &#123; CloseShareMemNode(pNode); return -1; &#125; return 0;&#125;int OpenShareMemNode(SimuShareMemNode_t* pNode, const char* szWriteName, const char* szReadName)&#123; bool bError = false; if (pNode == NULL || szWriteName == NULL || szReadName == NULL) &#123; return -1; &#125; strcpy(pNode-&gt;szWriteShmName, szWriteName); strcpy(pNode-&gt;szReadShmName, szReadName); pNode-&gt;nReadShmfd = 0; pNode-&gt;nWriteShmfd = 0; do &#123; pNode-&gt;pReadShm = OpenShareMemBlock(&amp;pNode-&gt;nReadShmfd, pNode-&gt;szReadShmName); if (pNode-&gt;pReadShm == NULL) &#123; bError = true; break; &#125; // 这里注释是因为写的测试程序起来就写数据了, 所以读的测试程序获取这块空间时不能重置了. // 正常程序这里不要注释，所有进程都要启动了，才能往共享内存里读写数据. /* pNode-&gt;pReadShm-&gt;nCoverCount = 0; pNode-&gt;pReadShm-&gt;nRepeatCount = 0; pNode-&gt;pReadShm-&gt;ReadDataPtr = 0; pNode-&gt;pReadShm-&gt;WriteDataptr = 0; */ pNode-&gt;pWriteShm = OpenShareMemBlock(&amp;pNode-&gt;nWriteShmfd, pNode-&gt;szWriteShmName); if (pNode-&gt;pWriteShm == NULL) &#123; bError = true; break; &#125; /* pNode-&gt;pWriteShm-&gt;nCoverCount = 0; pNode-&gt;pWriteShm-&gt;nRepeatCount = 0; pNode-&gt;pWriteShm-&gt;ReadDataPtr = 0; pNode-&gt;pWriteShm-&gt;WriteDataptr = 0; */ &#125; while(0); if(bError) &#123; CloseShareMemNode(pNode); return -1; &#125; return 0;&#125;int CloseShareMemNode(SimuShareMemNode_t* pNode)&#123; if (pNode == NULL) &#123; return -1; &#125; if (pNode-&gt;pReadShm != NULL) &#123; // 取消内存映射 munmap(pNode-&gt;pReadShm, sizeof(SimuShareMemBlock_t)); pNode-&gt;pReadShm = NULL; close(pNode-&gt;nReadShmfd); &#125; if (pNode-&gt;pWriteShm != NULL) &#123; // 取消内存映射 munmap(pNode-&gt;pWriteShm, sizeof(SimuShareMemBlock_t)); pNode-&gt;pWriteShm = NULL; close(pNode-&gt;nWriteShmfd); &#125; return 0;&#125;int UnlinkShareMem(const char* szWriteName, const char* szReadName)&#123; // 删除/dev/shm目录的文件 shm_unlink(szWriteName); shm_unlink(szReadName); return 0;&#125;int IsNewShareMemData(SimuShareMemNode_t* pNode)&#123; SimuShareMemBlock_t* pShm = pNode-&gt;pReadShm; if (pShm-&gt;ReadDataPtr % SIMU_MAX_SHM_BLOCK_QUEUE_LEN == pShm-&gt;WriteDataptr % SIMU_MAX_SHM_BLOCK_QUEUE_LEN) &#123; return -1; &#125; return 0;&#125;int ReadShareMemData(SimuShareMemNode_t* pNode, SimuShareMemData_t* pShmData)&#123; SimuShareMemBlock_t* pShm = pNode-&gt;pReadShm; unsigned long nReadIdx = 0; if (pShm-&gt;ReadDataPtr % SIMU_MAX_SHM_BLOCK_QUEUE_LEN == pShm-&gt;WriteDataptr % SIMU_MAX_SHM_BLOCK_QUEUE_LEN) &#123; return -1; &#125; nReadIdx = pShm-&gt;ReadDataPtr % SIMU_MAX_SHM_BLOCK_QUEUE_LEN; pShmData-&gt;nDataType = pShm-&gt;nDataType[nReadIdx]; pShmData-&gt;ulDataLen = pShm-&gt;nDataLen[nReadIdx]; pShmData-&gt;pData = (char*)malloc(pShmData-&gt;ulDataLen); memcpy((void*)pShmData-&gt;pData, pShm-&gt;szData[nReadIdx], pShmData-&gt;ulDataLen); pShm-&gt;ReadDataPtr += 1; pShm-&gt;ReadDataPtr %= SIMU_MAX_SHM_BLOCK_QUEUE_LEN; pShmData-&gt;ulTsl = time(NULL); return 0;&#125;int WriteShareMemData(SimuShareMemNode_t* pNode, int nDataType, const char* pData, unsigned long ulDataLen)&#123; SimuShareMemBlock_t* pShm = pNode-&gt;pWriteShm; unsigned long nWriteIdx = 0; if (pShm-&gt;ReadDataPtr == (pShm-&gt;WriteDataptr + 1) % SIMU_MAX_SHM_BLOCK_QUEUE_LEN) &#123; pShm-&gt;nCoverCount++; // 这里不知道啥意思 &#125; nWriteIdx = pShm-&gt;WriteDataptr % SIMU_MAX_SHM_BLOCK_QUEUE_LEN; memcpy(pShm-&gt;szData[nWriteIdx], pData, ulDataLen); pShm-&gt;nDataLen[nWriteIdx] = ulDataLen; pShm-&gt;nDataType[nWriteIdx] = nDataType; pShm-&gt;WriteDataptr++; pShm-&gt;WriteDataptr %= SIMU_MAX_SHM_BLOCK_QUEUE_LEN; return 0;&#125;//#endif 2. 使用示例共享内存写数据: writer.c 编译命令: g++ writer.c SimuShareMem.h SimuShareMem.cpp -o writer -lrt 注意最后的 -lrt链接库不能少，不然shm_open等相关函数不认识 ! 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &quot;SimuShareMem.h&quot;int main(int argc,char * argv[])&#123; SimuShareMemNode_t pNode; const char* szWriteShmName = &quot;shm_writer&quot;; const char* szReadShmName = &quot;shm_reader&quot;; CreateShareMemNode(&amp;pNode, szWriteShmName, szReadShmName); char writeData[] = &quot;test share memory writer.&quot;; int result = WriteShareMemData(&amp;pNode, 1, writeData, sizeof(writeData)); printf(&quot;result:%d, data:%s, len:%ld&quot;, result, writeData, sizeof(writeData)); getchar(); CloseShareMemNode(&amp;pNode); UnlinkShareMem(szWriteShmName, szReadShmName); return 0;&#125; 共享内存读数据：reader.c 编译命令: g++ reader.c SimuShareMem.h SimuShareMem.cpp -o reader -lrt 1234567891011121314151617#include &lt;stdio.h&gt;#include &quot;SimuShareMem.h&quot;int main(int argc,char * argv[])&#123; SimuShareMemNode_t pNode; const char* szWriteShmName = &quot;shm_writer&quot;; const char* szReadShmName = &quot;shm_reader&quot;; OpenShareMemNode(&amp;pNode, szReadShmName, szWriteShmName); // 这里的读是对面的写 SimuShareMemData_t srData; int result = ReadShareMemData(&amp;pNode, &amp;srData); printf(&quot;result: %d, data: %s, len: %ld&quot;, result, srData.pData, srData.ulDataLen); getchar(); return 0;&#125; 3. 测试结果 测试机器 分别启动writer&#x2F;reader程序读写结果 &#x2F;dev&#x2F;shm目录下新增对应两个共享内存文件","categories":[{"name":"project","slug":"project","permalink":"https://cxx001.gitee.io/categories/project/"}],"tags":[{"name":"共享内存","slug":"共享内存","permalink":"https://cxx001.gitee.io/tags/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"}],"keywords":[{"name":"project","slug":"project","permalink":"https://cxx001.gitee.io/categories/project/"}]},{"title":"虚拟地址到物理地址映射","slug":"computer system/虚拟地址到物理地址映射","date":"2022-08-19T16:32:55.000Z","updated":"2022-09-07T00:27:39.147Z","comments":true,"path":"2022/08/20/computer system/虚拟地址到物理地址映射/","link":"","permalink":"https://cxx001.gitee.io/2022/08/20/computer%20system/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/","excerpt":"","text":"前言程序在编译链接完成后所有指令虚拟地址就已经确定了，CPU在执行到某条指令，得到它的虚拟地址，然后通过其芯片里的MMU硬件将虚拟地址转换为物理地址，然后先去CPU芯片里的高速缓存中获取数据，如果没有再去内存中获取(这里程序会自动预测CPU下次指令要执行的数据，会提前把数据从内存传递到高速缓存中)。 其中虚拟地址映射到物理地址的实现大体经历了4次优化历程，下面依次分析。 名词约定： va: 虚拟地址 pa: 物理地址 一 “%”取模pa &#x3D; va % pa_max_len 最早就是用这种取模的方式来做映射的，它保证了虚拟地址映射不会越界。但是有个很明显的问题，就是地址冲突，同时只能运行一个程序，不能多开。 二 哈希后来为了解决地址冲突问题，我们想到了用哈希map来实现，va–&gt;hashmap–&gt;pa，它能保证每个va都能映射唯一的pa，解决了地址冲突的问题。 但是通过hashmap计算出的pa地址分布是凌乱的，这样寻址就会很低效。 三 段地址既然哈希算法转换的地址凌乱分布，导致寻址低效。那么有没有办法使得一段连续虚拟地址对应的物理地址也连续了？ 后面人们想到了用一段段连续空间来表示，如下图，程序p2分布在两个段空间内，段内地址是连续的，那么我们记录这样的段空间就可以用(va0, pa0, D)一个三元组来表示。va0是段虚拟地址的起始地址，pa0是物理地址的起始地址，D是段空间范围。 那么我们要映射某个物理地址va，过程是这样，先循环判断条件 va0 &lt;&#x3D; va &lt;&#x3D; va0 + D，找出va属于哪个段，然后 pa &#x3D; va - va0 + pa0; 这种方式解决了映射地址分布凌乱的问题，但是我们发现段的范围D是不固定的，根据当前内存使用情况决定。随着各种程序运行推移，一个程序很难找到一段比较长的空闲空间，他会分布到多个段空间中，碎片化越来越严重。 而且还一个问题是每次映射都要先查找属于哪个段的条件判断，这也是麻烦之一。 四 多级分页最终我们想到了让D保持不变，一般默认是4kb大小，这样的话我们描述映射表就只需要一个二元组了(va0, pa0)，甚至我们还可以直接用表的key索引来当va0字段，这样就只需要一个字段pa0记录了。 同时把内存分成一个个固定大小的页来作为最小的储存单元，这样相对不定长的段碎片也会少很多。 不过了光只是一层分页还不够，还可以再进一步优化，即多级分页，一般分到4层，每层4等分。那为什么要这么干了？下面我们来分析下其中缘由： 对于我们64位cpu一般va寻址范围是2^48，首先我们按4kb(2^12)分页，总共页数&#x3D; 2^48 &#x2F; 2^12 &#x3D; 2^36. 假设有个程序只分布在上图中的3个区域，那么这样就有个问题，这个程序有效数据其实只有图中的3个区域，但是我们却要申请2^36这么大一个数组来记录，大部分都是无效数据。 怎么优化了，那就是再往下分，每次4等分。 这样是不是这个程序的3个区域只在4(0~3)等分后的第1和第3个分区里。那么我们就只需要记录第1和第3个分区。依次类推再往下分，要记录的无效数据就会越来越少，即所要申请的记录数组越小。","categories":[{"name":"computer system","slug":"computer-system","permalink":"https://cxx001.gitee.io/categories/computer-system/"}],"tags":[{"name":"内存","slug":"内存","permalink":"https://cxx001.gitee.io/tags/%E5%86%85%E5%AD%98/"},{"name":"虚拟地址","slug":"虚拟地址","permalink":"https://cxx001.gitee.io/tags/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/"},{"name":"物理地址","slug":"物理地址","permalink":"https://cxx001.gitee.io/tags/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80/"}],"keywords":[{"name":"computer system","slug":"computer-system","permalink":"https://cxx001.gitee.io/categories/computer-system/"}]},{"title":"QuikPlatform Demo说明","slug":"project/QuikPlatform Demo说明","date":"2022-08-01T09:32:55.000Z","updated":"2022-09-07T00:27:39.177Z","comments":true,"path":"2022/08/01/project/QuikPlatform Demo说明/","link":"","permalink":"https://cxx001.gitee.io/2022/08/01/project/QuikPlatform%20Demo%E8%AF%B4%E6%98%8E/","excerpt":"","text":"QuikPaltformTest目录结构12345678910111213141516171819202122232425QuikPaltformTest |--&gt; bin // 打包后可执行程序 |--&gt; doc // 文档 |--&gt; trunk |--&gt; bin // 平台的动态库 |--&gt; include // 平台的头文件 |--&gt; CoreApp |--&gt; CoreLib |--&gt; CoreUi |--&gt; KIQtGui |--&gt; MyUI |--&gt; server |--&gt; server_imp |--&gt; ToolsLib |--&gt; lib // 平台的静态库 |--&gt; src // 自定义源码 |--&gt; plugins // 自定义插件 |--&gt; MyUI |--&gt; PluginGreetServer |--&gt; PluginUIA |--&gt; PluginUIB |--&gt; PluginUIC |--&gt; QuikPlatformIDE // 工程目录 |--&gt; QuikPlatformIDE.sln // vs启动文件 |--&gt; ... 创建插件 QuikPaltform平台封装了一套插件机制，通过开发各种插件然后组装起来就形成了一个软件。插件分为UI插件、Server插件、两者都有插件，他们遵循的规范都大同小异，分为声明接口、实现接口、注册这3个步骤。下面以Demo中”SayHello”服务接口为例： 1.声明对外提供的接口12345678910111213141516// IGreetServer.h...namespace Kcc &#123; namespace Greet &#123; class IGreetServer &#123; public： virtual ~IGreetServer() &#123;&#125; virtual void SayHello() = 0; // 对外提供的接口 &#125;; typedef QSharedPointer&lt;IGreetServer&gt; PIGreetServer; // 接口对象的智能指针 // 插件定义的通知事件类型 enum &#123; Notify_SayHello = 1 &#125;;&#125;&#125;... 2.实现接口1234567891011121314151617181920// GreetSever.h.../*如果想构建自己的服务，必须先继承ServerBase和自己自定义的服务接口（IGreetServer）*/class GreetServer : public ServerBase, public IGreetServer&#123;public: GreetServer(); ~GreetServer();public: // IServerInterfaceBase里的这几个接口必须要实现 virtual QString GetServerGroupName() const &#123; return SERVER_GROUP_IGREETSERVER_NAME; &#125; virtual QString GetInterfaceDefName() const &#123; return SERVER_INTERFACE_IGREETSERVER_NAME; &#125; virtual unsigned int GetVersion() const &#123; return SERVER_VERSION; &#125;public: // IGreetServer virtual void SayHello();&#125;;... 12345678910111213141516171819202122// GreetSever.cpp...void GreetServer::SayHello()&#123; //输出log日志 LOGOUT(QString(&quot;GreetServer SayHello&quot;), LOG_NORMAL); //1.发送通知：先请求对应的服务，这个服务对象类型为必须是PIServerInterfaceBase PIServerInterfaceBase pserver = RequestServer(SERVER_GROUP_IGREETSERVER_NAME, SERVER_INTERFACE_IGREETSERVER_NAME); //2.确定发送参数，发送命令（Notify_SayHello）是必须的，参数可以根据实际情况判断是否需要 NotifyStruct notifyStruct; notifyStruct.code = Notify_SayHello; notifyStruct.paramMap[&quot;Sender&quot;] = &quot;come from Greetserver&quot;; //3.发送通知 if (pserver) &#123; pserver-&gt;emitNotify(notifyStruct); &#125;&#125;... 3.插件注册123456789101112// PluginGreetServer.h...//每个被注册的模块都必须继承Moduleclass PluginGreetServer : public Module&#123; //每个模块都必须使用此宏 DEFINE_MODULEpublic: PluginGreetServer(QString strName); ~PluginGreetServer();&#125;;... 123456789101112131415...// 静态注册（当dll被加载时会调用），每个模块都必须使用此宏（第一个参数是当前类的类型；第二个是组的名称，一般为空；第三个是显示名称，一般是类型名称）REG_MODULE_BEGIN(PluginGreetServer, &quot;&quot;, &quot;PluginGreetServer&quot;)REG_MODULE_END(PluginGreetServer)//每个Module的参数一般情况为Module_Type_Normal，根据实际情况而定PluginGreetServer::PluginGreetServer(QString strName):Module(Module_Type_Normal, strName)&#123; /* 注册问候服务（服务都必须在构造的时候注册，请求服务一般都在所有模块构造之后，这样可以确保所有服务都已经被注册， 可以在每个模块的init()函数中请求，因为这个函数会在所有模块被构造之后被调用） */ RegServer&lt;GreetServer&gt;(new GreetServer());&#125;... 使用插件1. 通过直接获取插件对象指针来调用其接口123456789101112131415161718// PluginUIB.h...class PluginUIB :public QWidget, public Module&#123; Q_OBJECT DEFINE_MODULEpublic: PluginUIB(QString strName); ~PluginUIB();public: //Module virtual void init(KeyValueMap ¶ms); virtual void unInit(KeyValueMap &amp;saveParams);private: PIGreetServer m_pGreetServer; // 问候服务接口&#125;;... 12345678910111213141516171819202122232425262728// PluginUIB.cpp...void PluginUIB::init(KeyValueMap ¶ms)&#123; // 1. 获取要使用插件对象 m_pGreetServer = RequestServer&lt;IGreetServer&gt;(SERVER_GROUP_IGREETSERVER_NAME, SERVER_INTERFACE_IGREETSERVER_NAME); if (!m_pGreetServer) &#123; LOGOUT(&quot;IGreetServer未注册&quot;, LOG_ERROR); &#125;&#125;void PluginUIB::unInit(KeyValueMap &amp;saveParams)&#123; // 3. 使用插件对象释放 m_pGreetServer.clear();&#125;// 槽函数void PluginUIB::onPluginBTest()&#123; ui.textEdit-&gt;append(&quot;面板B的按钮已经被按下&quot;); if (m_pGreetServer) &#123; // 2. 调用插件对象对外提供的接口 m_pGreetServer-&gt;SayHello(); &#125;&#125; 2. 通过消息发布&#x2F;订阅的形式使用插件接口1234567891011121314151617181920// PluginUIC.cpp// 订阅消息(消息接收方)void PluginUIC::init(KeyValueMap &amp;params)&#123; // 1.请求问候服务 PIServerInterfaceBase pGreetserver = RequestServer(SERVER_GROUP_IGREETSERVER_NAME, SERVER_INTERFACE_IGREETSERVER_NAME); // 2.连接槽函数 pGreetserver-&gt;connectNotify(Notify_SayHello, this, SLOT(onRecieveGreetMsg(unsigned int, const NotifyStruct&amp;)));&#125;// 3. 槽函数消息响应void PluginUIC::onRecieveGreetMsg(unsigned int code, const NotifyStruct&amp; param)&#123; if (code == Notify_SayHello) &#123; QString strGreetMsg = param.paramMap[&quot;Sender&quot;].toString(); ui.textEdit-&gt;append(strGreetMsg); &#125; QMessageBox::about(this, tr(&quot;测试双击菜单&quot;), tr(&quot;双击响应！&quot;));&#125; 123456789101112131415161718192021// GreetSever.cpp// 发布消息(消息发送方)void GreetServer::SayHello()&#123; //输出log日志 LOGOUT(QString(&quot;GreetServer SayHello&quot;), LOG_NORMAL); //1.发送通知：先请求对应的服务，这个服务对象类型为必须是PIServerInterfaceBase PIServerInterfaceBase pserver = RequestServer(SERVER_GROUP_IGREETSERVER_NAME, SERVER_INTERFACE_IGREETSERVER_NAME); //2.确定发送参数，发送命令（Notify_SayHello）是必须的，参数可以根据实际情况判断是否需要 NotifyStruct notifyStruct; notifyStruct.code = Notify_SayHello; notifyStruct.paramMap[&quot;Sender&quot;] = &quot;come from Greetserver&quot;; //3.发送通知 if (pserver) &#123; pserver-&gt;emitNotify(notifyStruct); &#125;&#125;","categories":[{"name":"project","slug":"project","permalink":"https://cxx001.gitee.io/categories/project/"}],"tags":[{"name":"QT","slug":"QT","permalink":"https://cxx001.gitee.io/tags/QT/"},{"name":"软件架构","slug":"软件架构","permalink":"https://cxx001.gitee.io/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"}],"keywords":[{"name":"project","slug":"project","permalink":"https://cxx001.gitee.io/categories/project/"}]},{"title":"飞行仿真项目服务端设计","slug":"project/飞行仿真项目服务端设计","date":"2022-08-01T08:32:55.000Z","updated":"2022-09-07T00:27:39.177Z","comments":true,"path":"2022/08/01/project/飞行仿真项目服务端设计/","link":"","permalink":"https://cxx001.gitee.io/2022/08/01/project/%E9%A3%9E%E8%A1%8C%E4%BB%BF%E7%9C%9F%E9%A1%B9%E7%9B%AE%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"Table of Contents generated with DocToc 一 服务端架构概览 技术选型 整体架构 二 通信协议格式 1. 与前端通信 Package层 Message层 2. 与引擎通信 三 用户Gra4工程导入 Gra4格式 DB格式 下位机引擎生成代码平铺后的格式 一 服务端架构概览技术选型 nodejs + mongodb，多进程、分布式的服务器。 nodejs优势: io与可伸缩性的优势。io密集型的应用采用node.js是最合适的， 可达到最好的可伸缩性。 多进程单线程的应用架构。node.js天生采用单线程， 使它在处理复杂逻辑的时候无需考虑线程同步、锁、死锁等一系列问题， 减少了很多逻辑错误。 由多进程node.js组成的服务器群是最理想的应用架构之一。 语言优势。使用javascript开发可以实现快速迭代，如果客户端使用html 5，更可实现代码共用。 mongodb优势: 使用简单、方便。不需要预先定义表结构, 和写json配置一样自然。 整体架构 注： 上图中的方块表示进程， 定义上等同于“服务器“ 运行架构说明： 客户端登录网关服(gate), 网关服会根据connector服务器群负载情况，动态分配一个返回给客户端。 客户端通过websocket长连接连到connector服务器群。 connector负责承载连接，并把请求转发到后端的服务器群。 后端的服务器群主要包括引擎服务器(engine)、验证服务器(auth)等， 这些服务器负责各自的业务逻辑。后面还会有各种其它类型的服务器。 后端服务器处理完逻辑后把结果返回给connector， 再由connector广播回给客户端。 master负责统一管理这些服务器，包括各服务器的启动、监控和关闭等功能。 二 通信协议格式1. 与前端通信 基于tcp&#x2F;websocket方式通信, 底层使用的是二进制协议。协议包含两层编码: package和message。message层主要实现route压缩和protobuf压缩，message层的编码结果将传递给package层。package层主要实现应用基于二进制协议的握手过程，心跳和数据传输编码，package层的编码结果可以通过tcp，websocket等协议以二进制数据的形式进行传输。message层编码可选，也可替换成其他二进制编码格式，都不影响package层编码和发送。 协议层的结构如下图所示： Package层 package格式 package分为header和body两部分。header描述package包的类型和包的长度，body则是需要传输的数据内容。具体格式如下： type - package类型，1个byte，取值如下。 0x01: 客户端到服务器的握手请求以及服务器到客户端的握手响应 0x02: 客户端到服务器的握手ack 0x03: 心跳包 0x04: 数据包 0x05: 服务器主动断开连接通知 length - body内容长度，3个byte的大端整数，因此最大的包长度为2^24个byte。 body - 二进制的传输内容。 握手 握手流程主要提供一个机会，让客户端和服务器在连接建立后，进行一些初始化的数据交换。握手的内容为utf-8编码的json字符串（不压缩），通过body字段传输。 握手请求： 123456789&#123; &quot;sys&quot;: &#123; &quot;version&quot;: &quot;1.1.1&quot;, &quot;type&quot;: &quot;js-websocket&quot; &#125;, &quot;user&quot;: &#123; // any customized request data &#125;&#125; 握手响应: 1234567891011&#123; &quot;code&quot;: 200, // response code &quot;sys&quot;: &#123; &quot;heartbeat&quot;: 3, // heartbeat interval in second &quot;dict&quot;: &#123;&#125;, // route dictionary &quot;protos&quot;: &#123;&#125; // protobuf definition data &#125;, &quot;user&quot;: &#123; // any customized response data &#125;&#125; 握手流程如下: 当底层连接建立后，客户端向服务器发起握手请求，并附带必要的数据。服务器检验握手数据后，返回握手响应。如果握手成功，客户端向服务器发送一个握手ack，握手阶段至此成功结束。 心跳 心跳包的length字段为0，body为空。 心跳的流程如下： 服务器可以配置心跳时间间隔。当握手结束后，客户端发起第一个心跳。服务器和客户端收到心跳包后，延迟心跳间隔的时间后再向对方发送一个心跳包。 心跳超时时间为2倍的心跳间隔时间。服务器检测到心跳超时并不会主动断开客户端的连接。客户端检测到心跳超时，可以根据策略选择是否要主动断开连接。 数据 数据包用来在客户端和服务器之间传输数据所用。数据包的body是由上层传下来的任意二进制数据，package层不会对body内容做任何处理。 服务器主动断开 当服务器主动断开客户端连接时（如：踢掉某个在线用户），会先向客户端发送一个控制消息，然后再断开连接。客户端可以通过这个消息来判断是否是服务器主动断开连接的。 Message层message协议的主要作用是封装消息头，包括route和消息类型两部分，不同的消息类型有着不同的消息头，在消息头里面可能要打入message id(即requestId)和route信息。由于可能会有route压缩，而且对于服务端push的消息，message id为空，对于客户端请求的响应，route为空，因此message的头格式比较复杂。 消息头分为三部分，flag，message id，route。如下图所示： 从上图可以看出，消息头是可变的，会根据具体的消息类型和内容而改变。其中： flag位是必须的，占用一个byte，它决定了后面的消息类型和内容的格式; message id和route则是可选的。其中message id采用varints 128变长编码方式，根据值的大小，长度在0～5byte之间。route则根据消息类型以及内容的大小，长度在0～255byte之间。 标志位flag flag占用message头的第一个byte，其内容如下: 现在只用到了其中的4个bit，这四个bit包括两部分，占用3个bit的message type字段和占用1个bit的route标识，其中： message type用来标识消息类型,范围为0～7，现在消息共有四类，request，notify，response，push，值的范围是0～3。不同的消息类型有着不同的消息内容，下面会有详细分析。 最后一位的route表示route是否压缩，影响route字段的长度。 这两部分之间相互独立，互不影响。 消息类型 不同类型的消息，对应不同消息头，消息类型通过flag字段的第2-4位来确定，其对应关系以及相应的消息头如下图： route压缩标志位 route主要分为压缩和未压缩两种，由flag的最后一位（route压缩标志位）指定，当flag中的route标志为0时，表示未压缩的route，为1则表示是压缩route。route字段的编码会依赖flag的这一位，其格式如下图: 上图是不同的flag标志对应的route字段的内容： flag的最后一位为1时，后面跟的是一个uInt16表示的route字典编号，需要通过查询字典来获取route; flag最后一位为0是，后面route则由一个uInt8的byte，用来表示route的字节长度。之后是通过utf8编码后的route字符串，其长度就是前面一位byte的uInt8的值，因此route的长度最大支持256B。 2. 与引擎通信采用zmq通信，在后台服务器engine上起两个监听端口, 分别是zmq的Publisher模式(25150)和Pull模式(25151)。 服务端向下位机引擎发送消息: 1234567// Publisher模式:// 下位机引擎建立连接时，注册以uid为key的管道sock.connect(&quot;tcp://127.0.0.1:25150&quot;)sock.subscribe(&quot;uid&quot;)// 服务端向下位机引擎发送消息sock.send([&quot;uid&quot;, &quot;message&quot;]) 下位机引擎向服务端发送消息： 三 用户Gra4工程导入Gra4格式 主要的几个字段： 123UnitGroup: 当前画板模型列表IoportGroup: 输入/输出模块列表LineGroup: 连线列表 DB格式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 工程表 project&#123; id: String // 项目ID uid: String // 用户ID data: [sub] // 画板数组，每个元素对应一个画板&#125; sub: &#123; id: String // 画板ID name: String // 画板名称 pid: String // 画板关联的父ID block: [block] // 画板包含的模型 line: [line] // 画板包含的线&#125;block: &#123; id: String // 模型ID child: String // 模型关联的子画板ID(即子系统) modelId: String // 关联导入的数字模型ID (uid_dll_funcName) name: String // 模型名称 nodeType: Number // 模型类型(方形、圆形) position: Object // 模型位置 &#123; &quot;x&quot;: number, &quot;y&quot;: number &#125; size: Object // 模型大小 &#123; &quot;width&quot;: number), &quot;height&quot;: number &#125;; items: [&#123; &quot;id&quot;: &quot;out_0&quot;, &quot;group&quot;: &quot;in&quot; &#125;, &#123; &quot;id&quot;: &quot;in_0&quot;, &quot;group&quot;: &quot;out&quot; &#125;] // 端口描述 entity: String // 切换的实物ID, 默认null modifyAttr: &#123;&#125; // 修改的属性(和simulink逻辑一致, 先这里取修改的, 没有再去导入数字模型表中取)&#125;line: &#123; id: String // 连线ID lineType: Number // 连线类型 1: 细线 2: 粗线 source: Object // 线头 &#123;&quot;cell&quot;: 模型ID, &quot;port&quot;: 端口ID&#125; target: Object // 线尾 &#123;&quot;cell&quot;: 模型ID, &quot;port&quot;: 端口ID&#125; subLine: [] // 粗线详情 [&#123;source: Object, target: Object&#125;]&#125;// 示例结构&#123; id: string uid: string data: [ &#123; id: string, pid: string, name: string, block: [&#123; id: string, child: string, modelId: string, name: string, nodeType: int, position: Object, size: Object, items: [&#123; &quot;id&quot;: &quot;out_0&quot;, &quot;group&quot;: &quot;in&quot; &#125;, &#123; &quot;id&quot;: &quot;in_0&quot;, &quot;group&quot;: &quot;out&quot; &#125;], entity: null, modifyAttr: &#123;&#125; &#125;], line: [&#123; id: string, lineType: int, source: Object, target: Object, subLine: [] &#125;], &#125; ]&#125; 一个项目就是一个树结构，根节点就是顶层画板，子节点是子系统画板，叶子节点是最小的模型。 Gra4转DB整体思路： 读取解析项目中所有gra4文件，并找出顶层画板gra4对象(根据IoportGroup的Count属性为0判断)。 从顶层画板开始递归遍历。 首先确定当前遍历画板的中间模块和连线关系(不考虑Ioport相关模块与连线), 即下图圈起来部分: 然后确定当前遍历画板的IO模块和连线关系： 遍历与Ioport模块相关连的线，并记录连线端口信息。 然后在当前画板的父画板所有连线中找到与当前子系统连线端口一致的连线。 如果外边连线是粗线(一组线)，则需要判断是否展开，如果线连接的是子系统与子系统则不需要展开, 其它都展开。 如果是展开，则每条展开的线对应一个IO模块，以这条线对应的端口做为其ID。然后把连线关系建立起来。 如果不展开，则这条线会对应创建一个IO模块，如果这条线详情大于1条，则还会创建一个总线模块，IO模块ID同样根据线对应的端口确定，总线端口则根据线详情确定。最后把连线关系建立起来。 转换后的示意图: 下位机引擎生成代码平铺后的格式12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#123; &quot;PartitionGroup&quot;: [ &#123; &quot;Id&quot;: 0, &quot;CpuId&quot;: 0, &quot;Name&quot;: &quot;动力仿真子模型&quot;, &quot;BlockGroup&quot;: [ &#123; &quot;Id&quot;: 0, &quot;Name&quot;: &quot;发动机1&quot;, &quot;Model&quot;: &quot;Engine/EngineClass.json&quot;, &quot;Order&quot;: 0 &#125; ], &quot;BlcokCount&quot;: 5 &#125;, &#123; &quot;Id&quot;: 1, &quot;CpuId&quot;: 1, &quot;Name&quot;: &quot;弹道&quot;, &quot;BlockGroup&quot;: [ &#123; &quot;Id&quot;: 5, &quot;Name&quot;: &quot;部段1&quot;, &quot;Model&quot;: &quot;Mass/SegmentFunction.json&quot;, &quot;Order&quot;: 5 &#125; ], &quot;BlcokCount&quot;: 4 &#125; ], &quot;LineGroup&quot;: [ &#123; &quot;Src&quot;: 0, &quot;Dst&quot;: 1, &quot;SrcPort&quot;: 1, &quot;DstPort&quot;: 0, &quot;SrcName&quot;: &quot;发动机1&quot;, &quot;DstName&quot;: &quot;贮箱1&quot; &#125; ], &quot;IP&quot;: &quot;192.168.0.100&quot;, &quot;PartitionTotal&quot;: 2, &quot;BlockTotal&quot;: 9, &quot;LineTotal&quot;: 12&#125; DB转换engine平铺格式整体思路： 难点是生成LineGroup连线，其它信息获取比较简单，遍历DB树就能获取。下面主要记录下LineGroup连线生成的思路： 遍历所有最小模块，找出每个最小模块所有输出的连线。 然后遍历每条输出连线，递归查找出每条连线最后连的最小模块，即得到一条平铺后的连线。 递归逻辑： 如果线连的目标是子系统，则进入到子系统里边，依次找到连的目标递归。 如果线连的目标是IO&#x2F;总线模块，则找到线目标模块递归。 直到线连的目标是最小模块，跳出递归，确定连线。","categories":[{"name":"project","slug":"project","permalink":"https://cxx001.gitee.io/categories/project/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://cxx001.gitee.io/tags/nodejs/"},{"name":"服务器架构","slug":"服务器架构","permalink":"https://cxx001.gitee.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/"},{"name":"仿真","slug":"仿真","permalink":"https://cxx001.gitee.io/tags/%E4%BB%BF%E7%9C%9F/"}],"keywords":[{"name":"project","slug":"project","permalink":"https://cxx001.gitee.io/categories/project/"}]},{"title":"pomelo更新日志","slug":"pomelo/pomelo更新日志","date":"2022-08-01T08:05:16.000Z","updated":"2022-09-07T00:27:39.154Z","comments":true,"path":"2022/08/01/pomelo/pomelo更新日志/","link":"","permalink":"https://cxx001.gitee.io/2022/08/01/pomelo/pomelo%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/","excerpt":"","text":"Table of Contents generated with DocToc 1.0 日志 zookeeper集群管理 自动扩展插件 根据环境目录加载配置 客户端程序支持输入脚本命令 0.9 日志 rpc支持zeromq通信 客户端程序支持启动&#x2F;重启指定服务器 支持连接黑名单机制 支持protobuf原生的proto协议格式 websocket支持自动重连 0.8 日志 多个pushScheduler的配置及选择 rpc调用支持指定某台&#x2F;某类服务器 添加服务器生命周期回调 rpc也支持filter, 使用和handler的filter类似 servers.json配置新增集群简化配置 pomelo-logger支持动态日志级别 RPC调用的IP白名单 pomelo-admin的IP白名单 0.7日志 定时任务 新增全局filter 0.6日志 服务器与master之间的连接添加认证 plugin插件机制 连接加密 过载保护 0.5日志 master多机热备技术 分布式全局globalChannel 服务器自动重启 服务器绑定指定CPU 添加服务器关闭前事件 0.4日志 协议的编解码方式支持可配 支持同一账号多处登录 服务端检测心跳超时可配置是否断开连接 1.0 日志zookeeper集群管理 自动扩展插件 根据环境目录加载配置 默认先加载config根目录下的配置，当config目录下没有对应的文件时才会加载环境名称对应的目录下的配置。 客户端程序支持输入脚本命令 0.9 日志rpc支持zeromq通信 客户端程序支持启动&#x2F;重启指定服务器 支持连接黑名单机制 支持protobuf原生的proto协议格式 pomelo中使用步骤: 定义proto协议 用protobuf.js包自带命令将proto转js 加载js使用(protobuf.js本来是可以直接加载proto不需要转的，这里之所以转成js使用是考虑和pomelo原有的格式保持一致) websocket支持自动重连 0.8 日志多个pushScheduler的配置及选择 rpc调用支持指定某台&#x2F;某类服务器 添加服务器生命周期回调 rpc也支持filter, 使用和handler的filter类似 servers.json配置新增集群简化配置在0.8版的pomelo中对配置文件servers.json进行了精简，通过增加clusterCount字段将原有的配置进行了简化，这样将更加适合大规模应用的部署和运维管理。 原有的配置： 12345678910111213&quot;connector&quot;:[ &#123;&quot;id&quot;:&quot;connector-server-1&quot;, &quot;host&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:4050, &quot;clientPort&quot;: 3050, &quot;frontend&quot;: true&#125;, &#123;&quot;id&quot;:&quot;connector-server-2&quot;, &quot;host&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:4051, &quot;clientPort&quot;: 3051, &quot;frontend&quot;: true&#125;, &#123;&quot;id&quot;:&quot;connector-server-3&quot;, &quot;host&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:4052, &quot;clientPort&quot;: 3052, &quot;frontend&quot;: true&#125; ], &quot;chat&quot;:[ &#123;&quot;id&quot;:&quot;chat-server-1&quot;, &quot;host&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:6050&#125;, &#123;&quot;id&quot;:&quot;chat-server-2&quot;, &quot;host&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:6051&#125;, &#123;&quot;id&quot;:&quot;chat-server-3&quot;, &quot;host&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:6052&#125; ], &quot;gate&quot;:[ &#123;&quot;id&quot;: &quot;gate-server-1&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;clientPort&quot;: 3014, &quot;frontend&quot;: true&#125; ] 0.8版本pomelo支持的简化配置： 123456789&quot;connector&quot;:[ &#123;&quot;host&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:&quot;4050++&quot;, &quot;clientPort&quot;: &quot;3050++&quot;, &quot;frontend&quot;: true, &quot;clusterCount&quot;: 3&#125; ],&quot;chat&quot;:[ &#123;&quot;host&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:&quot;6050++&quot;, &quot;clusterCount&quot;: 3&#125; ],&quot;gate&quot;:[ &#123;&quot;host&quot;: &quot;127.0.0.1&quot;, &quot;clientPort&quot;: 3014, &quot;frontend&quot;: true, &quot;clusterCount&quot;: 1&#125; ] 同时在采用pomelo-cli进行动态增加服务器的时候，同样可以使用add host&#x3D;127.0.0.1 port&#x3D;9000++ serverType&#x3D;chat clusterCount&#x3D;3 这样的形式同时增加多台服务器。 pomelo-logger支持动态日志级别 RPC调用的IP白名单 pomelo-admin的IP白名单 0.7日志定时任务用户能够通过配置文件或者pomelo-cli的命令addCron和removeCron对定时任务进行动态调度。 定时任务是针对具体服务器而言，例如需要在chat服务器中配置定时任务： 首先在game-server&#x2F;app&#x2F;servers&#x2F;chat目录下增加cron目录，在game-server&#x2F;app&#x2F;servers&#x2F;chat&#x2F;cron目录下编写具体的执行的任务的代码chatCron.js，例如： 1234567891011module.exports = function(app) &#123; return new Cron(app);&#125;;var Cron = function(app) &#123; this.app = app;&#125;;var cron = Cron.prototype;cron.sendMoney = function() &#123; console.log(&#x27;%s server is sending money now!&#x27;, this.app.serverId);&#125;; 然后在game-server&#x2F;config&#x2F;目录下增加定时任务配置文件crons.json，具体配置文件如下所示： 1234567891011121314&#123; &quot;development&quot;:&#123; &quot;chat&quot;:[ &#123;&quot;id&quot;:1, &quot;time&quot;: &quot;0 30 10 * * *&quot;, &quot;action&quot;: &quot;chatCron.sendMoney&quot;&#125;, &#123;&quot;id&quot;:2, &quot;serverId&quot;:&quot;chat-server-1&quot;, &quot;time&quot;: &quot;0 30 10 * * *&quot;, &quot;action&quot;: &quot;chatCron.sendMoney&quot;&#125; ] &#125;, &quot;production&quot;:&#123; &quot;chat&quot;:[ &#123;&quot;id&quot;:1, &quot;time&quot;: &quot;0 30 10 * * *&quot;, &quot;action&quot;: &quot;chatCron.sendMoney&quot;&#125;, &#123;&quot;id&quot;:2, &quot;serverId&quot;:&quot;chat-server-1&quot;, &quot;time&quot;: &quot;0 30 10 * * *&quot;, &quot;action&quot;: &quot;chatCron.sendMoney&quot;&#125; ] &#125;&#125; 新增全局filter 0.6日志服务器与master之间的连接添加认证 plugin插件机制 连接加密 过载保护在pomelo之前的版本中有toobusy模块对服务器进行过载保护，在新版本中增加了一个对connector连接数的限制功能，开发者只需要在servers.json中对不同的connector进行最大连接数量的配置，当connector超过配置的最大数量，服务器会拒绝连接。配置可以参考如下代码： 1&#123;&quot;id&quot;:&quot;connector-server-1&quot;, &quot;host&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:4050, &quot;clientPort&quot;:3050, &quot;frontend&quot;:true, &quot;max-connections&quot;: 100&#125; 0.5日志master多机热备技术 分布式全局globalChannel 服务器自动重启 服务器绑定指定CPU为了更加充分的利用服务器的CPU，Pomelo在0.5版本中增加了服务器进程与指定CPU进行绑定，该功能限于linux系统的多核服务器，如果需要将服务器与具体CPU进行绑定，只需要在servers.json中进行配置，具体配置如下： 12345678910111213&#123; &quot;development&quot;:&#123; &quot;connector&quot;:[ &#123;&quot;id&quot;:&quot;connector-server-1&quot;, &quot;host&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:4050, &quot;clientPort&quot;: 3050, &quot;frontend&quot;: true, &quot;cpu&quot;: 2&#125; ] &quot;chat&quot;:[ &#123;&quot;id&quot;:&quot;chat-server-1&quot;, &quot;host&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:6050, &quot;cpu&quot;: 1&#125; ] &quot;gate&quot;:[ &#123;&quot;id&quot;: &quot;gate-server-1&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;clientPort&quot;: 3014, &quot;frontend&quot;: true, &quot;cpu&quot;: 3&#125; ] &#125;&#125; 添加服务器关闭前事件 0.4日志协议的编解码方式支持可配 支持同一账号多处登录 目前默认会挤号，应该是自己添加的逻辑。 服务端检测心跳超时可配置是否断开连接","categories":[{"name":"pomelo","slug":"pomelo","permalink":"https://cxx001.gitee.io/categories/pomelo/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://cxx001.gitee.io/tags/nodejs/"},{"name":"服务器架构","slug":"服务器架构","permalink":"https://cxx001.gitee.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/"}],"keywords":[{"name":"pomelo","slug":"pomelo","permalink":"https://cxx001.gitee.io/categories/pomelo/"}]},{"title":"npm包管理机制","slug":"nodejs/npm包管理机制","date":"2022-08-01T07:43:16.000Z","updated":"2022-09-07T00:27:39.151Z","comments":true,"path":"2022/08/01/nodejs/npm包管理机制/","link":"","permalink":"https://cxx001.gitee.io/2022/08/01/nodejs/npm%E5%8C%85%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/","excerpt":"","text":"一 package.json 组成： Dependencies依赖包支持的配置格式： &quot;core-js&quot;: &quot;^1.1.5&quot; 指定版本号，去npm服务器下载包 &quot;test2-js&quot;: &quot;http://cdn.com/test2-js.tar.gz&quot; 一个可下载的压缩包地址，去下载并解压安装 &quot;antd&quot;: &quot;ant-design/ant-design#4.0.0-alpha.8&quot; github用户名&#x2F;仓库名[#tag&#x2F;commitid]这种格式 git ulr形式下载安装，如：git+https://github.com/itwmike/axios.gitgit+ssh://git@github.com:itwmike/axios.git devDependencies属性与dependencies区别，dev是开发环境，只在开发环境使用，用户使用你的包时即使不安装这些依赖也可以正常运行，npm install时也会被安装和管理，但是不会被安装到生产环境。 scripts 用于配置一些脚本命令的缩写，各个脚本可以互相组合使用，这些脚本可以覆盖整个项目的生命周期，配置后可使用 npm run command 进行调用。如果是 npm 关键字，则可以直接调用。 二 npm包管理 npm view xxx version/versions 查看某个包最新版本&#x2F;所有发布的版本 ~: 当安装依赖时获取到有新版本时，安装到 x.y.z 中 z 的最新的版本。即保持主版本号、次版本号不变的情况下，保持修订号的最新版本。 ^: 当安装依赖时获取到有新版本时，安装到 x.y.z 中 y 和 z 都为最新版本。即保持主版本号不变的情况下，保持次版本号、修订版本号为最新版本。 package-lock.json文件，锁定依赖版本意味着在我们不手动执行更新的情况下，每次安装依赖都会安装固定版本。保证整个团队使用版本号一致的依赖。 使用 npm outdated 可以帮助我们列出有哪些还没有升级到最新版本的依赖： 黄色表示不符合我们指定的语意化版本范围 - 不需要升级 红色表示符合指定的语意化版本范围 - 需要升级 执行 npm update 会升级所有的红色依赖。 依赖变更 升级依赖: 修改 package.json文件的依赖版本，执行 npm install。 降级依赖: 执行 npm install package@version, 重新安装(改动package.json不会对依赖进行降级)。 注意改动依赖后提交lock文件 npm install执行原理 在执行 npm install 或 npm update命令下载依赖后，除了将依赖包安装在node_modules 目录下外，还会在本地的缓存目录缓存一份。查看缓存目录命令：npm config get cache npm 提供了几个命令来管理缓存数据： npm cache add：官方解释说这个命令主要是 npm 内部使用，但是也可以用来手动给一个指定的 package 添加缓存。 npm cache clean：删除缓存目录下的所有数据，为了保证缓存数据的完整性，需要加上 –force 参数。 npm cache verify：验证缓存数据的有效性和完整性，清理垃圾数据。 yarn yarn 是在 2016 年发布的，那时 npm 还处于 V3 时期，那时候还没有 package-lock.json 文件，就像上面我们提到的：不稳定性、安装速度慢等缺点经常会受到广大开发者吐槽。此时，yarn 诞生. yarn也有yarn.lock文件，原理大致和npm的一致，只是yarn.lock 中子依赖的版本号不是固定的，意味着单独一个 yarn.lock 确定不了 node_modules 目录结构，还需要和 package.json 文件进行配合。而 package-lock.json 只需要一个文件即可确定。 查看缓存目录：yarn cache dir删除缓存：yarn cache clean","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://cxx001.gitee.io/categories/nodejs/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://cxx001.gitee.io/tags/npm/"}],"keywords":[{"name":"nodejs","slug":"nodejs","permalink":"https://cxx001.gitee.io/categories/nodejs/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-07-06T20:42:52.000Z","updated":"2022-09-07T00:27:39.150Z","comments":true,"path":"2022/07/07/hello-world/","link":"","permalink":"https://cxx001.gitee.io/2022/07/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}