{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://cxx001.gitee.io"},"pages":[],"posts":[{"title":"飞行仿真引擎调度流程","slug":"project/飞行仿真引擎调度流程","date":"2023-03-27T03:54:50.000Z","updated":"2023-04-28T05:11:08.064Z","comments":true,"path":"2023/03/27/project/飞行仿真引擎调度流程/","link":"","permalink":"https://cxx001.gitee.io/2023/03/27/project/%E9%A3%9E%E8%A1%8C%E4%BB%BF%E7%9C%9F%E5%BC%95%E6%93%8E%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B/","excerpt":"","text":"前言介绍仿真引擎如何调度前，我们先回顾一些基本概念，什么是积分算法，导数？ 这篇文章介绍得很通俗: 微分、积分、微积分、导数之详细辨别 就是用于计算曲线的，导数描述曲线变化率，求积分就是用导数来计算曲线轨迹的过程。 下面是一些常见仿真引擎积分算法: 定步长欧拉法 定步长辛普森法 二阶龙格库塔法 三阶龙格库塔法 四阶龙格库塔法 四阶Adams-Bashford法 离散似然法 调度逻辑1. 模块接口封装1234567891011// 1. 初始化int32_t Class::init();// 2. 积分算法(小步长) msg: 消息类型 t: 时间 x：状态变量 f：导数int32_t Class::integral(int32_t msg, double t, double *x, double *f);// 3. 大步长推进void Class::run(void *extra); // 4. 释放void Class::destroy(); 2. 单次仿真调度流程 初始化阶段，先调所有模块的Initialize，然后所有模块的OUTPUT调一次，最后所有模块的WRITEDATA调一次。 步长推进阶段，根据选择的积分算法不同，先多次分别调用所有模块的Continue和OUTPUT，然后调一次WRITEDATA消息，依此循环推进。 最后停止，依次调所有模块的STOP消息释放。 以步长为0.01s，积分算法为四阶龙格库塔法为例，平台消息根据积分算法由多个积分步组成，即4次。 3. 批量仿真调度流程相比单次仿真，只是增加了所有模块单次仿真结束时的END消息处理和从第二次开始的Restart消息重新设置仿真模块参数信息。 Restart时常见的大批量试验设计方法有： 蒙特卡洛法 均匀设计法 正交设计法 拉丁超立方法 偏差管道法 全析因设计法 对应的执行时序图如下：","categories":[{"name":"project","slug":"project","permalink":"https://cxx001.gitee.io/categories/project/"}],"tags":[{"name":"仿真","slug":"仿真","permalink":"https://cxx001.gitee.io/tags/%E4%BB%BF%E7%9C%9F/"}],"keywords":[{"name":"project","slug":"project","permalink":"https://cxx001.gitee.io/categories/project/"}]},{"title":"CMake进阶","slug":"notes/cmake进阶","date":"2023-03-10T09:49:55.000Z","updated":"2023-03-13T03:54:45.150Z","comments":true,"path":"2023/03/10/notes/cmake进阶/","link":"","permalink":"https://cxx001.gitee.io/2023/03/10/notes/cmake%E8%BF%9B%E9%98%B6/","excerpt":"","text":"CMake是什么CMake是一种跨平台的自动化构建工具，可以生成跨平台的构建文件。比如Makefile、Visual Studio、XCode解决方案。使用CMake可以使得编译和构建过程更加简单。CMake使用CMakeLists.txt文件描述项目的构建过程，通过一系列的命令来描述如何编译、链接和打包源代码。 CMake的优点 跨平台支持:CMake可以在windows、linux、macos等操作系统使用，并且可以支持多种编译器和构建工具。 灵活的构建过程:CMake的构建过程非常灵活，可以自定义编译选项、链接库等。 可拓展性:CMake可以使用自定义的模块拓展功能，可以方便的添加新的构建规则和命令。 高效的构建:支持多线程构建，可以加快构建速度。 语法设置变量可以使用set命令设置变量参数,变量可以包含字符串和列表，命令是不区分大小写的 1234# 设置变量project为testset(project &quot;test&quot;)# 设置projects位列表set(projects test1 test2) 引用变量使用${}的方式引用定义的变量内容 12# 下面语句输出testmessage(STATUS $&#123;project&#125;) 条件语句cmake中的条件语句可以使用if、elseif、endif 12345678910# 下面代码根据CMAKE_SYSTEM_NAME判断不同的平台环境if(CMAKE_SYSTEM_NAME STREQUAL &quot;Windows&quot;) # do something for Windowselseif(CMAKE_SYSTEM_NAME STREQUAL &quot;Darwin&quot;) # do something for macOSelseif(CMAKE_SYSTEM_NAME STREQUAL &quot;Linux&quot;) # do something for Linuxelse() message(FATAL_ERROR &quot;Unsupported system: $&#123;CMAKE_SYSTEM_NAME&#125;&quot;)endif() 循环语句cmake中循环语句包含while，foreach&#x2F;endforeach 函数和宏定义cmake中使用function来定义函数，使用macro来定义宏。函数和宏都可以用来封装一些操作或者功能，并且在需要的时候调用他们。存在以下区别: 参数传递方式不同：函数的参数是以变量的形式传递的，而宏的参数则是以文本替换的方式传递的。 变量作用域不同：函数中定义的变量只能在函数内部使用，而宏中定义的变量则可以在宏的调用位置和宏内部使用。 函数返回值类型只能为字符串：在CMake中，函数的返回值只能是字符串类型，而宏没有返回值。 函数可以使用return命令返回值：函数中可以使用return命令来返回一个字符串值，而宏没有此功能。 宏可以在其调用位置使用命令：宏可以在其调用位置执行一些命令，而函数则不能。 12345678function(func)endfunction()macro(func2)endmacro() 注释在cmake中行注释以 # 字符开始，直到行结束 。块注释以 #[[ 开始 , 以 #]] 结束。 常用内置变量CMAKE_SOURCE_DIR项目源码根目录的绝对路径。 CMAKE_BINARY_DIRCMake生成的Makefile和可执行文件等二进制文件所在目录的绝对路径。 CMAKE_CURRENT_SOURCE_DIR当前处理的CMakeLists.txt所在的目录的绝对路径。 CMAKE_CURRENT_BINARY_DIR当前处理的CMakeLists.txt生成的目标文件所在的目录的绝对路径。 CMAKE_INSTALL_PREFIX安装目录的根目录。 CMAKE_CXX_COMPILERC++编译器的完整路径。 CMAKE_C_COMPILERC编译器的完整路径。 CMAKE_BUILD_TYPE构建类型，通常为Debug或Release。 CMAKE_LIBRARY_OUTPUT_DIRECTORY生成的动态库库文件输出目录。 CMAKE_RUNTIME_OUTPUT_DIRECTORY生成的可执行文件输出目录。 CMAKE_ARCHIVE_OUTPUT_DIRECTORY生成的静态链接库文件的输出目录 CMAKE_MODULE_PATH指定一组目录列表，用于cmake在构建过程中去查找模块或者脚本，这些模块或者脚本可以提供一些常用的功能，用于拓展cmake的功能。 常用命令add_executableadd_executable用来生成一个可执行文件的目标 1add_executable(target_name source_file1 [source_file2 ...]) 其中，target_name是要生成的可执行文件的名称，source_file1、source_file2等是用于生成该可执行文件的源文件。例如，如果我们有两个源文件main.cpp和helper.cpp，并且希望生成一个名为my_program的可执行文件，则可以在CMakeLists.txt文件中使用如下命令： 1add_executable(my_program main.cpp helper.cpp) add_libraryadd_library命令用来创建一个链接库目标。语法格式如下： 1add_library(target_name [STATIC | SHARED | MODULE] source1 [source2 ...]) target_name为要创建的目标的名称。STATIC表示生成静态链接库，SHARED参数表示生成动态链接库，MODULE表示动态加载模块 在C++开发中，我们一般需要告诉编辑器头文件和库文件的搜索路径(1. C&#x2F;C++-&gt;附加包含目录 2. 链接器-&gt;常规-&gt;附加库目录和输入-&gt;附加依赖项)。对应cmake中就是下面这两个命令：[target_]include_directories，[target_]link_directories，注意带target_前缀的添加搜索路径只是针对当前目标库添加，而不带的是全局添加，后面所有库都会附加。 include_directoriesinclude_directories用于向编译器添加一个或多个头文件搜索路径。该命令将指定的路径添加到编译器的搜索路径中，以便编译器可以找到指定路径中的头文件。命令语法如下： 1include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...]) link_directorieslink_directories用于向链接器添加一个或多个库文件搜索路径。该命令将指定的路径添加到链接器的搜索路径中，以便链接器可以找到指定路径中的库文件 add_definitionsadd_definitions用于向编译器添加定义，它可以将一个或者多个定义添加到所有源文件的编译器命令中，影响编译器的行为。 1add_definitions(-DFOO -DBAR ...) 需要注意的是上面三个命令会影响所有的构建项目，包括子项目。如果想要只影响指定的项目，使用target前缀相关的命令。 target_include_directoriestarget_include_directories用于为一个目标添加头文件的搜索路径，可以添加一个或者多个目录，从而使编译器能找到头文件。 123target_include_directories(&lt;target&gt; [SYSTEM] [AFTER|BEFORE] &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...] [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...]) target_link_librariestarget_link_libraries用于为一个目标文件添加链接库。它可以向一个目标文件的链接器命令添加一个或者多个链接库。从而使编译器能够正确的链接到指定库。语法如下： 1234567target_link_libraries(&lt;target&gt; &lt;PRIVATE|PUBLIC|INTERFACE&gt; item1 item2 ... [LINK_PRIVATE|LINK_PUBLIC|LINK_INTERFACE] [LINK_OPTIONS|INTERFACE_LINK_OPTIONS options...] [LINK_LIBRARIES|INTERFACE_LINK_LIBRARIES item1 item2 ...]) target_compile_definitionstarget_compile_definitions用于为一个指定目标文件添加编译器定义。 123456target_compile_definitions(&lt;target&gt; &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...] [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...]) target_compile_definitions(foo PUBLIC -DWIN32)target_compile_definitions(foo PUBLIC -DFOO=1) 以上三个target相关的命令都包含了PRIVATE、PUBLIC、INTERFACE三个不同的访问控制级别。相关含义如下: PRIVATE 表示为当前target设置的头文件路径、链接库和定义只对当前target可见(不具有传染性)。 PUBLIC 表示为当前target设置的相关属性可以被其他引用了该target的其他目标文件可见(具有传染性)。 include用于在CMAKE_MODULE_PATH中加载指定的脚本或者模块文件，语法如下 1include(filename) cmake文件引入成功之后就可以使用文件中定义的函数、变量、宏等 find_package用于在系统中查找已安装的库，并将其导入到CMake项目中。它通常用于在项目中引入第三方库。find_package的语法如下： 1find_package(&lt;package_name&gt; [version] [EXACT] [QUIET] [MODULE] [REQUIRED] [COMPONENTS ...]) 其中，是要查找的库的名称，version指定了所需的版本，EXACT表示查找确切版本，QUIET表示不向用户输出查找过程，MODULE表示只查找CMake模块，REQUIRED表示库是必需的，如果找不到则会出现错误。find_package还可以指定库的组件,通过COMPONENTS选项指定。比如Qt库中就包含组件Core、Gui等。可以按照项目实际需求指定库的组件。当find_package找到库时，会在CMAKE变量中设置一些有用的变量。比如 _FOUND：表示库是否已经找到。 _INCLUDE_DIRS：表示库头文件所在目录的列表。 _LIBRARIES：表示包含的链接库列表1234567find_package(Boost 1.72.0 REQUIRED COMPONENTS filesystem system)if(Boost_FOUND) include_directories($&#123;Boost_INCLUDE_DIRS&#125;) add_executable(myapp main.cpp) target_link_libraries(myapp $&#123;Boost_LIBRARIES&#125;)endif() find_package有两种搜索模式： 模块模式(Module mode)在该模式下，cmake会搜索一个名为Find.cmake的文件。搜索路径的顺序依次是CMAKE_MODULE_PATH指定的目录、cmake安装目录中查找。如果找到了相应的文件，那么就会读取并处理该文件。 配置模式(Config mode)该模式下，CMake会搜索-config.cmake文件或Config.cmake文件，我很少用。 帮助文档与示例上面只是介绍了一些cmake常用、基本的操作。还有很多特性、命令我们都可以通过cmd下cmake --help去查询了解。 最后是一个正式项目的示例：这是一个windows平台的QT项目，通过vscode使用cmake + ninja + msvc构建、编译。 注：ninja与msvc(window平台编译器)关系类似make与gcc，前者是项目构建工具，后者是源码编译器。可以简单这么理解这个流程，cmake通过解析CMakeLists.txt构建工程，而解析操作则是由ninja完成的，最终编译代码则是用msvc完成。 ninja是谷歌的一个高效的构建工具，一般比vsstudio的快不少。 vscode环境搭建步骤： 安装QT4.8.7、vs2010、cmake(3.24.1)、vscode的cmake插件。 配置示例工程根目录的ninja到环境变量。 Ctrl+Shift+p依次执行命令： a. CMake:Configure，只需要执行一次，第一次会提示选择编译器(VisualStudio.10.0-x86)。 b. Cmake:Build，如果修改了代码重新Build不生效，可以先CMake:Clean，再CMake:Build。 c. 编译完就可以F5调试运行了。 示例下载","categories":[{"name":"notes","slug":"notes","permalink":"https://cxx001.gitee.io/categories/notes/"}],"tags":[{"name":"cmake","slug":"cmake","permalink":"https://cxx001.gitee.io/tags/cmake/"},{"name":"CMakeLists.txt","slug":"CMakeLists-txt","permalink":"https://cxx001.gitee.io/tags/CMakeLists-txt/"}],"keywords":[{"name":"notes","slug":"notes","permalink":"https://cxx001.gitee.io/categories/notes/"}]},{"title":"threejs物理效果和声音","slug":"threejs/threejs物理效果和声音","date":"2023-03-08T08:28:15.000Z","updated":"2023-03-14T05:43:44.390Z","comments":true,"path":"2023/03/08/threejs/threejs物理效果和声音/","link":"","permalink":"https://cxx001.gitee.io/2023/03/08/threejs/threejs%E7%89%A9%E7%90%86%E6%95%88%E6%9E%9C%E5%92%8C%E5%A3%B0%E9%9F%B3/","excerpt":"","text":"一、Threejs中如何创建物理场景threejs中创建物理场景我们用它的扩展库：Physijs。它可以使场景中的对象有重力效果，可以相互碰撞，施加力之后可以移动，还可以通过合页和滑块在移动过程中在对象上施加约束。这个库是基于另一个著名物理引擎ammo.js实现的，它只是为了适配threejs对其包装了一层，因此Physijs只是一个包装器，所以它也可以与其它的物理引擎一起工作，在它的github代码仓中你也可以发现一个使用不同的物理引擎Cannon.js的分支版本。 创建物理场景步骤： 配置物理引擎，指定工作线程和使用的物理引擎。 创建物理场景并设置重力。 创建物理场景里的对象(使用Physijs包装的各种网格对象创建)。 执行物理场景。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173&lt;!-- chapter-12-01.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125;&lt;/style&gt;&lt;head&gt; &lt;title&gt;Physijs&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/physi.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/chroma.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; &#x27;use strict&#x27;; var scale = chroma.scale([&#x27;green&#x27;, &#x27;white&#x27;]); // 指定的颜色之间创建色阶 // 1. 配置物理引擎 Physijs.scripts.worker = &#x27;../libs/physijs_worker.js&#x27;; // 指定后台worker线程,做CPU密集的物理计算，为了不卡主渲染线程。 Physijs.scripts.ammo = &#x27;../libs/ammo.js&#x27;; // 指定使用的物理引擎 var initScene, render, applyForce, setMousePosition, mouse_position, ground_material, box_material, renderer, render_stats, scene, ground, light, camera, box, boxes = []; initScene = function () &#123; renderer = new THREE.WebGLRenderer(&#123;antialias: true&#125;); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setClearColor(new THREE.Color(0x000000)); document.getElementById(&#x27;viewport&#x27;).appendChild(renderer.domElement); render_stats = new Stats(); render_stats.domElement.style.position = &#x27;absolute&#x27;; render_stats.domElement.style.top = &#x27;1px&#x27;; render_stats.domElement.style.zIndex = 100; document.getElementById(&#x27;viewport&#x27;).appendChild(render_stats.domElement); // 2. 创建物理场景并设置重力 scene = new Physijs.Scene; scene.setGravity(new THREE.Vector3(0, -50, 0)); camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 1000 ); camera.position.set(50, 30, 50); camera.lookAt(new THREE.Vector3(10, 0, 10)); scene.add(camera); light = new THREE.SpotLight(0xFFFFFF); light.position.set(20, 100, 50); scene.add(light); // 3. 创建物理场景里的对象 createGround(); requestAnimationFrame(render); var points = getPoints(); var stones = []; var controls = new function () &#123; this.gravityX = 0; this.gravityY = -50; this.gravityZ = 0; this.resetScene = function () &#123; scene.setGravity(new THREE.Vector3(controls.gravityX, controls.gravityY, controls.gravityZ)); stones.forEach(function (st) &#123; scene.remove(st) &#125;); stones = []; points.forEach(function (point) &#123; var stoneGeom = new THREE.BoxGeometry(0.6, 6, 2); var stone = new Physijs.BoxMesh(stoneGeom, Physijs.createMaterial(new THREE.MeshPhongMaterial( &#123; color: scale(Math.random()).hex(), transparent: true, opacity: 0.8, &#125;))); console.log(stone.position); stone.position.copy(point); stone.lookAt(scene.position); // 设置骨牌的朝向 stone.__dirtyRotation = true; // 告诉Physijs，骨牌对象的角度更新了 stone.position.y = 3.5; scene.add(stone); stones.push(stone); &#125;); // 推倒第一块骨牌 stones[0].rotation.x = 0.2; stones[0].__dirtyRotation = true; &#125;; &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;gravityX&#x27;, -100, 100); gui.add(controls, &#x27;gravityY&#x27;, -100, 100); gui.add(controls, &#x27;gravityZ&#x27;, -100, 100); gui.add(controls, &#x27;resetScene&#x27;); controls.resetScene(); &#125;; render = function () &#123; requestAnimationFrame(render); renderer.render(scene, camera); render_stats.update(); // 4. 执行物理场景 scene.simulate(); &#125;; // 得到骨牌的位置点 function getPoints() &#123; var points = []; var r = 27; var cX = 0; var cY = 0; var circleOffset = 0; for (var i = 0; i &lt; 1000; i += 6 + circleOffset) &#123; circleOffset = 4.5 * (i / 360); var x = (r / 1440) * (1440 - i) * Math.cos(i * (Math.PI / 180)) + cX; var z = (r / 1440) * (1440 - i) * Math.sin(i * (Math.PI / 180)) + cY; var y = 0; points.push(new THREE.Vector3(x, y, z)); &#125; return points; &#125; // 5个物理网格盒子拼起来的地面 function createGround() &#123; var ground_material = Physijs.createMaterial( new THREE.MeshPhongMaterial(&#123;map: THREE.ImageUtils.loadTexture(&#x27;../assets/textures/general/wood-2.jpg&#x27;)&#125;), .9, .3); var ground = new Physijs.BoxMesh(new THREE.BoxGeometry(60, 1, 60), ground_material, 0); // 最后一个参数是重力，设置为0，是不然地面受重力影响下落。 var borderLeft = new Physijs.BoxMesh(new THREE.BoxGeometry(2, 3, 60), ground_material, 0); borderLeft.position.x = -31; borderLeft.position.y = 2; ground.add(borderLeft); var borderRight = new Physijs.BoxMesh(new THREE.BoxGeometry(2, 3, 60), ground_material, 0); borderRight.position.x = 31; borderRight.position.y = 2; ground.add(borderRight); var borderBottom = new Physijs.BoxMesh(new THREE.BoxGeometry(64, 3, 2), ground_material, 0); borderBottom.position.z = 30; borderBottom.position.y = 2; ground.add(borderBottom); var borderTop = new Physijs.BoxMesh(new THREE.BoxGeometry(64, 3, 2), ground_material, 0); borderTop.position.z = -30; borderTop.position.y = 2; ground.add(borderTop); scene.add(ground); &#125; window.onload = initScene; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;viewport&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 二、Physijs提供的包装几何体对象物理场景中添加网格对象，就是把THREE.Mesh换成Physijs.xxx包装的几何体网格，这样对象就会受物理的影响了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255&lt;!-- chapter-12-02.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; background-color: #000000; &#125; &lt;/style&gt; &lt;title&gt;Physijs shapes&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/physi.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/chroma.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/perlin.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; &#x27;use strict&#x27;; Physijs.scripts.worker = &#x27;../libs/physijs_worker.js&#x27;; Physijs.scripts.ammo = &#x27;../libs/ammo.js&#x27;; var scale = chroma.scale([&#x27;blue&#x27;, &#x27;white&#x27;]); var initScene, render, applyForce, setMousePosition, mouse_position, ground_material, box_material, projector, renderer, render_stats, physics_stats, scene, ground, light, camera, box, boxes = []; initScene = function () &#123; renderer = new THREE.WebGLRenderer(&#123;antialias: true&#125;); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setClearColor(new THREE.Color(0x000000)); renderer.shadowMapEnabled = true; document.getElementById(&#x27;viewport&#x27;).appendChild(renderer.domElement); render_stats = new Stats(); render_stats.domElement.style.position = &#x27;absolute&#x27;; render_stats.domElement.style.top = &#x27;1px&#x27;; render_stats.domElement.style.left = &#x27;1px&#x27;; render_stats.domElement.style.zIndex = 100; document.getElementById(&#x27;viewport&#x27;).appendChild(render_stats.domElement); scene = new Physijs.Scene(&#123;reportSize: 10, fixedTimeStep: 1 / 60&#125;); scene.setGravity(new THREE.Vector3(0, -20, 0)); camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 1000 ); camera.position.set(105, 85, 85); camera.lookAt(new THREE.Vector3(0, 0, 0)); scene.add(camera); var ambi = new THREE.AmbientLight(0x222222); scene.add(ambi); light = new THREE.SpotLight(0xFFFFFF); light.position.set(40, 50, 100); light.castShadow = true; light.shadowMapDebug = true; light.shadowCameraNear = 10; light.shadowCameraFar = 200; light.intensity = 1.5; scene.add(light); // 添加物理对象 var meshes = []; var controls = new function () &#123; // 添加包装的球体几何体 this.addSphereMesh = function () &#123; var sphere = new Physijs.SphereMesh( new THREE.SphereGeometry(3, 20), getMaterial() ); setPosAndShade(sphere); meshes.push(sphere); scene.add(sphere); &#125;; // 添加包装的盒子几何体 this.addBoxMesh = function () &#123; var cube = new Physijs.BoxMesh( new THREE.BoxGeometry(4, 2, 6), getMaterial() ); setPosAndShade(cube); meshes.push(cube); scene.add(cube); &#125;; // 添加包装的圆柱几何体 this.addCylinderMesh = function () &#123; var cylinder = new Physijs.CylinderMesh( new THREE.CylinderGeometry(2, 2, 6), getMaterial() ); setPosAndShade(cylinder); meshes.push(cylinder); scene.add(cylinder); &#125;; // 添加包装的圆锥几何体 this.addConeMesh = function () &#123; var cone = new Physijs.ConeMesh( new THREE.CylinderGeometry(0, 3, 7, 20, 10), getMaterial() ); setPosAndShade(cone); meshes.push(cone); scene.add(cone); &#125;; // 添加包装的平面几何体(固定重量为0，不受重力影响) this.addPlaneMesh = function () &#123; var plane = new Physijs.PlaneMesh( new THREE.PlaneGeometry(5, 5, 10, 10), getMaterial() ); setPosAndShade(plane); meshes.push(plane); scene.add(plane); &#125;; // 添加包装的胶囊几何体 this.addCapsuleMesh = function () &#123; var merged = new THREE.Geometry(); var cyl = new THREE.CylinderGeometry(2, 2, 6); var top = new THREE.SphereGeometry(2); var bot = new THREE.SphereGeometry(2); var matrix = new THREE.Matrix4(); matrix.makeTranslation(0, 3, 0); top.applyMatrix(matrix); var matrix = new THREE.Matrix4(); matrix.makeTranslation(0, -3, 0); bot.applyMatrix(matrix); merged.merge(top); merged.merge(bot); merged.merge(cyl); var capsule = new Physijs.CapsuleMesh( merged, getMaterial() ); setPosAndShade(capsule); meshes.push(capsule); scene.add(capsule); &#125;; // 添加包装的复杂图形几何体 this.addConvexMesh = function () &#123; var convex = new Physijs.ConvexMesh( new THREE.TorusKnotGeometry(0.5, 0.3, 64, 8, 2, 3, 10), getMaterial() ); setPosAndShade(convex); meshes.push(convex); scene.add(convex); &#125;; // 清除场景中添加的包装几何体 this.clearMeshes = function () &#123; meshes.forEach(function (e) &#123; scene.remove(e); &#125;); meshes = []; &#125; &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;addPlaneMesh&#x27;); gui.add(controls, &#x27;addBoxMesh&#x27;); gui.add(controls, &#x27;addSphereMesh&#x27;); gui.add(controls, &#x27;addCylinderMesh&#x27;); gui.add(controls, &#x27;addConeMesh&#x27;); gui.add(controls, &#x27;addCapsuleMesh&#x27;); gui.add(controls, &#x27;addConvexMesh&#x27;); gui.add(controls, &#x27;clearMeshes&#x27;); // 创建高度场 var date = new Date(); var pn = new Perlin(&#x27;rnd&#x27; + date.getTime()); // 噪声生成器生成地形 var map = createHeightMap(pn); // 遍历几何体每个顶点，并随机设置顶点的z属性 scene.add(map); requestAnimationFrame(render); scene.simulate(); &#125;; function createHeightMap(pn) &#123; var ground_material = Physijs.createMaterial( new THREE.MeshLambertMaterial( &#123; map: THREE.ImageUtils.loadTexture(&#x27;../assets/textures/ground/grasslight-big.jpg&#x27;) &#125;), .3, // high friction .8 // low restitution ); var ground_geometry = new THREE.PlaneGeometry(120, 100, 100, 100); for (var i = 0; i &lt; ground_geometry.vertices.length; i++) &#123; var vertex = ground_geometry.vertices[i]; var value = pn.noise(vertex.x / 10, vertex.y / 10, 0); vertex.z = value * 10; &#125; ground_geometry.computeFaceNormals(); ground_geometry.computeVertexNormals(); var ground = new Physijs.HeightfieldMesh( ground_geometry, ground_material, 0, // mass 100, 100 ); ground.rotation.x = Math.PI / -2; ground.rotation.y = 0.4; ground.receiveShadow = true; return ground; &#125; function setPosAndShade(obj) &#123; obj.position.set( Math.random() * 20 - 45, 40, Math.random() * 20 - 5 ); obj.rotation.set(Math.random() * 2 * Math.PI, Math.random() * 2 * Math.PI, Math.random() * 2 * Math.PI); obj.castShadow = true; &#125; function getMaterial() &#123; var material = Physijs.createMaterial( new THREE.MeshLambertMaterial( &#123; color: scale(Math.random()).hex(), &#125;), 0.5, 0.7); return material; &#125; render = function () &#123; requestAnimationFrame(render); renderer.render(scene, camera); render_stats.update(); scene.simulate(); &#125;; window.onload = initScene; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;viewport&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 三、Physijs使用约束限制对象的移动Physijs提供的约束对象如下： 前面4个约束示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; body &#123; /* set margin to 0 and overflow to hidden, to go fullscreen */ margin: 0; overflow: hidden; background-color: #000000; &#125; &lt;/style&gt; &lt;title&gt;Physijs Constraints&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/physi.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/chroma.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; &#x27;use strict&#x27;; Physijs.scripts.worker = &#x27;../libs/physijs_worker.js&#x27;; Physijs.scripts.ammo = &#x27;../libs/ammo.js&#x27;; var scale = chroma.scale([&#x27;white&#x27;, &#x27;blue&#x27;, &#x27;red&#x27;, &#x27;yellow&#x27;]); var initScene, render, applyForce, setMousePosition, mouse_position, ground_material, box_material, projector, renderer, render_stats, physics_stats, scene, ground, light, camera, box, boxes = []; initScene = function () &#123; projector = new THREE.Projector; renderer = new THREE.WebGLRenderer(&#123;antialias: true&#125;); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setClearColor(new THREE.Color(0x000000)); renderer.shadowMapEnabled = true; document.getElementById(&#x27;viewport&#x27;).appendChild(renderer.domElement); render_stats = new Stats(); render_stats.domElement.style.position = &#x27;absolute&#x27;; render_stats.domElement.style.top = &#x27;1px&#x27;; render_stats.domElement.style.right = &#x27;1px&#x27;; render_stats.domElement.style.zIndex = 100; document.getElementById(&#x27;viewport&#x27;).appendChild(render_stats.domElement); scene = new Physijs.Scene(&#123;reportSize: 10, fixedTimeStep: 1 / 60&#125;); scene.setGravity(new THREE.Vector3(0, -10, 0)); camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 1000 ); camera.position.set(85, 65, 65); camera.lookAt(new THREE.Vector3(0, 0, 0)); scene.add(camera); // Light light = new THREE.SpotLight(0xFFFFFF); light.position.set(20, 50, 50); light.castShadow = true; light.shadowMapDebug = true; light.shadowCameraNear = 10; light.shadowCameraFar = 100; scene.add(light); var meshes = []; createGround(); var flipperLeftConstraint = createLeftFlipper(); var flipperRightConstraint = createRightFlipper(); var sliderBottomConstraint = createSliderBottom(); var sliderTopConstraint = createSliderTop(); var coneTwistConstraint = createConeTwist(); var point2point = createPointToPoint(true); var controls = new function () &#123; this.enableMotor = false; this.acceleration = 2; this.velocity = -10; this.enableConeTwistMotor = false; this.motorTargetX = 0; this.motorTargetY = 0; this.motorTargetZ = 0; this.updateCone = function () &#123; if (controls.enableConeTwistMotor) &#123; coneTwistConstraint.enableMotor(); coneTwistConstraint.setMotorTarget(new THREE.Vector3(controls.motorTargetX, controls.motorTargetY, controls.motorTargetZ)); &#125; else &#123; coneTwistConstraint.disableMotor(); &#125; &#125;; this.updateMotor = function () &#123; if (controls.enableMotor) &#123; // velocity is the velocity we are going for. // acceleration is how fast we&#x27;re going to reach it flipperLeftConstraint.disableMotor(); flipperLeftConstraint.enableAngularMotor(controls.velocity, controls.acceleration); flipperRightConstraint.disableMotor(); flipperRightConstraint.enableAngularMotor(-1 * controls.velocity, controls.acceleration); &#125; else &#123; flipperLeftConstraint.disableMotor(); flipperRightConstraint.disableMotor(); &#125; &#125;; this.sliderLeft = function () &#123; sliderBottomConstraint.disableLinearMotor(); sliderBottomConstraint.enableLinearMotor(controls.velocity, controls.acceleration); sliderTopConstraint.disableLinearMotor(); sliderTopConstraint.enableLinearMotor(controls.velocity, controls.acceleration); &#125;; this.sliderRight = function () &#123; sliderBottomConstraint.disableLinearMotor(); sliderBottomConstraint.enableLinearMotor(-1 * controls.velocity, controls.acceleration); sliderTopConstraint.disableLinearMotor(); sliderTopConstraint.enableLinearMotor(-1 * controls.velocity, controls.acceleration); &#125;; this.clearMeshes = function () &#123; meshes.forEach(function (e) &#123; scene.remove(e); &#125;); meshes = []; &#125;; this.addSpheres = function () &#123; var colorSphere = scale(Math.random()).hex(); for (var i = 0; i &lt; 5; i++) &#123; box = new Physijs.SphereMesh( new THREE.SphereGeometry(2, 20), Physijs.createMaterial( new THREE.MeshPhongMaterial( &#123; color: colorSphere, opacity: 0.8, transparent: true// map: THREE.ImageUtils.loadTexture( &#x27;../assets/textures/general/floor-wood.jpg&#x27; ) &#125;), controls.sphereFriction, controls.sphereRestitution ) , 0.1); box.castShadow = true; box.receiveShadow = true; box.position.set( Math.random() * 50 - 25, 20 + Math.random() * 5, Math.random() * 5 ); meshes.push(box); scene.add(box); &#125; &#125;; &#125;; controls.updateMotor(); var gui = new dat.GUI(); gui.domElement.style.position = &#x27;absolute&#x27;; gui.domElement.style.top = &#x27;20px&#x27;; gui.domElement.style.left = &#x27;20px&#x27;; var generalFolder = gui.addFolder(&#x27;general&#x27;); generalFolder.add(controls, &quot;acceleration&quot;, 0, 15).onChange(controls.updateMotor); generalFolder.add(controls, &quot;velocity&quot;, -10, 10).onChange(controls.updateMotor); var hingeFolder = gui.addFolder(&#x27;hinge&#x27;); hingeFolder.add(controls, &quot;enableMotor&quot;).onChange(controls.updateMotor); var sliderFolder = gui.addFolder(&#x27;sliders&#x27;); sliderFolder.add(controls, &quot;sliderLeft&quot;).onChange(controls.sliderLeft); sliderFolder.add(controls, &quot;sliderRight&quot;).onChange(controls.sliderRight); var coneTwistFolder = gui.addFolder(&#x27;coneTwist&#x27;); coneTwistFolder.add(controls, &quot;enableConeTwistMotor&quot;).onChange(controls.updateCone); coneTwistFolder.add(controls, &quot;motorTargetX&quot;, -Math.PI / 2, Math.PI / 2).onChange(controls.updateCone); coneTwistFolder.add(controls, &quot;motorTargetY&quot;, -Math.PI / 2, Math.PI / 2).onChange(controls.updateCone); coneTwistFolder.add(controls, &quot;motorTargetZ&quot;, -Math.PI / 2, Math.PI / 2).onChange(controls.updateCone); var spheresFolder = gui.addFolder(&#x27;spheres&#x27;); spheresFolder.add(controls, &quot;clearMeshes&quot;).onChange(controls.updateMotor); spheresFolder.add(controls, &quot;addSpheres&quot;).onChange(controls.updateMotor); requestAnimationFrame(render); scene.simulate(); &#125;; function createGround() &#123; // Materials ground_material = Physijs.createMaterial( new THREE.MeshPhongMaterial( &#123;// color: 0xaaaaaa, map: THREE.ImageUtils.loadTexture(&#x27;../assets/textures/general/floor-wood.jpg&#x27;) &#125;), .9, // high friction .7 // low restitution ); // Ground ground = new Physijs.BoxMesh( new THREE.BoxGeometry(60, 1, 65), ground_material, 0 // mass ); ground.receiveShadow = true; var borderLeft = new Physijs.BoxMesh( new THREE.BoxGeometry(2, 6, 65), ground_material, 0 // mass ); borderLeft.position.x = -31; borderLeft.position.y = 2; borderLeft.receiveShadow = true; ground.add(borderLeft); var borderRight = new Physijs.BoxMesh(new THREE.BoxGeometry(2, 6, 65), ground_material, 0 // mass ); borderRight.position.x = 31; borderRight.position.y = 2; borderRight.receiveShadow = true; ground.add(borderRight); var borderBottom = new Physijs.BoxMesh( new THREE.BoxGeometry(64, 6, 2), ground_material, 0 // mass ); borderBottom.position.z = 32; borderBottom.position.y = 1.5; borderBottom.receiveShadow = true; ground.add(borderBottom); var borderTop = new Physijs.BoxMesh( new THREE.BoxGeometry(64, 6, 2), ground_material, 0 // mass ); borderTop.position.z = -32; borderTop.position.y = 2; borderTop.receiveShadow = true; ground.add(borderTop); ground.receiveShadow = true; scene.add(ground); &#125; function createConeTwist() &#123; var baseMesh = new THREE.SphereGeometry(1); var armMesh = new THREE.BoxGeometry(2, 12, 3); var objectOne = new Physijs.BoxMesh(baseMesh, Physijs.createMaterial( new THREE.MeshPhongMaterial(&#123;color: 0x4444ff, transparent: true, opacity: 0.7&#125;), 0, 0), 0); objectOne.position.z = 0; objectOne.position.x = 20; objectOne.position.y = 15.5; objectOne.castShadow = true; scene.add(objectOne); var objectTwo = new Physijs.SphereMesh(armMesh, Physijs.createMaterial( new THREE.MeshPhongMaterial(&#123;color: 0x4444ff, transparent: true, opacity: 0.7&#125;), 0, 0), 10); objectTwo.position.z = 0; objectTwo.position.x = 20; objectTwo.position.y = 7.5; scene.add(objectTwo); objectTwo.castShadow = true; //position is the position of the axis, relative to the ref, based on the current position var constraint = new Physijs.ConeTwistConstraint(objectOne, objectTwo, objectOne.position); scene.addConstraint(constraint); // set limit to quarter circle for each axis constraint.setLimit(0.5 * Math.PI, 0.5 * Math.PI, 0.5 * Math.PI); constraint.setMaxMotorImpulse(1); constraint.setMotorTarget(new THREE.Vector3(0, 0, 0)); // desired rotation return constraint; &#125; function createPointToPoint() &#123; var obj1 = new THREE.SphereGeometry(2); var obj2 = new THREE.SphereGeometry(2); var objectOne = new Physijs.SphereMesh(obj1, Physijs.createMaterial( new THREE.MeshPhongMaterial(&#123;color: 0xff4444, transparent: true, opacity: 0.7&#125;), 0, 0)); objectOne.position.z = -18; objectOne.position.x = -10; objectOne.position.y = 2; objectOne.castShadow = true; scene.add(objectOne); var objectTwo = new Physijs.SphereMesh(obj2, Physijs.createMaterial( new THREE.MeshPhongMaterial(&#123;color: 0xff4444, transparent: true, opacity: 0.7&#125;), 0, 0)); objectTwo.position.z = -5; objectTwo.position.x = -20; objectTwo.position.y = 2; objectTwo.castShadow = true; scene.add(objectTwo); // if no position two, its fixed to a position. Else fixed to objectTwo and both will move var constraint = new Physijs.PointConstraint(objectOne, objectTwo, objectTwo.position); scene.addConstraint(constraint); &#125; function createSliderBottom() &#123; var sliderCube = new THREE.BoxGeometry(12, 2, 2); var sliderMesh = new Physijs.BoxMesh(sliderCube, Physijs.createMaterial( new THREE.MeshPhongMaterial(&#123;color: 0x44ff44, opacity: 0.6, transparent: true&#125;), 0, 0), 0.01); sliderMesh.position.z = 20; sliderMesh.position.x = 6; sliderMesh.position.y = 1.5; sliderMesh.castShadow = true; scene.add(sliderMesh); var constraint = new Physijs.SliderConstraint(sliderMesh, new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0)); scene.addConstraint(constraint); constraint.setLimits(-10, 10, 0, 0); constraint.setRestitution(0.1, 0.1); return constraint; &#125; function createSliderTop() &#123; var sliderSphere = new THREE.BoxGeometry(7, 2, 7); var sliderMesh = new Physijs.BoxMesh(sliderSphere, Physijs.createMaterial( new THREE.MeshPhongMaterial(&#123;color: 0x44ff44, transparent: true, opacity: 0.5&#125;), 0, 0), 10); sliderMesh.position.z = -15; sliderMesh.position.x = -20; sliderMesh.position.y = 1.5; scene.add(sliderMesh); sliderMesh.castShadow = true; //position is the position of the axis, relative to the ref, based on the current position var constraint = new Physijs.SliderConstraint(sliderMesh, new THREE.Vector3(-10, 0, 20), new THREE.Vector3(Math.PI / 2, 0, 0)); scene.addConstraint(constraint); constraint.setLimits(-20, 10, 0.5, -0, 5); constraint.setRestitution(0.2, 0.1); return constraint; &#125; function createLeftFlipper() &#123; var flipperLeft = new Physijs.BoxMesh( new THREE.BoxGeometry(12, 2, 2), Physijs.createMaterial(new THREE.MeshPhongMaterial( &#123;opacity: 0.6, transparent: true&#125; )), 0.3 ); flipperLeft.position.x = -6; flipperLeft.position.y = 2; flipperLeft.position.z = 0; flipperLeft.castShadow = true; scene.add(flipperLeft); var flipperLeftPivot = new Physijs.SphereMesh( new THREE.BoxGeometry(1, 1, 1), ground_material, 0); flipperLeftPivot.position.y = 1; flipperLeftPivot.position.x = -15; flipperLeftPivot.position.z = 0; flipperLeftPivot.rotation.y = 1.4; flipperLeftPivot.castShadow = true; scene.add(flipperLeftPivot); // when looking at the axis, the axis of object two are used. // so as long as that one is the same as the scene, no problems // rotation and axis are relative to object2. If position == cube2.position it works as expected var constraint = new Physijs.HingeConstraint(flipperLeft, flipperLeftPivot, flipperLeftPivot.position, new THREE.Vector3(0, 1, 0)); scene.addConstraint(constraint); constraint.setLimits( -2.2, // minimum angle of motion, in radians, from the point object 1 starts (going back) -0.6, // maximum angle of motion, in radians, from the point object 1 starts (going forward) 0.1, // applied as a factor to constraint error, how big the kantelpunt is moved when a constraint is hit 0 // controls bounce at limit (0.0 == no bounce) ); return constraint; &#125; function createRightFlipper() &#123; var flipperright = new Physijs.BoxMesh( new THREE.BoxGeometry(12, 2, 2), Physijs.createMaterial(new THREE.MeshPhongMaterial( &#123;opacity: 0.6, transparent: true&#125; )), 0.3 ); flipperright.position.x = 8; flipperright.position.y = 2; flipperright.position.z = 0; flipperright.castShadow = true; scene.add(flipperright); var flipperLeftPivot = new Physijs.SphereMesh( new THREE.BoxGeometry(1, 1, 1), ground_material, 0); flipperLeftPivot.position.y = 2; flipperLeftPivot.position.x = 15; flipperLeftPivot.position.z = 0; flipperLeftPivot.rotation.y = 1.4; flipperLeftPivot.castShadow = true; scene.add(flipperLeftPivot); // when looking at the axis, the axis of object two are used. // so as long as that one is the same as the scene, no problems // rotation and axis are relative to object2. If position == cube2.position it works as expected var constraint = new Physijs.HingeConstraint(flipperright, flipperLeftPivot, flipperLeftPivot.position, new THREE.Vector3(0, 1, 0));// var constraint = new Physijs.HingeConstraint(cube1, new THREE.Vector3(0,0,0), new THREE.Vector3(0,1,0)); scene.addConstraint(constraint); constraint.setLimits( -2.2, // minimum angle of motion, in radians, from the point object 1 starts (going back) -0.6, // maximum angle of motion, in radians, from the point object 1 starts (going forward) 0.1, // applied as a factor to constraint error, how big the kantelpunt is moved when a constraint is hit 0 // controls bounce at limit (0.0 == no bounce) ); return constraint; &#125; var direction = 1; render = function () &#123; requestAnimationFrame(render); renderer.render(scene, camera); render_stats.update(); ground.__dirtyRotation = true; scene.simulate(undefined, 2); &#125;; window.onload = initScene; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;viewport&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 最后一个DOFConstraint约束示例(可以准确的控制对象的线性方向和角度方向的移动)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; body &#123; /* set margin to 0 and overflow to hidden, to go fullscreen */ margin: 0; overflow: hidden; background-color: #000000; &#125; &lt;/style&gt; &lt;title&gt;Physijs Constraints&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/physi.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/chroma.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; &#x27;use strict&#x27;; Physijs.scripts.worker = &#x27;../libs/physijs_worker.js&#x27;; Physijs.scripts.ammo = &#x27;../libs/ammo.js&#x27;; var scale = chroma.scale([&#x27;white&#x27;, &#x27;blue&#x27;, &#x27;red&#x27;, &#x27;yellow&#x27;]); var initScene, render, applyForce, setMousePosition, mouse_position, ground_material, box_material, projector, renderer, render_stats, physics_stats, scene, ground, light, camera, box, boxes = []; initScene = function () &#123; renderer = new THREE.WebGLRenderer(&#123;antialias: true&#125;); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setClearColor(new THREE.Color(0x000000)); renderer.shadowMapEnabled = true; document.getElementById(&#x27;viewport&#x27;).appendChild(renderer.domElement); render_stats = new Stats(); render_stats.domElement.style.position = &#x27;absolute&#x27;; render_stats.domElement.style.top = &#x27;1px&#x27;; render_stats.domElement.style.left = &#x27;1px&#x27;; render_stats.domElement.style.zIndex = 100; document.getElementById(&#x27;viewport&#x27;).appendChild(render_stats.domElement); scene = new Physijs.Scene(&#123;reportSize: 10, fixedTimeStep: 1 / 60&#125;); scene.setGravity(new THREE.Vector3(0, -40, 0)); camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 1000 ); camera.position.set(90, 90, 90); camera.lookAt(new THREE.Vector3(30, 0, -20)); scene.add(camera); // Light light = new THREE.SpotLight(0xFFFFFF); light.position.set(120, 70, 100); light.castShadow = true; light.shadowMapDebug = true; light.shadowCameraNear = 10; light.shadowCameraFar = 200; scene.add(light); var meshes = []; createGround(); var car = createCar(); var controls = new function () &#123; this.velocity = -2; this.wheelAngle = 0.5; this.loosenXRight = 0.0001; this.loosenXLeft = 0.0001; this.changeVelocity = function () &#123; // if you add a motor, the current constraint is overridden // if you want to rotate set min higher then max car.flConstraint.configureAngularMotor(2, 0.1, 0, controls.velocity, 15000); car.frConstraint.configureAngularMotor(2, 0.1, 0, controls.velocity, 15000); // motor one is for left and right// frConstraint.enableAngularMotor(1); // motor two is forward and backwards car.flConstraint.enableAngularMotor(2); car.frConstraint.enableAngularMotor(2); &#125;; this.changeOrientation = function () &#123; car.rrConstraint.setAngularLowerLimit(&#123;x: 0, y: controls.wheelAngle, z: 0.1&#125;); car.rrConstraint.setAngularUpperLimit(&#123;x: controls.loosenXRight, y: controls.wheelAngle, z: 0&#125;); car.rlConstraint.setAngularLowerLimit(&#123;x: controls.loosenXLeft, y: controls.wheelAngle, z: 0.1&#125;); car.rlConstraint.setAngularUpperLimit(&#123;x: 0, y: controls.wheelAngle, z: 0&#125;); &#125; &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;velocity&#x27;, -10, 10).onChange(controls.changeVelocity); gui.add(controls, &#x27;wheelAngle&#x27;, -1, 1).onChange(controls.changeOrientation); gui.add(controls, &#x27;loosenXRight&#x27;, 0, 0.5).step(0.01).onChange(controls.changeOrientation); gui.add(controls, &#x27;loosenXLeft&#x27;, 0, 0.6).step(-0.01).onChange(controls.changeOrientation); controls.loosenXLeft = 0; controls.loosenXRight = 0; requestAnimationFrame(render); scene.simulate(); &#125;; function createWheel(position) &#123; var wheel_material = Physijs.createMaterial( new THREE.MeshLambertMaterial(&#123;color: 0x444444, opacity: 0.9, transparent: true&#125;), 1.0, // high friction .5 // medium restitution ); var wheel_geometry = new THREE.CylinderGeometry(4, 4, 2, 10); var wheel = new Physijs.CylinderMesh( wheel_geometry, wheel_material, 100 ); wheel.rotation.x = Math.PI / 2; wheel.castShadow = true; wheel.position.copy(position); return wheel; &#125; function createCar() &#123; var car = &#123;&#125;; var car_material = Physijs.createMaterial( new THREE.MeshLambertMaterial(&#123;color: 0xff4444, opacity: 0.9, transparent: true&#125;), .5, // high friction .5 // medium restitution ); // create the car body var geom = new THREE.BoxGeometry(15, 4, 4); var body = new Physijs.BoxMesh(geom, car_material, 500); body.position.set(5, 5, 5); body.castShadow = true; scene.add(body); // create the wheels var fr = createWheel(new THREE.Vector3(0, 4, 10)); var fl = createWheel(new THREE.Vector3(0, 4, 0)); var rr = createWheel(new THREE.Vector3(10, 4, 10)); var rl = createWheel(new THREE.Vector3(10, 4, 0)); // add the wheels to the scene scene.add(fr); scene.add(fl); scene.add(rr); scene.add(rl); var frConstraint = createWheelConstraint(fr, body, new THREE.Vector3(0, 4, 8)); scene.addConstraint(frConstraint); var flConstraint = createWheelConstraint(fl, body, new THREE.Vector3(0, 4, 2)); scene.addConstraint(flConstraint); var rrConstraint = createWheelConstraint(rr, body, new THREE.Vector3(10, 4, 8)); scene.addConstraint(rrConstraint); var rlConstraint = createWheelConstraint(rl, body, new THREE.Vector3(10, 4, 2)); scene.addConstraint(rlConstraint); // backwheels don&#x27;t move themselves and are restriced in their // movement. They should be able to rotate along the z-axis // same here, if the complete angle is allowed set lower higher // than upper. // by setting the lower and upper to the same value you can // fix the position // we can set the x position to &#x27;loosen&#x27; the axis for the directional rrConstraint.setAngularLowerLimit(&#123;x: 0, y: 0.5, z: 0.1&#125;); rrConstraint.setAngularUpperLimit(&#123;x: 0, y: 0.5, z: 0&#125;); rlConstraint.setAngularLowerLimit(&#123;x: 0, y: 0.5, z: 0.1&#125;); rlConstraint.setAngularUpperLimit(&#123;x: 0, y: 0.5, z: 0&#125;); // front wheels should only move along the z axis. // we don&#x27;t need to specify anything here, since // that value is overridden by the motors frConstraint.setAngularLowerLimit(&#123;x: 0, y: 0, z: 0&#125;); frConstraint.setAngularUpperLimit(&#123;x: 0, y: 0, z: 0&#125;); flConstraint.setAngularLowerLimit(&#123;x: 0, y: 0, z: 0&#125;); flConstraint.setAngularUpperLimit(&#123;x: 0, y: 0, z: 0&#125;); // if you add a motor, the current constraint is overridden // if you want to rotate set min higher then max flConstraint.configureAngularMotor(2, 0.1, 0, -2, 1500); frConstraint.configureAngularMotor(2, 0.1, 0, -2, 1500); // motor one is for left and right// frConstraint.enableAngularMotor(1); // motor two is forward and backwards flConstraint.enableAngularMotor(2); frConstraint.enableAngularMotor(2); car.flConstraint = flConstraint; car.frConstraint = frConstraint; car.rlConstraint = rlConstraint; car.rrConstraint = rrConstraint; return car; &#125; function createWheelConstraint(wheel, body, position) &#123; var constraint = new Physijs.DOFConstraint( wheel, body, position); return constraint; &#125; function createGround() &#123; var length = 120; var width = 120; // Materials ground_material = Physijs.createMaterial( new THREE.MeshPhongMaterial( &#123;// color: 0xaaaaaa, map: THREE.ImageUtils.loadTexture(&#x27;../assets/textures/general/floor-wood.jpg&#x27;) &#125;), 1, // high friction .7 // low restitution ); // Ground ground = new Physijs.BoxMesh( new THREE.BoxGeometry(length, 1, width), ground_material, 0 // mass ); ground.receiveShadow = true; var borderLeft = new Physijs.BoxMesh( new THREE.BoxGeometry(2, 6, width), ground_material, 0 // mass ); borderLeft.position.x = -1 * length / 2 - 1; borderLeft.position.y = 2; borderLeft.receiveShadow = true; ground.add(borderLeft); var borderRight = new Physijs.BoxMesh(new THREE.BoxGeometry(2, 6, width), ground_material, 0 // mass ); borderRight.position.x = length / 2 + 1; borderRight.position.y = 2; borderRight.receiveShadow = true; ground.add(borderRight); var borderBottom = new Physijs.BoxMesh( new THREE.BoxGeometry(width - 1, 6, 2), ground_material, 0 // mass ); borderBottom.position.z = width / 2; borderBottom.position.y = 1.5; borderBottom.receiveShadow = true; ground.add(borderBottom); var borderTop = new Physijs.BoxMesh( new THREE.BoxGeometry(width, 6, 2), ground_material, 0 // mass ); borderTop.position.z = -width / 2; borderTop.position.y = 2; borderTop.receiveShadow = true; ground.position.x = 20; ground.position.z = -20; ground.add(borderTop); ground.receiveShadow = true; scene.add(ground); &#125; render = function () &#123; requestAnimationFrame(render); renderer.render(scene, camera); render_stats.update(); scene.simulate(undefined, 2); &#125;; window.onload = initScene; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;viewport&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 四、在场景中添加声源Threejs中声音很有意思，因为它会受到摄像机距离的影响： 声源离摄像机的距离决定着声音的大小 摄像机左右侧的位置分别决定着左右侧扬声器声音的大小。 下面示例展示了一个第一人视角，你会发现离哪个方块近，哪个动物的声音就会大。如果将摄像机放在狗和牛之间，你会听到牛的声音来自右侧，狗的声音来自左侧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108function init() &#123; var stats = initStats(); var renderer = initRenderer(); var camera = initCamera(new THREE.Vector3(10, 10, 10)); var clock = new THREE.Clock(); scene = new THREE.Scene(); initDefaultLighting(scene); camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000); camera.position.set(-200, 25, 0); // 1. 定义声音监听对象，并添加到摄像机 var listener1 = new THREE.AudioListener(); camera.add(listener1); var listener2 = new THREE.AudioListener(); camera.add(listener2); var listener3 = new THREE.AudioListener(); camera.add(listener3); // 第一人称视角 controls = new THREE.FirstPersonControls(camera); controls.movementSpeed = 70; controls.lookSpeed = 0.15; controls.noFly = true; controls.lookVertical = false; scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x000000, 0.0035); light = new THREE.DirectionalLight(0xffffff); light.position.set(0, 0.5, 1).normalize(); scene.add(light); var cube = new THREE.BoxGeometry(40, 40, 40); var material_1 = new THREE.MeshBasicMaterial(&#123; color: 0xffffff, map: THREE.ImageUtils.loadTexture(&quot;../../assets/textures/animals/cow.png&quot;) &#125;); var material_2 = new THREE.MeshBasicMaterial(&#123; color: 0xffffff, map: THREE.ImageUtils.loadTexture(&quot;../../assets/textures/animals/dog.jpg&quot;) &#125;); var material_3 = new THREE.MeshBasicMaterial(&#123; color: 0xffffff, map: THREE.ImageUtils.loadTexture(&quot;../../assets/textures/animals/cat.jpg&quot;) &#125;); var mesh1 = new THREE.Mesh(cube, material_1); mesh1.position.set(0, 20, 100); var mesh2 = new THREE.Mesh(cube, material_2); mesh2.position.set(0, 20, 0); var mesh3 = new THREE.Mesh(cube, material_3); mesh3.position.set(0, 20, -100); scene.add(mesh1); scene.add(mesh2); scene.add(mesh3); // 2. 绑定声音监听对象，并添加到对应的物体上 var posSound1 = new THREE.PositionalAudio( listener1 ); var posSound2 = new THREE.PositionalAudio( listener2 ); var posSound3 = new THREE.PositionalAudio( listener3 ); mesh1.add(posSound1); mesh2.add(posSound2); mesh3.add(posSound3); // 3. 加载声音并设置属性 var audioLoader = new THREE.AudioLoader(); audioLoader.load(&#x27;../../assets/audio/cow.ogg&#x27;, function(buffer) &#123; posSound1.setBuffer( buffer ); posSound1.setRefDistance( 30 ); // 决定距离物体多远时声音开始降低 posSound1.play(); posSound1.setRolloffFactor(10); // 决定远离物体多远时声音开始降低 posSound1.setLoop(true); &#125;); audioLoader.load(&#x27;../../assets/audio/dog.ogg&#x27;, function(buffer) &#123; posSound2.setBuffer( buffer ); posSound2.setRefDistance( 30 ); posSound2.play(); posSound2.setRolloffFactor(10); posSound2.setLoop(true); &#125;); audioLoader.load(&#x27;../../assets/audio/cat.ogg&#x27;, function(buffer) &#123; posSound3.setBuffer( buffer ); posSound3.setRefDistance( 30 ); posSound3.play(); posSound3.setRolloffFactor(10); posSound3.setLoop(true); &#125;); // 辅助对象GridHelper创建网格地面 var helper = new THREE.GridHelper(500, 10); helper.position.y = 0.1; scene.add(helper); animate(); function animate() &#123; requestAnimationFrame(animate); render(); &#125; function render() &#123; var delta = clock.getDelta(), time = clock.getElapsedTime() * 5; controls.update(delta); renderer.render(scene, camera); &#125; &#125; 五、第3版最新案例代码代码是基于Threejs的r95版本，相比本系列教程使用的第二版，在示例代码质量和渲染效果上都有一定提升。 第三版案例代码资源下载","categories":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/categories/threejs/"}],"tags":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/tags/threejs/"},{"name":"物理引擎","slug":"物理引擎","permalink":"https://cxx001.gitee.io/tags/%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/"},{"name":"声音","slug":"声音","permalink":"https://cxx001.gitee.io/tags/%E5%A3%B0%E9%9F%B3/"}],"keywords":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/categories/threejs/"}]},{"title":"threejs后期处理","slug":"threejs/threejs后期处理","date":"2023-03-07T07:53:15.000Z","updated":"2023-03-14T05:42:25.473Z","comments":true,"path":"2023/03/07/threejs/threejs后期处理/","link":"","permalink":"https://cxx001.gitee.io/2023/03/07/threejs/threejs%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86/","excerpt":"","text":"1. 如何使用Threejs的后期处理后期处理就是在场景渲染完后，最后对场景显示效果调整的手段。 使用后期处理步骤： （1）创建THREE.EffectComposer对象。(效果组合器) （2）在该对象上添加后期处理通道。(渲染时就会按照添加的顺序依次处理–即渲染管线类似) （3）在render循环中，使用THREE.EffectComposer来渲染场景。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130&lt;!-- chapter-11-01.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Effect composings&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/OrbitControls.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/ShaderPass.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/shaders/CopyShader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/EffectComposer.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/MaskPass.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/FilmPass.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/shaders/FilmShader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/RenderPass.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0x000, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; var sphere = createMesh(new THREE.SphereGeometry(10, 40, 40)); scene.add(sphere); camera.position.x = -10; camera.position.y = 15; camera.position.z = 25; camera.lookAt(new THREE.Vector3(0, 0, 0)); var orbitControls = new THREE.OrbitControls(camera); orbitControls.autoRotate = false; var clock = new THREE.Clock(); var ambi = new THREE.AmbientLight(0x181818); scene.add(ambi); var spotLight = new THREE.DirectionalLight(0xffffff); spotLight.position.set(550, 100, 550); spotLight.intensity = 0.6; scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); // 1. 创建效果组合器对象 var composer = new THREE.EffectComposer(webGLRenderer); // 2. 添加后期处理通道 var renderPass = new THREE.RenderPass(scene, camera); // 该通道会在当前场景和摄像机的基础上渲染出一个新场景 var effectFilm = new THREE.FilmPass(0.8, 0.325, 256, false); // 该通道可以实现电视栅格效果 effectFilm.renderToScreen = true; // 渲染到界面(不是所有通道都有该属性) composer.addPass(renderPass); composer.addPass(effectFilm); var controls = new function () &#123; this.scanlinesCount = 256; // 控制扫描线数量 this.grayscale = false; // 如果设置为true，输出结果将会被转换为灰度图 this.scanlinesIntensity = 0.3; // 指定扫描线的显著程度 this.noiseIntensity = 0.8; // 控制场景的粗糙程度 this.updateEffectFilm = function () &#123; effectFilm.uniforms.grayscale.value = controls.grayscale; effectFilm.uniforms.nIntensity.value = controls.noiseIntensity; effectFilm.uniforms.sIntensity.value = controls.scanlinesIntensity; effectFilm.uniforms.sCount.value = controls.scanlinesCount; &#125;; &#125;; var gui = new dat.GUI(); gui.add(controls, &quot;scanlinesIntensity&quot;, 0, 1).onChange(controls.updateEffectFilm); gui.add(controls, &quot;noiseIntensity&quot;, 0, 3).onChange(controls.updateEffectFilm); gui.add(controls, &quot;grayscale&quot;).onChange(controls.updateEffectFilm); gui.add(controls, &quot;scanlinesCount&quot;, 0, 2048).step(1).onChange(controls.updateEffectFilm); function createMesh(geom) &#123; var planetTexture = THREE.ImageUtils.loadTexture(&quot;../assets/textures/planets/Earth.png&quot;); var specularTexture = THREE.ImageUtils.loadTexture(&quot;../assets/textures/planets/EarthSpec.png&quot;); var normalTexture = THREE.ImageUtils.loadTexture(&quot;../assets/textures/planets/EarthNormal.png&quot;); var planetMaterial = new THREE.MeshPhongMaterial(); planetMaterial.specularMap = specularTexture; planetMaterial.specular = new THREE.Color(0x4444aa); planetMaterial.normalMap = normalTexture; planetMaterial.map = planetTexture; //planetMaterial.shininess = 150; var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [planetMaterial]); return mesh; &#125; var delta = clock.getDelta(); function render() &#123; stats.update(); orbitControls.update(delta); sphere.rotation.y += 0.002; requestAnimationFrame(render); // 3. 用效果组合器来渲染 composer.render(delta); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2. Threejs提供的后期处理通道Threejs库提供了许多后期处理通道，这些通道可以直接添加到THREE.EffectComposer组合器中使用。 （1）简单后期处理通道123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232&lt;!-- chapter-11-02.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Simple passes&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/OrbitControls.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/ShaderPass.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/shaders/CopyShader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/BloomPass.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/shaders/ConvolutionShader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/DotScreenPass.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/shaders/DotScreenShader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/EffectComposer.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/MaskPass.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/FilmPass.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/shaders/FilmShader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/RenderPass.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/TexturePass.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0x000, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; var sphere = createMesh(new THREE.SphereGeometry(10, 40, 40)); scene.add(sphere); camera.position.x = -10; camera.position.y = 15; camera.position.z = 25; camera.lookAt(new THREE.Vector3(0, 0, 0)); var orbitControls = new THREE.OrbitControls(camera); orbitControls.autoRotate = false; var ambi = new THREE.AmbientLight(0x686868); scene.add(ambi); var spotLight = new THREE.DirectionalLight(0xffffff); spotLight.position.set(550, 100, 550); spotLight.intensity = 0.6; scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); // 复制场景 var renderPass = new THREE.RenderPass(scene, camera); var effectCopy = new THREE.ShaderPass(THREE.CopyShader); effectCopy.renderToScreen = true; var composer = new THREE.EffectComposer(webGLRenderer); composer.addPass(renderPass); composer.addPass(effectCopy); // 将上面场景输出为纹理，然后就可以作为其它组合器输入使用，这样就可以重复使用而不必每次都从零开始渲染场景。 var renderScene = new THREE.TexturePass(composer.renderTarget2); // 简单组合器 var bloomPass = new THREE.BloomPass(3, 25, 5.0, 256); var effectFilm = new THREE.FilmPass(0.8, 0.325, 256, false); effectFilm.renderToScreen = true; var dotScreenPass = new THREE.DotScreenPass(); // 左下(黑点图层通道) var composer1 = new THREE.EffectComposer(webGLRenderer); composer1.addPass(renderScene); composer1.addPass(dotScreenPass); composer1.addPass(effectCopy); // 右下(原始图) var composer2 = new THREE.EffectComposer(webGLRenderer); composer2.addPass(renderScene); composer2.addPass(effectCopy); // 左上(泛光效果) var composer3 = new THREE.EffectComposer(webGLRenderer); composer3.addPass(renderScene); composer3.addPass(bloomPass); composer3.addPass(effectCopy); // 右上(电视栅格效果) var composer4 = new THREE.EffectComposer(webGLRenderer); composer4.addPass(renderScene); composer4.addPass(effectFilm); var controls = new function () &#123; // film this.scanlinesCount = 256; // 控制扫描线数量 this.grayscale = false; // 设为true，输出结果将会被转换为灰度图 this.scanlinesIntensity = 0.3; // 指定扫描线的显著程度 this.noiseIntensity = 0.8; // 控制场景的粗糙程度 // bloompass this.strength = 3; // 泛光效果强度 this.kernelSize = 25; // 泛光效果的偏移量 this.sigma = 5.0; // 控制泛光效果的锐利程度，值越大，泛光效果看起来越模糊 this.resolution = 256; // 泛光效果的精确度，值越小，泛光效果的方块化越严重 // dotscreen this.centerX = 0.5; // 点偏移量 this.centerY = 0.5; this.angle = 1.57; // 改变点的对齐方式 this.scale = 1; // 设置点的大小。值越小，则点越大 this.updateEffectFilm = function () &#123; effectFilm.uniforms.grayscale.value = controls.grayscale; effectFilm.uniforms.nIntensity.value = controls.noiseIntensity; effectFilm.uniforms.sIntensity.value = controls.scanlinesIntensity; effectFilm.uniforms.sCount.value = controls.scanlinesCount; &#125;; this.updateDotScreen = function () &#123; var dotScreenPass = new THREE.DotScreenPass(new THREE.Vector2(controls.centerX, controls.centerY), controls.angle, controls.scale); composer1 = new THREE.EffectComposer(webGLRenderer); composer1.addPass(renderScene); composer1.addPass(dotScreenPass); composer1.addPass(effectCopy); &#125;; this.updateEffectBloom = function () &#123; bloomPass = new THREE.BloomPass(controls.strength, controls.kernelSize, controls.sigma, controls.resolution); composer3 = new THREE.EffectComposer(webGLRenderer); composer3.addPass(renderScene); composer3.addPass(bloomPass); composer3.addPass(effectCopy); &#125;; &#125;; var gui = new dat.GUI(); var bpFolder = gui.addFolder(&quot;BloomPass&quot;); bpFolder.add(controls, &quot;strength&quot;, 1, 10).onChange(controls.updateEffectBloom); bpFolder.add(controls, &quot;kernelSize&quot;, 1, 100).onChange(controls.updateEffectBloom); bpFolder.add(controls, &quot;sigma&quot;, 1, 10).onChange(controls.updateEffectBloom); bpFolder.add(controls, &quot;resolution&quot;, 0, 1024).onChange(controls.updateEffectBloom); var fpFolder = gui.addFolder(&quot;FilmPass&quot;); fpFolder.add(controls, &quot;scanlinesIntensity&quot;, 0, 1).onChange(controls.updateEffectFilm); fpFolder.add(controls, &quot;noiseIntensity&quot;, 0, 3).onChange(controls.updateEffectFilm); fpFolder.add(controls, &quot;grayscale&quot;).onChange(controls.updateEffectFilm); fpFolder.add(controls, &quot;scanlinesCount&quot;, 0, 2048).step(1).onChange(controls.updateEffectFilm); var dsFolder = gui.addFolder(&quot;DotScreenPass&quot;); dsFolder.add(controls, &quot;centerX&quot;, 0, 1).onChange(controls.updateDotScreen); dsFolder.add(controls, &quot;centerY&quot;, 0, 1).onChange(controls.updateDotScreen); dsFolder.add(controls, &quot;angle&quot;, 0, 3.14).onChange(controls.updateDotScreen); dsFolder.add(controls, &quot;scale&quot;, 0, 10).onChange(controls.updateDotScreen); function createMesh(geom) &#123; var planetTexture = THREE.ImageUtils.loadTexture(&quot;../assets/textures/planets/Earth.png&quot;); var specularTexture = THREE.ImageUtils.loadTexture(&quot;../assets/textures/planets/EarthSpec.png&quot;); var normalTexture = THREE.ImageUtils.loadTexture(&quot;../assets/textures/planets/EarthNormal.png&quot;); var planetMaterial = new THREE.MeshPhongMaterial(); planetMaterial.specularMap = specularTexture; planetMaterial.specular = new THREE.Color(0x4444aa); planetMaterial.normalMap = normalTexture; planetMaterial.map = planetTexture; var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [planetMaterial]); return mesh; &#125; var width = window.innerWidth || 2; var height = window.innerHeight || 2; var halfWidth = width / 2; var halfHeight = height / 2; var clock = new THREE.Clock(); var delta = clock.getDelta(); function render() &#123; stats.update(); orbitControls.update(delta); sphere.rotation.y += 0.002; requestAnimationFrame(render); // 多场景视口设置 webGLRenderer.autoClear = false; webGLRenderer.clear(); // 副本渲染，后续才能使用这个副本 webGLRenderer.setViewport(0, 0, 2 * halfWidth, 2 * halfHeight); composer.render(delta); // 分别渲染4个视口场景 webGLRenderer.setViewport(0, 0, halfWidth, halfHeight); composer1.render(delta); webGLRenderer.setViewport(halfWidth, 0, halfWidth, halfHeight); composer2.render(delta); webGLRenderer.setViewport(0, halfHeight, halfWidth, halfHeight); composer3.render(delta); webGLRenderer.setViewport(halfWidth, halfHeight, halfWidth, halfHeight); composer4.render(delta); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125;; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; （2）使用掩码的高级效果组合器前面使用后期处理的通道都是针对整个屏幕上，而下面讨论的掩码通道就可以指定特定区域上使用通道。添加掩码通道后，则后续的通道只作用于这个掩码通道区域。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187&lt;!-- chapter-11-03.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Post processing masks&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/OrbitControls.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/ShaderPass.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/shaders/CopyShader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/shaders/ColorifyShader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/BloomPass.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/shaders/ConvolutionShader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/EffectComposer.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/MaskPass.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/FilmPass.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/shaders/FilmShader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/shaders/SepiaShader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/RenderPass.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/SavePass.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/TexturePass.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); // 3个场景分别渲染地球、火星、背景 var sceneEarth = new THREE.Scene(); var sceneMars = new THREE.Scene(); var sceneBG = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var cameraBG = new THREE.OrthographicCamera(-window.innerWidth, window.innerWidth, window.innerHeight, -window.innerHeight, -10000, 10000); // 用正交相机来显示背景图 cameraBG.position.z = 50; var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0x000, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; var sphere = createEarthMesh(new THREE.SphereGeometry(10, 40, 40)); sphere.position.x = -10; var sphere2 = createMarshMesh(new THREE.SphereGeometry(5, 40, 40)); sphere2.position.x = 10; sceneEarth.add(sphere); sceneMars.add(sphere2); camera.position.x = -10; camera.position.y = 15; camera.position.z = 25; camera.lookAt(new THREE.Vector3(0, 0, 0)); var materialColor = new THREE.MeshBasicMaterial(&#123; map: THREE.ImageUtils.loadTexture(&quot;../assets/textures/starry-deep-outer-space-galaxy.jpg&quot;), depthTest: false &#125;); var bgPlane = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), materialColor); bgPlane.position.z = -100; bgPlane.scale.set(window.innerWidth * 2, window.innerHeight * 2, 1); sceneBG.add(bgPlane); var orbitControls = new THREE.OrbitControls(camera); orbitControls.autoRotate = false; var clock = new THREE.Clock(); // 注意不同场景光源要独立 var ambi = new THREE.AmbientLight(0x181818); var ambi2 = new THREE.AmbientLight(0x181818); sceneEarth.add(ambi); sceneMars.add(ambi2); var spotLight = new THREE.DirectionalLight(0xffffff); spotLight.position.set(550, 100, 550); spotLight.intensity = 0.6; var spotLight2 = new THREE.DirectionalLight(0xffffff); spotLight.position.set(550, 100, 550); spotLight.intensity = 0.6; sceneEarth.add(spotLight); sceneMars.add(spotLight2); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); // 3个对应的渲染场景通道 var bgPass = new THREE.RenderPass(sceneBG, cameraBG); var renderPass = new THREE.RenderPass(sceneEarth, camera); renderPass.clear = false; // 要设置为false，不然每次渲染前会把前面已经渲染的给清除 var renderPass2 = new THREE.RenderPass(sceneMars, camera); renderPass2.clear = false; // 复制当前渲染结果显示到屏幕通道 var effectCopy = new THREE.ShaderPass(THREE.CopyShader); effectCopy.renderToScreen = true; // THREE.MaskPass到THREE.ClearMaskPass之间的通道只作用在THREE.MaskPass掩码通道对象上 var clearMask = new THREE.ClearMaskPass(); // earth mask var earthMask = new THREE.MaskPass(sceneEarth, camera); // earthMask.inverse = true; // 反转掩码 // mars mask var marsMask = new THREE.MaskPass(sceneMars, camera); // marsMask.inverse = true; var effectSepia = new THREE.ShaderPass(THREE.SepiaShader); effectSepia.uniforms[&#x27;amount&#x27;].value = 0.8; var effectColorify = new THREE.ShaderPass(THREE.ColorifyShader); effectColorify.uniforms[&#x27;color&#x27;].value.setRGB(0.5, 0.5, 1); var composer = new THREE.EffectComposer(webGLRenderer); // 使用掩码要启动模板缓存 composer.renderTarget1.stencilBuffer = true; composer.renderTarget2.stencilBuffer = true; // 渲染原始场景 composer.addPass(bgPass); composer.addPass(renderPass); composer.addPass(renderPass2); // 添加火星球体场景掩码，后续通道只能作用在这个区域 composer.addPass(marsMask); composer.addPass(effectColorify); // 同上对地球场景添加掩码，只是要注意添加另一个掩码前要先清除上一个掩码通道 composer.addPass(clearMask); composer.addPass(earthMask); composer.addPass(effectSepia); // 清除上次掩码通道，复制当前场景渲染到屏幕 composer.addPass(clearMask); composer.addPass(effectCopy); function createMarshMesh(geom) &#123; var planetTexture = THREE.ImageUtils.loadTexture(&quot;../assets/textures/planets/Mars_2k-050104.png&quot;); var normalTexture = THREE.ImageUtils.loadTexture(&quot;../assets/textures/planets/Mars-normalmap_2k.png&quot;); var planetMaterial = new THREE.MeshPhongMaterial(); planetMaterial.normalMap = normalTexture; planetMaterial.map = planetTexture; var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [planetMaterial]); return mesh; &#125; function createEarthMesh(geom) &#123; var planetTexture = THREE.ImageUtils.loadTexture(&quot;../assets/textures/planets/Earth.png&quot;); var specularTexture = THREE.ImageUtils.loadTexture(&quot;../assets/textures/planets/EarthSpec.png&quot;); var normalTexture = THREE.ImageUtils.loadTexture(&quot;../assets/textures/planets/EarthNormal.png&quot;); var planetMaterial = new THREE.MeshPhongMaterial(); planetMaterial.specularMap = specularTexture; planetMaterial.specular = new THREE.Color(0x4444aa); planetMaterial.normalMap = normalTexture; planetMaterial.map = planetTexture; var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [planetMaterial]); return mesh; &#125; var delta = clock.getDelta(); function render() &#123; webGLRenderer.autoClear = false; stats.update(); orbitControls.update(delta); sphere.rotation.y += 0.002; sphere2.rotation.y += 0.002; requestAnimationFrame(render); composer.render(delta); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 没对火星球体和地球球体添加掩码处理前： 对火星球体添加掩码通道并添加彩色效果，对地球球体添加掩码并添加褐色效果： （3）使用THREE.ShaderPass自定义效果这个通道可以传递一个自定义的着色器，将大量的额外效果添加到场景中。 Threejs提供的简单着色器： 另外，一些提供模糊效果的着色器： 最后，还有一些提供高级效果的着色器： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430&lt;!-- chapter-11-04.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Shader Pass simple&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/OBJLoader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/MTLLoader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/OBJMTLLoader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/EffectComposer.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/ShaderPass.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/RenderPass.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/MaskPass.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/shaders/CopyShader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/shaders/BrightnessContrastShader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/shaders/ColorifyShader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/shaders/SepiaShader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/shaders/RGBShiftShader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/shaders/ColorCorrectionShader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/shaders/MirrorShader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/shaders/VignetteShader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/shaders/HueSaturationShader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/shaders/BlendShader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/shaders/KaleidoShader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/shaders/LuminosityShader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/shaders/TechnicolorShader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/shaders/UnpackDepthRGBAShader.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xaaaaff, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; camera.position.x = 20; camera.position.y = 30; camera.position.z = 40; camera.lookAt(new THREE.Vector3(-15, -10, -25)); var spotLight = new THREE.SpotLight(0xffffff); spotLight.castShadow = true; spotLight.position.set(0, 60, 50); spotLight.intensity = 1; spotLight.shadowMapWidth = 2048; spotLight.shadowMapHeight = 2048; spotLight.shadowCameraFov = 120; spotLight.shadowCameraNear = 1; spotLight.shadowCameraFar = 1000; var ambiLight = new THREE.AmbientLight(0x444444); scene.add(ambiLight); scene.add(spotLight); var plane = new THREE.BoxGeometry(1600, 1600, 0.1, 40, 40); var cube = new THREE.Mesh(plane, new THREE.MeshPhongMaterial( &#123; color: 0xffffff, map: THREE.ImageUtils.loadTexture(&quot;../assets/textures/general/plaster-diffuse.jpg&quot;), normalMap: THREE.ImageUtils.loadTexture(&quot;../assets/textures/general/plaster-normal.jpg&quot;), normalScale: new THREE.Vector2(0.6, 0.6) &#125;)); cube.material.map.wrapS = THREE.RepeatWrapping; cube.material.map.wrapT = THREE.RepeatWrapping; cube.material.normalMap.wrapS = THREE.RepeatWrapping; cube.material.normalMap.wrapT = THREE.RepeatWrapping; cube.rotation.x = Math.PI / 2; cube.material.map.repeat.set(80, 80); cube.receiveShadow = true; cube.position.z = -150; cube.position.x = -150; scene.add(cube); var cube1 = new THREE.Mesh(new THREE.BoxGeometry(30, 10, 2), new THREE.MeshPhongMaterial(&#123;color: 0xff0000&#125;)); cube1.position.x = -15; cube1.position.y = 5; cube1.position.z = 15; cube1.castShadow = true; scene.add(cube1); var cube2 = cube1.clone(); cube2.material = cube1.material.clone(); cube2.material.color = new THREE.Color(0x00ff00); cube2.position.z = 5; cube2.position.x = -20; scene.add(cube2); var cube3 = cube1.clone(); cube3.material = cube1.material.clone(); cube3.material.color = new THREE.Color(0x0000ff); cube3.position.z = -8; cube3.position.x = -25; scene.add(cube3); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var mesh; var loader = new THREE.OBJMTLLoader(); loader.load(&#x27;../assets/models/sol/libertStatue.obj&#x27;, &#x27;../assets/models/sol/libertStatue.mtl&#x27;, function (event) &#123; var object = event; // fix for incorrect uvs. console.log(event); var geom = object.children[0].geometry; var uv3 = geom.faceVertexUvs[0][0]; var uv4 = geom.faceVertexUvs[0][10]; // fill in the missing ones for (var j = 0; j &lt; 7616 - 7206; j++) &#123; if (geom.faces[j + 7206] instanceof THREE.Face4) &#123; geom.faceVertexUvs[0].push(uv4); &#125; else &#123; geom.faceVertexUvs[0].push(uv4); &#125; &#125; object.children.forEach(function (e) &#123; e.castShadow = true &#125;); object.scale.set(20, 20, 20); mesh = object; mesh.position.x = 15; mesh.position.z = 5; scene.add(object); &#125;); // 各种shader通道 var mirror = new THREE.ShaderPass(THREE.MirrorShader); mirror.enabled = false; var hue = new THREE.ShaderPass(THREE.HueSaturationShader); hue.enabled = false; var vignette = new THREE.ShaderPass(THREE.VignetteShader); vignette.enabled = false; var colorCorrection = new THREE.ShaderPass(THREE.ColorCorrectionShader); colorCorrection.enabled = false; var rgbShift = new THREE.ShaderPass(THREE.RGBShiftShader); rgbShift.enabled = false; var brightness = new THREE.ShaderPass(THREE.BrightnessContrastShader); brightness.uniforms.brightness.value = 0; brightness.uniforms.contrast.value = 0; brightness.enabled = false; brightness.uniforms.brightness.value = 0; brightness.uniforms.contrast.value = 0; var colorify = new THREE.ShaderPass(THREE.ColorifyShader); colorify.uniforms.color.value = new THREE.Color(0xffffff); colorify.enabled = false; var sepia = new THREE.ShaderPass(THREE.SepiaShader); sepia.uniforms.amount.value = 1; sepia.enabled = false; var kal = new THREE.ShaderPass(THREE.KaleidoShader); kal.enabled = false; var lum = new THREE.ShaderPass(THREE.LuminosityShader); lum.enabled = false; var techni = new THREE.ShaderPass(THREE.TechnicolorShader); techni.enabled = false; var unpack = new THREE.ShaderPass(THREE.UnpackDepthRGBAShader); unpack.enabled = false; var renderPass = new THREE.RenderPass(scene, camera); var effectCopy = new THREE.ShaderPass(THREE.CopyShader); effectCopy.renderToScreen = true; var composer = new THREE.EffectComposer(webGLRenderer); composer.addPass(renderPass); composer.addPass(brightness); composer.addPass(sepia); composer.addPass(mirror); composer.addPass(colorify); composer.addPass(colorCorrection); composer.addPass(rgbShift); composer.addPass(vignette); composer.addPass(hue); composer.addPass(kal); composer.addPass(lum); composer.addPass(techni); composer.addPass(unpack); composer.addPass(effectCopy); var controls = new function () &#123; this.brightness = 0.01; this.contrast = 0.01; this.select = &#x27;none&#x27;; this.color = 0xffffff; this.amount = 1; this.powRGB_R = 2; this.mulRGB_R = 1; this.powRGB_G = 2; this.mulRGB_G = 1; this.powRGB_B = 2; this.mulRGB_B = 1; this.rgbAmount = 0.005; this.angle = 0.0; this.side = 1; this.offset = 1; this.darkness = 1; this.hue = 0.01; this.saturation = 0.01; this.kalAngle = 0; this.kalSides = 6; this.rotate = false; this.switchShader = function () &#123; switch (controls.select) &#123; case &#x27;none&#x27; : &#123; enableShader(); break; &#125; case &#x27;colorify&#x27; : &#123; enableShader(colorify); break; &#125; case &#x27;brightness&#x27; : &#123; enableShader(brightness); break; &#125; case &#x27;sepia&#x27; : &#123; enableShader(sepia); break; &#125; case &#x27;colorCorrection&#x27; : &#123; enableShader(colorCorrection); break; &#125; case &#x27;rgbShift&#x27; : &#123; enableShader(rgbShift); break; &#125; case &#x27;mirror&#x27; : &#123; enableShader(mirror); break; &#125; case &#x27;vignette&#x27; : &#123; enableShader(vignette); break; &#125; case &#x27;hueAndSaturation&#x27; : &#123; enableShader(hue); break; &#125; case &#x27;kaleidoscope&#x27; : &#123; enableShader(kal); break; &#125; case &#x27;luminosity&#x27; : &#123; enableShader(lum); break; &#125; case &#x27;technicolor&#x27; : &#123; enableShader(techni); break; &#125; case &#x27;unpackDepth&#x27; : &#123; enableShader(unpack); break; &#125; &#125; &#125;; this.changeBrightness = function () &#123; brightness.uniforms.brightness.value = controls.brightness; brightness.uniforms.contrast.value = controls.contrast; &#125;; this.changeColor = function () &#123; colorify.uniforms.color.value = new THREE.Color(controls.color); &#125;; this.changeSepia = function () &#123; sepia.uniforms.amount.value = controls.amount; &#125;; this.changeCorrection = function () &#123; colorCorrection.uniforms.mulRGB.value = new THREE.Vector3(controls.mulRGB_R, controls.mulRGB_G, controls.mulRGB_B); colorCorrection.uniforms.powRGB.value = new THREE.Vector3(controls.powRGB_R, controls.powRGB_G, controls.powRGB_B); &#125;; this.changeRGBShifter = function () &#123; rgbShift.uniforms.amount.value = controls.rgbAmount; rgbShift.uniforms.angle.value = controls.angle; &#125;; this.changeMirror = function () &#123; mirror.uniforms.side.value = controls.side; &#125;; this.changeVignette = function () &#123; vignette.uniforms.darkness.value = controls.darkness; vignette.uniforms.offset.value = controls.offset; &#125;; this.changeHue = function () &#123; hue.uniforms.hue.value = controls.hue; hue.uniforms.saturation.value = controls.saturation; &#125;; this.changeKal = function () &#123; kal.uniforms.sides.value = controls.kalSides; kal.uniforms.angle.value = controls.kalAngle; &#125;; function enableShader(shader) &#123; for (var i = 1; i &lt; composer.passes.length - 1; i++) &#123; if (composer.passes[i] == shader) &#123; composer.passes[i].enabled = true; &#125; else &#123; composer.passes[i].enabled = false; &#125; &#125; &#125; &#125;; var gui = new dat.GUI(); gui.add(controls, &quot;select&quot;, [&#x27;none&#x27;, &quot;colorify&quot;, &#x27;brightness&#x27;, &#x27;sepia&#x27;, &#x27;colorCorrection&#x27;, &#x27;rgbShift&#x27;, &#x27;mirror&#x27;, &#x27;vignette&#x27;, &#x27;hueAndSaturation&#x27;, &#x27;kaleidoscope&#x27;, &#x27;luminosity&#x27;, &#x27;technicolor&#x27;]).onChange(controls.switchShader); gui.add(controls, &quot;rotate&quot;); var bnFolder = gui.addFolder(&quot;Brightness&quot;); bnFolder.add(controls, &quot;brightness&quot;, -1, 1).onChange(controls.changeBrightness); bnFolder.add(controls, &quot;contrast&quot;, -1, 1).onChange(controls.changeBrightness); var clFolder = gui.addFolder(&quot;Colorify&quot;); clFolder.addColor(controls, &quot;color&quot;).onChange(controls.changeColor); var colFolder = gui.addFolder(&#x27;Color Correction&#x27;); colFolder.add(controls, &quot;powRGB_R&quot;, 0, 5).onChange(controls.changeCorrection); colFolder.add(controls, &quot;powRGB_G&quot;, 0, 5).onChange(controls.changeCorrection); colFolder.add(controls, &quot;powRGB_B&quot;, 0, 5).onChange(controls.changeCorrection); colFolder.add(controls, &quot;mulRGB_R&quot;, 0, 5).onChange(controls.changeCorrection); colFolder.add(controls, &quot;mulRGB_G&quot;, 0, 5).onChange(controls.changeCorrection); colFolder.add(controls, &quot;mulRGB_B&quot;, 0, 5).onChange(controls.changeCorrection); var sepiaFolder = gui.addFolder(&quot;Sepia&quot;); sepiaFolder.add(controls, &quot;amount&quot;, 0, 2).step(0.1).onChange(controls.changeSepia); var shiftFolder = gui.addFolder(&quot;RGB Shift&quot;); shiftFolder.add(controls, &quot;rgbAmount&quot;, 0, 0.1).step(0.001).onChange(controls.changeRGBShifter); shiftFolder.add(controls, &quot;angle&quot;, 0, 3.14).step(0.001).onChange(controls.changeRGBShifter); var mirrorFolder = gui.addFolder(&quot;mirror&quot;); mirrorFolder.add(controls, &quot;side&quot;, 0, 3).step(1).onChange(controls.changeMirror); var vignetteFolder = gui.addFolder(&quot;vignette&quot;); vignetteFolder.add(controls, &quot;darkness&quot;, 0, 2).onChange(controls.changeVignette); vignetteFolder.add(controls, &quot;offset&quot;, 0, 2).onChange(controls.changeVignette); var hueAndSat = gui.addFolder(&quot;hue and saturation&quot;); hueAndSat.add(controls, &quot;hue&quot;, -1, 1).step(0.01).onChange(controls.changeHue); hueAndSat.add(controls, &quot;saturation&quot;, -1, 1).step(0.01).onChange(controls.changeHue); var kalMenu = gui.addFolder(&quot;Kaleidoscope&quot;); kalMenu.add(controls, &quot;kalAngle&quot;, -2 * Math.PI, 2 * Math.PI).onChange(controls.changeKal); kalMenu.add(controls, &quot;kalSides&quot;, 2, 20).onChange(controls.changeKal); function render() &#123; stats.update(); if (controls.rotate) &#123; if (mesh) mesh.rotation.y += 0.01; cube1.rotation.y += 0.01; cube2.rotation.y += 0.01; cube3.rotation.y += 0.01; &#125; requestAnimationFrame(render); composer.render(); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125;; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3. 创建自定义后期处理着色器自定义着色器主要是两个： 顶点着色器：用于改变每个顶点的位置。 片段着色器：用于定义每个像素的颜色。 着色器程序是使用OpenGL着色器语言GLSL写的，有点像C语言。关于这个是一个很大的话题，本节只会简单介绍使用流程。 示例写了两个着色器，一个是将图片转换为灰度图，一个是将图片转换为8位图。 架子(就是用上面的THREE.ShaderPass通道，只是把传递的着色器程序换成我们自定义的了)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149&lt;!-- chapter-11-05.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;custom shaderpass&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/OrbitControls.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/ShaderPass.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/shaders/CopyShader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/EffectComposer.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/MaskPass.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/ShaderPass.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/postprocessing/RenderPass.js&quot;&gt;&lt;/script&gt; &lt;!--- 导入自定义着色器程序 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;custom-shader.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;!-- Div which will hold the Output --&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0x000, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; var sphere = createMesh(new THREE.SphereGeometry(10, 40, 40)); scene.add(sphere); camera.position.x = -10; camera.position.y = 15; camera.position.z = 25; camera.lookAt(new THREE.Vector3(0, 0, 0)); var orbitControls = new THREE.OrbitControls(camera); orbitControls.autoRotate = false; var clock = new THREE.Clock(); var ambi = new THREE.AmbientLight(0x181818); scene.add(ambi); var spotLight = new THREE.DirectionalLight(0xffffff); spotLight.position.set(550, 100, 550); spotLight.intensity = 0.6; scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var renderPass = new THREE.RenderPass(scene, camera); var effectCopy = new THREE.ShaderPass(THREE.CopyShader); effectCopy.renderToScreen = true; // 置灰着色器通道 var shaderPass = new THREE.ShaderPass(THREE.CustomGrayScaleShader); shaderPass.enabled = false; // 转8位图着色器通道 var bitPass = new THREE.ShaderPass(THREE.CustomBitShader); bitPass.enabled = false; var composer = new THREE.EffectComposer(webGLRenderer); composer.addPass(renderPass); composer.addPass(shaderPass); composer.addPass(bitPass); composer.addPass(effectCopy); var controls = new function () &#123; this.grayScale = false; this.rPower = 0.2126; this.gPower = 0.7152; this.bPower = 0.0722; this.bitShader = false; this.bitSize = 8; this.updateEffectFilm = function () &#123; shaderPass.enabled = controls.grayScale; shaderPass.uniforms.rPower.value = controls.rPower; shaderPass.uniforms.gPower.value = controls.gPower; shaderPass.uniforms.bPower.value = controls.bPower; &#125;; this.updateBit = function () &#123; bitPass.enabled = controls.bitShader; bitPass.uniforms.bitSize.value = controls.bitSize; &#125; &#125;; var gui = new dat.GUI(); var grayMenu = gui.addFolder(&#x27;gray scale&#x27;); grayMenu.add(controls, &#x27;grayScale&#x27;).onChange(controls.updateEffectFilm); grayMenu.add(controls, &#x27;rPower&#x27;, 0, 1).onChange(controls.updateEffectFilm); grayMenu.add(controls, &#x27;gPower&#x27;, 0, 1).onChange(controls.updateEffectFilm); grayMenu.add(controls, &#x27;bPower&#x27;, 0, 1).onChange(controls.updateEffectFilm); var bitMenu = gui.addFolder(&#x27;bit&#x27;); bitMenu.add(controls, &#x27;bitShader&#x27;).onChange(controls.updateBit); bitMenu.add(controls, &#x27;bitSize&#x27;, 2, 24).step(1).onChange(controls.updateBit); function createMesh(geom) &#123; var planetTexture = THREE.ImageUtils.loadTexture(&quot;../assets/textures/planets/Earth.png&quot;); var specularTexture = THREE.ImageUtils.loadTexture(&quot;../assets/textures/planets/EarthSpec.png&quot;); var normalTexture = THREE.ImageUtils.loadTexture(&quot;../assets/textures/planets/EarthNormal.png&quot;); var planetMaterial = new THREE.MeshPhongMaterial(); planetMaterial.specularMap = specularTexture; planetMaterial.specular = new THREE.Color(0x4444aa); planetMaterial.normalMap = normalTexture; planetMaterial.map = planetTexture; var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [planetMaterial]); return mesh; &#125; var delta = clock.getDelta(); function render() &#123; stats.update(); orbitControls.update(delta); sphere.rotation.y += 0.002; requestAnimationFrame(render); composer.render(delta); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 着色器程序: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// custom-shader.jsTHREE.CustomGrayScaleShader = &#123; uniforms: &#123; &quot;tDiffuse&quot;: &#123;type: &quot;t&quot;, value: null&#125;, &quot;rPower&quot;: &#123;type: &quot;f&quot;, value: 0.2126&#125;, &quot;gPower&quot;: &#123;type: &quot;f&quot;, value: 0.7152&#125;, &quot;bPower&quot;: &#123;type: &quot;f&quot;, value: 0.0722&#125; &#125;, // 0.2126 R + 0.7152 G + 0.0722 B // vertexshader is always the same for postprocessing steps vertexShader: [ &quot;varying vec2 vUv;&quot;, &quot;void main() &#123;&quot;, &quot;vUv = uv;&quot;, &quot;gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );&quot;, &quot;&#125;&quot; ].join(&quot;\\n&quot;), fragmentShader: [ // pass in our custom uniforms &quot;uniform float rPower;&quot;, &quot;uniform float gPower;&quot;, &quot;uniform float bPower;&quot;, // pass in the image/texture we&#x27;ll be modifying &quot;uniform sampler2D tDiffuse;&quot;, // used to determine the correct texel we&#x27;re working on &quot;varying vec2 vUv;&quot;, // executed, in parallel, for each pixel &quot;void main() &#123;&quot;, // get the pixel from the texture we&#x27;re working with (called a texel) &quot;vec4 texel = texture2D( tDiffuse, vUv );&quot;, // calculate the new color &quot;float gray = texel.r*rPower + texel.g*gPower + texel.b*bPower;&quot;, // return this new color &quot;gl_FragColor = vec4( vec3(gray), texel.w );&quot;, &quot;&#125;&quot; ].join(&quot;\\n&quot;)&#125;;THREE.CustomBitShader = &#123; uniforms: &#123; &quot;tDiffuse&quot;: &#123;type: &quot;t&quot;, value: null&#125;, &quot;bitSize&quot;: &#123;type: &quot;i&quot;, value: 4&#125; &#125;, vertexShader: [ &quot;varying vec2 vUv;&quot;, &quot;void main() &#123;&quot;, &quot;vUv = uv;&quot;, &quot;gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );&quot;, &quot;&#125;&quot; ].join(&quot;\\n&quot;), fragmentShader: [ &quot;uniform int bitSize;&quot;, &quot;uniform sampler2D tDiffuse;&quot;, &quot;varying vec2 vUv;&quot;, &quot;void main() &#123;&quot;, &quot;vec4 texel = texture2D( tDiffuse, vUv );&quot;, &quot;float n = pow(float(bitSize),2.0);&quot;, &quot;float newR = floor(texel.r*n)/n;&quot;, &quot;float newG = floor(texel.g*n)/n;&quot;, &quot;float newB = floor(texel.b*n)/n;&quot;, &quot;gl_FragColor = vec4( vec3(newR,newG,newB), 1.0);&quot;, &quot;&#125;&quot; ].join(&quot;\\n&quot;)&#125;;","categories":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/categories/threejs/"}],"tags":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/tags/threejs/"},{"name":"后期处理","slug":"后期处理","permalink":"https://cxx001.gitee.io/tags/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86/"},{"name":"着色器","slug":"着色器","permalink":"https://cxx001.gitee.io/tags/%E7%9D%80%E8%89%B2%E5%99%A8/"}],"keywords":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/categories/threejs/"}]},{"title":"threejs纹理","slug":"threejs/threejs纹理","date":"2023-02-17T15:11:10.000Z","updated":"2023-03-14T05:44:25.278Z","comments":true,"path":"2023/02/17/threejs/threejs纹理/","link":"","permalink":"https://cxx001.gitee.io/2023/02/17/threejs/threejs%E7%BA%B9%E7%90%86/","excerpt":"","text":"前面我们介绍了各种可以用来覆盖对象的材质，也介绍了如何修改材质的颜色、关泽和不透明度，但是我们还没有详细介绍如何在材质中使用外部图片(也叫纹理). 将纹理应用于材质1. 加载纹理并应用到网格纹理最基础的用法是作为贴图被添加在材质上，当你使用这样的材质创建网格时，网格的颜色则来源于纹理。 注: 为了达到最好效果，图片最好使用2的次方的正方形。 纹理的放大和缩小： 由于纹理可以放大或缩小，所以纹理上的像素不会一对一映射到面的像素上。为此，Threejs提供了各种不同的选项，你可以指定magFilter或minFilter属性来设置纹理如何放大或缩小。 magFilter可选值： 名称 描述 THREE.NearestFilter（最邻近过滤） 会将纹理上最近的像素颜色应用于面上。在放大时，会导致方块化；在缩小时，会丢失很多细节 THREE.LinearFilter（线性过滤） 最终颜色由周围四个像素值来决定。这样虽然在缩小时仍会丢失一些细节，但是在放大时会平滑很多，方块化也比较少出现（默认选择） minFilter属性是要使用mipmap，mipmap是把纹理按照2的倍数进行缩小，直到图形为1×1的大小，然后把这些图都存储起来，这些图片是在加载纹理时创建的，可以用于生成比较光滑的过滤效果。 过滤模式有下面这些： 名称 描述 THREE.NearestMipMapNearestFilter 选择最邻近的mip层，并执行上表中最邻近过滤。虽然放大时仍然会有方块化，但是缩小时效果会好很多 THREE.NearestMipMapLinearFilter 选择最邻近的两个mip层，并分别在这两个mip层上运行最邻近过滤获取两个中间值，最后将这两个中间值传递到线性过滤器中获取最终值 THREE.LinearMipMapNearestFilter 选择最邻近的mip层，并执行前表中的线性过滤 THREE.LinearMipMapLinearFilter 选择最邻近的两个mip层，并分别在这两个mip层上运行线性过滤获取两个中间值，最后将这两个中间值传递到线性过滤器中获取最终值（默认选择） 其它格式纹理加载器： 除了使用THREE.ImageUtils.loadTexture方法加载标志格式的png，gif或jpeg图片，Threejs还提供了一些自定义加载器，以此来加载其它格式的纹理文件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;!-- chapter-10-01.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Basic textures&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; // 二十面体 var polyhedron = createMesh(new THREE.IcosahedronGeometry(5, 0), &quot;metal-rust.jpg&quot;); polyhedron.position.x = 12; scene.add(polyhedron); // 球体 var sphere = createMesh(new THREE.SphereGeometry(5, 20, 20), &quot;floor-wood.jpg&quot;); scene.add(sphere); // 立方体 var cube = createMesh(new THREE.BoxGeometry(5, 5, 5), &quot;brick-wall.jpg&quot;); cube.position.x = -12; scene.add(cube); console.log(cube.geometry.faceVertexUvs); camera.position.x = 00; camera.position.y = 12; camera.position.z = 28; camera.lookAt(new THREE.Vector3(0, 0, 0)); var ambiLight = new THREE.AmbientLight(0x141414); scene.add(ambiLight); var light = new THREE.DirectionalLight(); light.position.set(0, 30, 20); scene.add(light); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); // 使用外部纹理作为材质创建网格对象 function createMesh(geom, imageFile) &#123; // 如果加载其它格式纹理，使用上面介绍的对应加载器即可 var texture = THREE.ImageUtils.loadTexture(&quot;../assets/textures/general/&quot; + imageFile); var mat = new THREE.MeshPhongMaterial(); mat.map = texture; var mesh = new THREE.Mesh(geom, mat); return mesh; &#125; var step = 0; function render() &#123; stats.update(); polyhedron.rotation.y = step += 0.01; polyhedron.rotation.x = step; cube.rotation.y = step; cube.rotation.x = step; sphere.rotation.y = step; sphere.rotation.x = step; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2. 使用凹凸贴图创建褶皱凹凸贴图用于为材质添加厚度，网格面看起来有起伏、深度的感觉，更加立体。我们使用材质的bumpMap属性和bumpScale属性。 但是注意像素的密集程度定义的是凹凸的高度，但是凹凸图只包含像素的相对高度，没有任何倾斜的方向信息。所以使用凹凸贴图所能表达的深度信息有限，要想实现更多的细节可以使用法向贴图。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137&lt;!-- chapter-10-02.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Bump maps&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; // 右边没有使用凹凸贴图墙体 var sphere1 = createMesh(new THREE.BoxGeometry(15, 15, 2), &quot;stone.jpg&quot;); sphere1.rotation.y = -0.5; sphere1.position.x = 12; scene.add(sphere1); // 左边使用凹凸贴图墙体 var sphere2 = createMesh(new THREE.BoxGeometry(15, 15, 2), &quot;stone.jpg&quot;, &quot;stone-bump.jpg&quot;); sphere2.rotation.y = 0.5; sphere2.position.x = -12; scene.add(sphere2); console.log(sphere2.geometry.faceVertexUvs); // 地面 var floorTex = THREE.ImageUtils.loadTexture(&quot;../assets/textures/general/floor-wood.jpg&quot;); var plane = new THREE.Mesh(new THREE.BoxGeometry(200, 100, 0.1, 30), new THREE.MeshPhongMaterial(&#123; color: 0x3c3c3c, map: floorTex &#125;)); plane.position.y = -7.5; plane.rotation.x = -0.5 * Math.PI; scene.add(plane); camera.position.x = 00; camera.position.y = 12; camera.position.z = 28; camera.lookAt(new THREE.Vector3(0, 0, 0)); var ambiLight = new THREE.AmbientLight(0x242424); scene.add(ambiLight); var light = new THREE.SpotLight(); light.position.set(0, 30, 30); light.intensity = 1.2; scene.add(light); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var controls = new function () &#123; this.bumpScale = 0.2; this.rotate = false; this.changeTexture = function (e) &#123; var texture = THREE.ImageUtils.loadTexture(&quot;../assets/textures/general/&quot; + e + &quot;.jpg&quot;); sphere2.material.map = texture; sphere1.material.map = texture; var bump = THREE.ImageUtils.loadTexture(&quot;../assets/textures/general/&quot; + e + &quot;-bump.jpg&quot;); sphere2.material.bumpMap = bump; &#125;; this.updateBump = function (e) &#123; console.log(sphere2.material.bumpScale); sphere2.material.bumpScale = e; &#125; &#125;; var gui = new dat.GUI(); gui.add(controls, &quot;bumpScale&quot;, -2, 2).onChange(controls.updateBump); gui.add(controls, &quot;changeTexture&quot;, [&#x27;stone&#x27;, &#x27;weave&#x27;]).onChange(controls.changeTexture); gui.add(controls, &quot;rotate&quot;); function createMesh(geom, imageFile, bump) &#123; var texture = THREE.ImageUtils.loadTexture(&quot;../assets/textures/general/&quot; + imageFile); geom.computeVertexNormals(); var mat = new THREE.MeshPhongMaterial(); mat.map = texture; // 加载使用凹凸贴图 if (bump) &#123; var bump = THREE.ImageUtils.loadTexture(&quot;../assets/textures/general/&quot; + bump); mat.bumpMap = bump; // 指定凹凸纹理 mat.bumpScale = 0.2; // 指定凹凸程度 console.log(&#x27;d&#x27;); &#125; var mesh = new THREE.Mesh(geom, mat); return mesh; &#125; function render() &#123; stats.update(); if (controls.rotate) &#123; sphere1.rotation.y -= 0.01; sphere2.rotation.y += 0.01; &#125; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3. 使用法向贴图创建更加细致的凹凸和褶皱法线贴图保存的不是高度信息，而是法向量的方向。简单来讲，使用法向量贴图只需要使用很少的顶点和面就可以创建出细节很丰富的模型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182&lt;!-- chapter-10-03.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Normal maps&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; // 右边普通纹理立方体 var sphere1 = createMesh(new THREE.BoxGeometry(15, 15, 15), &quot;plaster.jpg&quot;); sphere1.rotation.y = -0.5; sphere1.position.x = 12; scene.add(sphere1); // 左边法向贴图立方体 var sphere2 = createMesh(new THREE.BoxGeometry(15, 15, 15), &quot;plaster.jpg&quot;, &quot;plaster-normal.jpg&quot;); sphere2.rotation.y = 0.5; sphere2.position.x = -12; scene.add(sphere2); console.log(sphere2.geometry.faceVertexUvs); // 地面 var floorTex = THREE.ImageUtils.loadTexture(&quot;../assets/textures/general/floor-wood.jpg&quot;); var plane = new THREE.Mesh(new THREE.BoxGeometry(200, 100, 0.1, 30), new THREE.MeshPhongMaterial(&#123; color: 0x3c3c3c, map: floorTex &#125;)); plane.position.y = -7.5; plane.rotation.x = -0.5 * Math.PI; scene.add(plane); camera.position.x = 00; camera.position.y = 12; camera.position.z = 38; camera.lookAt(new THREE.Vector3(0, 0, 0)); var ambiLight = new THREE.AmbientLight(0x242424); scene.add(ambiLight); var light = new THREE.SpotLight(); light.position.set(0, 30, 30); light.intensity = 1.2; scene.add(light); var pointColor = &quot;#ff5808&quot;; var directionalLight = new THREE.PointLight(pointColor); scene.add(directionalLight); // 光源标志小球 var sphereLight = new THREE.SphereGeometry(0.2); var sphereLightMaterial = new THREE.MeshBasicMaterial(&#123;color: 0xac6c25&#125;); var sphereLightMesh = new THREE.Mesh(sphereLight, sphereLightMaterial); sphereLightMesh.castShadow = true; sphereLightMesh.position = new THREE.Vector3(3, 3, 3); scene.add(sphereLightMesh); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var controls = new function () &#123; this.normalScale = 1; this.changeTexture = &quot;plaster&quot;; this.rotate = false; this.changeTexture = function (e) &#123; var texture = THREE.ImageUtils.loadTexture(&quot;../assets/textures/general/&quot; + e + &quot;.jpg&quot;); sphere2.material.map = texture; sphere1.material.map = texture; var bump = THREE.ImageUtils.loadTexture(&quot;../assets/textures/general/&quot; + e + &quot;-normal.jpg&quot;); sphere2.material.normalMap = bump; // 指定法向贴图纹理 &#125;; this.updateBump = function (e) &#123; sphere2.material.normalScale.set(e, e); // 指定法向贴图凹凸程度 &#125; &#125;; var gui = new dat.GUI(); gui.add(controls, &quot;normalScale&quot;, -2, 2).onChange(controls.updateBump); gui.add(controls, &quot;changeTexture&quot;, [&#x27;plaster&#x27;, &#x27;bathroom&#x27;, &#x27;metal-floor&#x27;]).onChange(controls.changeTexture); gui.add(controls, &quot;rotate&quot;); function createMesh(geom, imageFile, normal) &#123; if (normal) &#123; // 创建法向贴图网格 var t = THREE.ImageUtils.loadTexture(&quot;../assets/textures/general/&quot; + imageFile); var m = THREE.ImageUtils.loadTexture(&quot;../assets/textures/general/&quot; + normal); var mat2 = new THREE.MeshPhongMaterial(); mat2.map = t; // 指定外部纹理 // 使用法向贴图最大问题是这个贴图的创建，需要使用如Blender或Photoshop这样的特殊工具。 // 这些工具可以讲高分辨率的效果图或纹理作为输入来创建法向贴图。 // Threejs同样提供了在运行期创建法向贴图的方法，THREE.ImageUtils对象的getNormalMap方法。 mat2.normalMap = m; // 指定法向贴图纹理 var mesh = new THREE.Mesh(geom, mat2); return mesh; &#125; else &#123; // 创建普通纹理网格 var t = THREE.ImageUtils.loadTexture(&quot;../assets/textures/general/&quot; + imageFile); var mat1 = new THREE.MeshPhongMaterial(&#123; map: t &#125;); var mesh = new THREE.Mesh(geom, mat1); return mesh; &#125; return mesh; &#125; var invert = 1; var phase = 0; var step = 0; function render() &#123; stats.update(); step += 0.1; if (controls.rotate) &#123; sphere1.rotation.y -= 0.01; sphere2.rotation.y += 0.01; &#125; if (phase &gt; 2 * Math.PI) &#123; invert = invert * -1; phase -= 2 * Math.PI; &#125; else &#123; phase += 0.03; &#125; sphereLightMesh.position.z = +(21 * (Math.sin(phase))); sphereLightMesh.position.x = -14 + (14 * (Math.cos(phase))); if (invert &lt; 0) &#123; var pivot = 0; sphereLightMesh.position.x = (invert * (sphereLightMesh.position.x - pivot)) + pivot; &#125; // 平行光源随小球一起运动 directionalLight.position.copy(sphereLightMesh.position); requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125;; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4. 使用光照贴图创建阴影效果前面我们也介绍了可以受光照影响实时产生阴影的材质。本节来看看另一种产生阴影的方法–光照贴图。它是预先渲染好的阴影，可以用它来模拟真实的阴影，效率更高，主要用于静态场景的阴影。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;!-- chapter-10-04.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;LightMap&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var renderer; var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; renderer = webGLRenderer; // 地面，使用光照贴图 var groundGeom = new THREE.PlaneGeometry(95, 95, 1, 1); var lm = THREE.ImageUtils.loadTexture(&#x27;../assets/textures/lightmap/lm-1.png&#x27;); var wood = THREE.ImageUtils.loadTexture(&#x27;../assets/textures/general/floor-wood.jpg&#x27;); var groundMaterial = new THREE.MeshBasicMaterial( &#123; color: 0x777777, lightMap: lm, // 指定光照贴图 map: wood // 指定纹理 &#125;); // 要让光照贴图显示出来还需要指定它的UV映射，详情请参考： // http://stackoverflow.com/questions/15137695/three-js-lightmap-causes-an-error-webglrenderingcontext-gl-error-gl-invalid-op // https://github.com/mrdoob/three.js/pull/2372 groundGeom.faceVertexUvs[1] = groundGeom.faceVertexUvs[0]; var groundMesh = new THREE.Mesh(groundGeom, groundMaterial); groundMesh.rotation.x = -Math.PI / 2; groundMesh.position.y = 0; scene.add(groundMesh); // 创建两个立方体，并放到阴影正确位置 var cubeGeometry = new THREE.BoxGeometry(12, 12, 12); var cubeGeometry2 = new THREE.BoxGeometry(6, 6, 6); var meshMaterial = new THREE.MeshBasicMaterial(); meshMaterial.map = THREE.ImageUtils.loadTexture(&#x27;../assets/textures/general/stone.jpg&#x27;); var cube = new THREE.Mesh(cubeGeometry, meshMaterial); var cube2 = new THREE.Mesh(cubeGeometry2, meshMaterial); cube.position.set(0.9, 6, -12); cube2.position.set(-13.2, 3, -6); scene.add(cube); scene.add(cube2); camera.position.x = -20; camera.position.y = 20; camera.position.z = 30; camera.lookAt(new THREE.Vector3(0, 0, 0)); var ambientLight = new THREE.AmbientLight(0x0c0c0c); scene.add(ambientLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(renderer.domElement); function render() &#123; stats.update(); requestAnimationFrame(render); renderer.render(scene, camera); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5. 使用环境贴图创建反光效果计算环境的反光效果对CPU耗费是非常巨大的，而且通常会使用光线追踪算法。本节我们用另一种方式实现反光效果，通过创建一个对象所处环境的纹理来伪装反光，并将它应用到指定的对象上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;!-- chapter-10-05.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;dynamic envmap&lt;/title&gt; &lt;script src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../libs/OrbitControls.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;script&gt; var renderer; var scene; var camera, cubeCamera; var control; var orbit; var sphere; function init() &#123; scene = new THREE.Scene(); camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 10000); orbit = new THREE.OrbitControls(camera); renderer = new THREE.WebGLRenderer(); renderer.setClearColor(0x000000, 1.0); renderer.setSize(window.innerWidth, window.innerHeight); //1. 创建天空盒，你处于盒子中间，看到的是盒子里的纹理图形，就像你身处场景中一样。 // 创建盒子贴图纹理(6个面是场景的360全景图纹理) var textureCube = createCubeMap(); textureCube.format = THREE.RGBFormat; // 使用Shader材质 var shader = THREE.ShaderLib[&quot;cube&quot;]; shader.uniforms[&quot;tCube&quot;].value = textureCube; var material = new THREE.ShaderMaterial(&#123; fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: shader.uniforms, depthWrite: false, side: THREE.DoubleSide &#125;); // 创建天空盒，使用上面的环境材质创建立方盒子 var skybox = new THREE.Mesh(new THREE.BoxGeometry(10000, 10000, 10000), material); scene.add(skybox); // 2. 将场景中的纹理反射到网格上(环境纹理获取两种方式：1.THREE.CubeCamera快照 2.直接使用上面创建的CubeMap纹理) // 创建一个获取环境贴图的cubeCamera,可以为场景中的所有渲染的物体创建快照。 cubeCamera = new THREE.CubeCamera(0.1, 20000, 256); scene.add(cubeCamera); // 动态反射：将THREE.CubeCamera生成的环境贴图纹理指定到球体材质上 var sphereGeometry = new THREE.SphereGeometry(4, 15, 15); var dynamicEnvMaterial = new THREE.MeshBasicMaterial(&#123;envMap: cubeCamera.renderTarget, side: THREE.DoubleSide&#125;); // envMap环境贴图属性，通过cubeCamera的renderTarget对象获取生成的立方体纹理 sphere = new THREE.Mesh(sphereGeometry, dynamicEnvMaterial); sphere.name = &#x27;sphere&#x27;; scene.add(sphere); // 静态反射：将加载全景图的6面生成的环境贴图纹理指定到圆锥材质上 var cylinderGeometry = new THREE.CylinderGeometry(2, 4, 10, 20, 20, false); var envMaterial = new THREE.MeshBasicMaterial(&#123;envMap: textureCube, side: THREE.DoubleSide&#125;); var cylinder = new THREE.Mesh(cylinderGeometry, envMaterial); cylinder.name = &#x27;cylinder&#x27;; scene.add(cylinder); cylinder.position.set(10, 0, 0); // 立方体使用同上材质 var boxGeometry = new THREE.BoxGeometry(5, 5, 5); var cube = new THREE.Mesh(boxGeometry, envMaterial); cube.name = &#x27;cube&#x27;; scene.add(cube); cube.position.set(-10, 0, 0); camera.position.x = 0; camera.position.y = 5; camera.position.z = 33; camera.lookAt(scene.position); document.body.appendChild(renderer.domElement); render(); &#125; // 创建环境贴图立方盒子 function createCubeMap() &#123; var path = &quot;../assets/textures/cubemap/parliament/&quot;; var format = &#x27;.jpg&#x27;; // 360全景图转换而来, 有在线工具可以转 var urls = [ path + &#x27;posx&#x27; + format, path + &#x27;negx&#x27; + format, // 左右面纹理 path + &#x27;posy&#x27; + format, path + &#x27;negy&#x27; + format, // 上下面纹理 path + &#x27;posz&#x27; + format, path + &#x27;negz&#x27; + format // 前后面纹理 ]; // 创建CubeMap对象 var textureCube = THREE.ImageUtils.loadTextureCube(urls, new THREE.CubeReflectionMapping()); return textureCube; /* * threejs也可以直接使用全景图来创建CubeMap对象 * var textureCube = THREE.ImageUtils.loadTexture(&quot;360-degrees.png&quot;, new THREE.UVMapping()); */ &#125; function render() &#123; orbit.update(); // 控制拖拽 sphere.visible = false; cubeCamera.updateCubeMap(renderer, scene); // 当前场景快照 sphere.visible = true; renderer.render(scene, camera); scene.getObjectByName(&#x27;cube&#x27;).rotation.x += 0.005; scene.getObjectByName(&#x27;cube&#x27;).rotation.y += 0.005; scene.getObjectByName(&#x27;cylinder&#x27;).rotation.x += 0.005; requestAnimationFrame(render); &#125; window.onload = init;&lt;/script&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 6. 使用高光贴图创建闪亮效果通过高光贴图，你可以为材质指定一个闪亮的、色彩明快的贴图。 下面示例：海洋区域反光、明亮；陆地不反光、暗淡。细节效果需要自调参数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!-- chapter-10-06.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Specular map&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/OrbitControls.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0x000, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; var sphere = createMesh(new THREE.SphereGeometry(10, 40, 40)); scene.add(sphere); camera.position.x = 15; camera.position.y = 15; camera.position.z = 15; camera.lookAt(new THREE.Vector3(0, 0, 0)); var orbitControls = new THREE.OrbitControls(camera); orbitControls.autoRotate = false; var ambi = new THREE.AmbientLight(0x3300000); scene.add(ambi); var spotLight = new THREE.DirectionalLight(0xffffff); spotLight.position.set(350, 350, 150); spotLight.intensity = 0.4; scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); function createMesh(geom) &#123; var planetTexture = THREE.ImageUtils.loadTexture(&quot;../assets/textures/planets/Earth.png&quot;); var specularTexture = THREE.ImageUtils.loadTexture(&quot;../assets/textures/planets/EarthSpec.png&quot;); var normalTexture = THREE.ImageUtils.loadTexture(&quot;../assets/textures/planets/EarthNormal.png&quot;); var planetMaterial = new THREE.MeshPhongMaterial(); planetMaterial.specularMap = specularTexture; // 高光贴图 planetMaterial.specular = new THREE.Color(0xff0000); // 通常与specularMap一起使用，决定反光的颜色 planetMaterial.normalMap = normalTexture; // 法向贴图 planetMaterial.map = planetTexture; // 使用的纹理 planetMaterial.shininess = 150; // 指定高光部分的亮度 var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [planetMaterial]); return mesh; &#125; var clock = new THREE.Clock(); function render() &#123; stats.update(); var delta = clock.getDelta(); orbitControls.update(delta); sphere.rotation.y += 0.005; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 纹理的高级用途1. 自定义UV映射UV映射是指指定纹理的哪部分显示在物体的表面上。默认是将整个纹理显示到物体表面上，一般不需要修改，如果要自定义UV映射，指定部分纹理显示到物体表面，通常都是借助建模工具完成(Blender)。 原理是修改几何体对应面的每个顶点的faceVertexUvs属性，这个属性有两个维度u/v，对应faceVertexUvs属性的x/y，取值范围0~1。 如修改几何体第一个面的UV映射： 1234567// 第一个面(由3个顶点组成)geom.faceVertexUvs[0][0][0].x = 0.5; // 第一个面的第一个顶点的u值geom.faceVertexUvs[0][0][0].y = 0.7; // 第一个面的第一个顶点的v值geom.faceVertexUvs[0][0][1].x = 0.4; // 第一个面的第二个顶点...以此类推geom.faceVertexUvs[0][0][1].y = 0.1;geom.faceVertexUvs[0][0][2].x = 0.4;geom.faceVertexUvs[0][0][2].y = 0.5; 很明显这样自定义设置很不直观，所以一般自定义UV映射我们一般通过专业工具完成，然后加载模型文件即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;!-- chapter-10-07.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;UV mapping &lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/OBJLoader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xffffff, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; camera.position.x = -30; camera.position.y = 40; camera.position.z = 50; camera.lookAt(new THREE.Vector3(0, 0, 0)); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var mesh; var controls = new function () &#123; // 第一组自定义UV模型 this.loadCube1 = function () &#123; var loader = new THREE.OBJLoader(); // 加载自定义UV模型文件(修改的是面的顶点的uv值)，决定纹理的哪些部分显示到表面上 loader.load(&#x27;../assets/models/UVCube1.obj&#x27;, function (geometry) &#123; if (mesh) scene.remove(mesh); var material = new THREE.MeshBasicMaterial(&#123;color: 0xffffff&#125;); var texture = THREE.ImageUtils.loadTexture(&quot;../assets/textures/ash_uvgrid01.jpg&quot;); material.map = texture; geometry.children[0].material = material; mesh = geometry; geometry.scale.set(15, 15, 15); scene.add(geometry); &#125;); &#125;; // 第二组自定义UV模型 this.loadCube2 = function () &#123; var loader = new THREE.OBJLoader(); loader.load(&#x27;../assets/models/UVCube2.obj&#x27;, function (geometry) &#123; if (mesh) scene.remove(mesh); var material = new THREE.MeshBasicMaterial(&#123;color: 0xffffff&#125;); var texture = THREE.ImageUtils.loadTexture(&quot;../assets/textures/ash_uvgrid01.jpg&quot;); material.map = texture; geometry.children[0].material = material; mesh = geometry; geometry.scale.set(15, 15, 15); geometry.rotation.x = -0.3; scene.add(geometry); &#125;); &#125;; &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;loadCube1&#x27;); gui.add(controls, &#x27;loadCube2&#x27;); controls.loadCube1(); function render() &#123; stats.update(); requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; loadCube1: loadCube2: 2. 复制纹理上面UV映射是指定纹理哪些部分显示到物体表面，Threejs会用选定的纹理包围整个物体表面。但是对于有些情形，你可能不想将纹理遍布整个面或整个几何体，而是让纹理进行重复(复制)。 通过material.map.wrapS 和 material.map.wrapT属性来设置纹理的包裹类型(wrapS是x轴方向纹理的行为，wrapT是y轴方向纹理的行为)： 纹理包裹类型 描述 THREE.RepeatWrapping 允许纹理重复自己 THREE.ClampToEdgeWrapping 默认值，纹理不会重复，用选择的纹理尽量包裹物体整个表面，只是在边缘的像素用重复纹理来填充剩下的空间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126&lt;!-- chapter-10-08.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Repeat mapping&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; var sphere = createMesh(new THREE.SphereGeometry(5, 20, 20), &quot;floor-wood.jpg&quot;); scene.add(sphere); sphere.position.x = 7; var cube = createMesh(new THREE.BoxGeometry(6, 6, 6), &quot;brick-wall.jpg&quot;); cube.position.x = -7; scene.add(cube); console.log(cube.geometry.faceVertexUvs); camera.position.x = 00; camera.position.y = 12; camera.position.z = 20; camera.lookAt(new THREE.Vector3(0, 0, 0)); var ambiLight = new THREE.AmbientLight(0x141414); scene.add(ambiLight); var light = new THREE.DirectionalLight(); light.position.set(0, 30, 20); scene.add(light); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var controls = new function () &#123; this.repeatX = 1; this.repeatY = 1; this.repeatWrapping = true; // 更新纹理重复方式 this.updateRepeat = function (e) &#123; // 设置重复纹理在x/y轴方向多久重复1次，值为1则不重复，大于1开始重复，小于1纹理被放大，负数则会产生一个纹理镜像 cube.material.map.repeat.set(controls.repeatX, controls.repeatY); sphere.material.map.repeat.set(controls.repeatX, controls.repeatY); if (controls.repeatWrapping) &#123; // 使用纹理重复 cube.material.map.wrapS = THREE.RepeatWrapping; cube.material.map.wrapT = THREE.RepeatWrapping; sphere.material.map.wrapS = THREE.RepeatWrapping; sphere.material.map.wrapT = THREE.RepeatWrapping; &#125; else &#123; // 不使用纹理重复 cube.material.map.wrapS = THREE.ClampToEdgeWrapping; cube.material.map.wrapT = THREE.ClampToEdgeWrapping; sphere.material.map.wrapS = THREE.ClampToEdgeWrapping; sphere.material.map.wrapT = THREE.ClampToEdgeWrapping; &#125; cube.material.map.needsUpdate = true; sphere.material.map.needsUpdate = true; &#125; &#125;; var gui = new dat.GUI(); gui.add(controls, &quot;repeatX&quot;, -4, 4).onChange(controls.updateRepeat); gui.add(controls, &quot;repeatY&quot;, -4, 4).onChange(controls.updateRepeat); gui.add(controls, &quot;repeatWrapping&quot;).onChange(controls.updateRepeat); function createMesh(geom, texture) &#123; var texture = THREE.ImageUtils.loadTexture(&quot;../assets/textures/general/&quot; + texture); texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping; geom.computeVertexNormals(); var mat = new THREE.MeshPhongMaterial(); mat.map = texture; var mesh = new THREE.Mesh(geom, mat); return mesh; &#125; var step = 0; function render() &#123; stats.update(); step += 0.01; cube.rotation.y = step; cube.rotation.x = step; sphere.rotation.y = step; sphere.rotation.x = step; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3. 在画布上绘制图案并作为纹理前面我们都是加载本地静态图片作为纹理，其实Threejs也支持将HTML5的画布作为纹理使用。 下面示例我们将用Literally库(http://literallycanvas.com) ，来创建一个交互式的画布。在画布上你可以进行绘图，它可以作为纹理实时显示到网格对象上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;!-- chapter-10-09.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Canvas texture&lt;/title&gt; &lt;link href=&quot;../libs/literally/css/literally.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/perlin.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/literally/jquery-1.8.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/literally/underscore-1.4.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/literally/js/literallycanvas.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; &#125; .fs-container &#123; width: 300px; height: 300px; margin: auto; bottom: 20px; position: absolute; x: 0; y: 0; &quot; &#125; #canvas-output &#123; width: 300px; height: 300px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div class=&quot;fs-container&quot;&gt; &lt;div id=&quot;canvas-output&quot; style=&quot;float:left&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var canvas = document.createElement(&quot;canvas&quot;); document.getElementById(&#x27;canvas-output&#x27;).appendChild(canvas); $(&#x27;#canvas-output&#x27;).literallycanvas(&#123;imageURLPrefix: &#x27;../libs/literally/img&#x27;&#125;); // 使用Literally库的literallycanvas创建绘图工具 function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xbbbbbb, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; var cube = createMesh(new THREE.BoxGeometry(10, 10, 10)); cube.position.x = 0; scene.add(cube); camera.position.x = 00; camera.position.y = 12; camera.position.z = 28; camera.lookAt(new THREE.Vector3(0, 0, 0)); var ambiLight = new THREE.AmbientLight(0x141414); scene.add(ambiLight); var light = new THREE.DirectionalLight(); light.position.set(0, 30, 20); scene.add(light); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); function createMesh(geom) &#123; var canvasMap = new THREE.Texture(canvas); // 将画布转为纹理对象 var mat = new THREE.MeshPhongMaterial(); mat.map = canvasMap; // 使用画布纹理 var mesh = new THREE.Mesh(geom, mat); return mesh; &#125; function render() &#123; stats.update(); cube.rotation.y += 0.01; cube.rotation.x += 0.01; cube.material.map.needsUpdate = true; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4. 将视频输出作为纹理Threejs也支持将HTML5的视频元素作为纹理输出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;!-- chapter-10-10.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Video texture - non canvas&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;video id=&quot;video&quot; style=&quot;display: none; position: absolute; left: 15px; top: 75px;&quot; src=&quot;../assets/movies/Big_Buck_Bunny_small.ogv&quot; controls=&quot;true&quot; autoplay=&quot;true&quot;&gt;&lt;/video&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var texture; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; var video = document.getElementById(&#x27;video&#x27;); texture = new THREE.VideoTexture(video); // 将视频元素作为纹理输出 var cube = createMesh(new THREE.BoxGeometry(20, 10, 10)); cube.position.y = 2; scene.add(cube); camera.position.x = 00; camera.position.y = 1; camera.position.z = 28; camera.lookAt(new THREE.Vector3(0, 0, 0)); var ambiLight = new THREE.AmbientLight(0x141414); scene.add(ambiLight); var light = new THREE.DirectionalLight(); light.position.set(0, 30, 20); scene.add(light); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var controls = new function () &#123; this.rotate = false; &#125;; var gui = new dat.GUI(); gui.add(controls, &quot;rotate&quot;); function createMesh(geom) &#123; var materialArray = []; materialArray.push(new THREE.MeshBasicMaterial(&#123;color: 0x0051ba&#125;)); materialArray.push(new THREE.MeshBasicMaterial(&#123;color: 0x0051ba&#125;)); materialArray.push(new THREE.MeshBasicMaterial(&#123;color: 0x0051ba&#125;)); materialArray.push(new THREE.MeshBasicMaterial(&#123;color: 0x0051ba&#125;)); materialArray.push(new THREE.MeshBasicMaterial(&#123;map: texture&#125;)); // 这个面使用视频纹理 materialArray.push(new THREE.MeshBasicMaterial(&#123;color: 0xff51ba&#125;)); var faceMaterial = new THREE.MeshFaceMaterial(materialArray); var mesh = new THREE.Mesh(geom, faceMaterial); return mesh; &#125; function render() &#123; stats.update(); if (controls.rotate) &#123; cube.rotation.x += -0.01; cube.rotation.y += -0.01; cube.rotation.z += -0.01; &#125; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/categories/threejs/"}],"tags":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/tags/threejs/"},{"name":"纹理","slug":"纹理","permalink":"https://cxx001.gitee.io/tags/%E7%BA%B9%E7%90%86/"}],"keywords":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/categories/threejs/"}]},{"title":"threejs动画","slug":"threejs/threejs动画","date":"2023-02-10T13:42:55.000Z","updated":"2023-03-14T05:41:58.934Z","comments":true,"path":"2023/02/10/threejs/threejs动画/","link":"","permalink":"https://cxx001.gitee.io/2023/02/10/threejs/threejs%E5%8A%A8%E7%94%BB/","excerpt":"","text":"前面我们所用的模型大都是静态的，没有动画，没有生命。这节我们将赋予它们生命。 动画本质是通过改变物体的旋转、缩放、位置、材质、顶点、面以及其它你所能想到的属性来实现的。这些其实在前面章节示例里或多或少已经使用了。 一、选择对象在写示例前我们先了解一个重要操作，如何通过鼠标选中场景中的对象。 当我们在屏幕上点击鼠标时，会发生如下事情： 首先，基于屏幕上点击位置会创建一个THREE.Vecor3向量。 接着，使用vector.unproject方法将屏幕上的点击位置转换成Threejs场景中的坐标。 然后，创建THREE.Raycaster。使用它可以向场景中发射光线。 最后，我们使用raycaster.intersectObjects方法来判断指定的对象中哪些被该光线照射到了。其结果包含了所有被照射到的对象的信息，这些信息包括： 12345distance: 50.66666666666 // 从摄像机到被点击对象的距离face: THREE.Face3 // 那个面被点击了faceIndex: 6 // 被点击面的下标object: THREE.Mesh // 被点击的网格对象point: THREE.Vector3 // 网格对象上哪个点被点击了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;!-- chapter-09-01.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Selecting objects&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/Projector.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var renderer = new THREE.WebGLRenderer(); renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); renderer.setSize(window.innerWidth, window.innerHeight); var planeGeometry = new THREE.PlaneGeometry(60, 20, 1, 1); var planeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xffffff&#125;); var plane = new THREE.Mesh(planeGeometry, planeMaterial); plane.rotation.x = -0.5 * Math.PI; plane.position.x = 15; plane.position.y = 0; plane.position.z = 0; scene.add(plane); var cubeGeometry = new THREE.BoxGeometry(4, 4, 4); var cubeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xff0000&#125;); var cube = new THREE.Mesh(cubeGeometry, cubeMaterial); cube.position.x = -9; cube.position.y = 3; cube.position.z = 0; scene.add(cube); var sphereGeometry = new THREE.SphereGeometry(4, 20, 20); var sphereMaterial = new THREE.MeshLambertMaterial(&#123;color: 0x7777ff&#125;); var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial); sphere.position.x = 20; sphere.position.y = 0; sphere.position.z = 2; scene.add(sphere); var cylinderGeometry = new THREE.CylinderGeometry(2, 2, 20); var cylinderMaterial = new THREE.MeshLambertMaterial(&#123;color: 0x77ff77&#125;); var cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial); cylinder.position.set(0, 0, 1); scene.add(cylinder); camera.position.x = -30; camera.position.y = 40; camera.position.z = 30; camera.lookAt(scene.position); var ambientLight = new THREE.AmbientLight(0x0c0c0c); scene.add(ambientLight); var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(-40, 60, -10); scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(renderer.domElement); var tube; var controls = new function () &#123; this.showRay = false; &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;showRay&#x27;).onChange(function (e) &#123; if (tube) scene.remove(tube) &#125;); function render() &#123; stats.update(); renderer.render(scene, camera); requestAnimationFrame(render); &#125; render(); // 监控鼠标按下和鼠标移动事件 document.addEventListener(&#x27;mousedown&#x27;, onDocumentMouseDown, false); document.addEventListener(&#x27;mousemove&#x27;, onDocumentMouseMove, false); function onDocumentMouseDown(event) &#123; // 1.鼠标点击位置 var vector = new THREE.Vector3(( event.clientX / window.innerWidth ) * 2 - 1, -( event.clientY / window.innerHeight ) * 2 + 1, 0.5); // 2.把鼠标点击位置转换为threejs场景中的坐标 vector = vector.unproject(camera); // 3.从摄像机位置向点击位置发射一条光线 var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize()); // 4. 获取指定数组里对象哪些被光线照射到了 var intersects = raycaster.intersectObjects([sphere, cylinder, cube]); if (intersects.length &gt; 0) &#123; console.log(intersects[0]); intersects[0].object.material.transparent = true; intersects[0].object.material.opacity = 0.5; &#125; &#125; function onDocumentMouseMove(event) &#123; // 是否显示HREE.Raycaster射线 if (controls.showRay) &#123; var vector = new THREE.Vector3(( event.clientX / window.innerWidth ) * 2 - 1, -( event.clientY / window.innerHeight ) * 2 + 1, 0.5); vector = vector.unproject(camera); var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize()); var intersects = raycaster.intersectObjects([sphere, cylinder, cube]); if (intersects.length &gt; 0) &#123; var points = []; points.push(new THREE.Vector3(-30, 39.8, 30)); points.push(intersects[0].point); var mat = new THREE.MeshBasicMaterial(&#123;color: 0xff0000, transparent: true, opacity: 0.6&#125;); var tubeGeometry = new THREE.TubeGeometry(new THREE.SplineCurve3(points), 60, 0.001); if (tube) scene.remove(tube); tube = new THREE.Mesh(tubeGeometry, mat); scene.add(tube); &#125; &#125; &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 下面回归正题，我们重新回到动画上来。 二、使用Tween.js实现动画Tween.js是一个轻量级的javascript库 https://github.com/tweenjs/tween.js，通过这个库可以很容易实现某个属性在两个值之间进行过渡，我们称这种为补间动画。官方提供了很多示例，自行去查看。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;!-- chapter-09-02.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Animation tween &lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/ColladaLoader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/tween.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xcccccc, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; camera.position.x = 150; camera.position.y = 150; camera.position.z = 150; camera.lookAt(new THREE.Vector3(0, 20, 0)); var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(150, 150, 150); spotLight.intensity = 2; scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var mesh; var loader = new THREE.ColladaLoader(); loader.load(&quot;../assets/models/dae/Truck_dae.dae&quot;, function (result) &#123; mesh = result.scene.children[0].children[0].clone(); //mesh.scale.set(4, 4, 4); scene.add(mesh); // 补间动画要在模型加载完后才能开始 tween.start(); &#125;); // 使用补间动画, 在y轴上下缓动移动 // http://sole.github.io/tween.js/examples/03_graphs.html var posSrc = &#123;pos: 10&#125;; var tween = new TWEEN.Tween(posSrc).to(&#123;pos: 0&#125;, 1000); tween.easing(TWEEN.Easing.Sinusoidal.InOut); var tweenBack = new TWEEN.Tween(posSrc).to(&#123;pos: 10&#125;, 1000); tweenBack.easing(TWEEN.Easing.Sinusoidal.InOut); // 衔接两个动作，循环执行 tween.chain(tweenBack); tweenBack.chain(tween); // 执行后坐标更新 var onUpdate = function () &#123; var pos = this.pos; mesh.position.y = pos; &#125;; tween.onUpdate(onUpdate); tweenBack.onUpdate(onUpdate); function render() &#123; stats.update(); // 更新补间动画 TWEEN.update(); requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 三、使用摄像机实现动画前面我们已经接触过了，可以通过移动摄像机的位置让整个场景动起来，我们是通过手动改变摄像机位置实现的。Threejs还提供了其它更新摄像机的控件，下面我们依次看看。 最常用的： 其它的本节不会介绍，使用和上面一样，了解下： 1. 轨迹球控制器下面是使用这个控制器，通过鼠标左键拖动、滚轮、右键拖动分别实现场景的旋转、缩放、平移的示例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;!-- chapter-09-03.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Trackball controls &lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/OBJLoader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/MTLLoader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/OBJMTLLoader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/chroma.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/TrackballControls.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0x000, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; camera.position.x = 100; camera.position.y = 100; camera.position.z = 300; camera.lookAt(new THREE.Vector3(0, 0, 0)); var ambientLight = new THREE.AmbientLight(0x383838); scene.add(ambientLight); var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(300, 300, 300); spotLight.intensity = 1; scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); // 创建轨迹球控制器，并绑定摄像机 var trackballControls = new THREE.TrackballControls(camera); // 想要全面了解这些属性可以参考rackballControls.js源文件 trackballControls.rotateSpeed = 1.0; trackballControls.zoomSpeed = 1.0; trackballControls.panSpeed = 1.0; //trackballControls.noZoom=false; //trackballControls.noPan=false; trackballControls.staticMoving = true; //trackballControls.dynamicDampingFactor=0.3; // 加载OBJ/MTL模型 var mesh; var loader = new THREE.OBJMTLLoader(); var texture = THREE.ImageUtils.loadTexture(&#x27;../assets/textures/Metro01.JPG&#x27;); //texture.wrapS = texture.wrapT = THREE.MirroredRepeatWrapping; loader.load(&#x27;../assets/models/city.obj&#x27;, &#x27;../assets/models/city.mtl&#x27;, function (object) &#123; var scale = chroma.scale([&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]); setRandomColors(object, scale); mesh = object; scene.add(mesh); &#125;); //texture.repeat.set( 1 , 1); function setRandomColors(object, scale) &#123; var children = object.children; if (children &amp;&amp; children.length &gt; 0) &#123; children.forEach(function (e) &#123; setRandomColors(e, scale) &#125;); &#125; else &#123; if (object instanceof THREE.Mesh) &#123; object.material.color = new THREE.Color(scale(Math.random()).hex()); if (object.material.name.indexOf(&quot;building&quot;) == 0) &#123; object.material.emissive = new THREE.Color(0x444444); object.material.transparent = true; object.material.opacity = 0.8; &#125; &#125; &#125; &#125; var clock = new THREE.Clock(); function render() &#123; stats.update(); var delta = clock.getDelta(); trackballControls.update(delta); // delta距离上次调用时间间隔 requestAnimationFrame(render); webGLRenderer.render(scene, camera) &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2. 飞行控制器可行像飞行视角一样在场景中飞行。 123456789101112131415161718// 创建飞行控制器var flyControls = new THREE.FlyControls(camera);flyControls.movementSpeed = 25;flyControls.domElement = document.querySelector(&quot;#WebGL-output&quot;);flyControls.rollSpeed = Math.PI / 24;flyControls.autoForward = true;flyControls.dragToLook = false;// 更新var clock = new THREE.Clock();function render() &#123; var delta = clock.getDelta(); flyControls.update(delta); webGLRenderer.clear(); requestAnimationFrame(render); webGLRenderer.render(scene, camera)&#125; 3. 翻滚控制器翻滚场景(Q&#x2F;E 左&#x2F;右翻滚)。 12345678910111213141516// 创建翻滚控制器var rollControls = new THREE.RollControls(camera);rollControls.movementSpeed = 25;rollControls.lookSpeed = 3;// 更新var clock = new THREE.Clock();function render() &#123; var delta = clock.getDelta(); rollControls.update(delta); webGLRenderer.clear(); requestAnimationFrame(render); webGLRenderer.render(scene, camera)&#125; 4. 第一视角控制器类似第一视角射击游戏那样控制摄像机。鼠标用于控制视角，键盘用于控制角色移动。 12345678910111213141516171819202122// 创建第一视角控制器var camControls = new THREE.FirstPersonControls(camera);camControls.lookSpeed = 0.4;camControls.movementSpeed = 20;camControls.noFly = true;camControls.lookVertical = true;camControls.constrainVertical = true;camControls.verticalMin = 1.0;camControls.verticalMax = 2.0;camControls.lon = -150;camControls.lat = 120;// 更新var clock = new THREE.Clock();function render() &#123; var delta = clock.getDelta(); rollControls.update(delta); webGLRenderer.clear(); requestAnimationFrame(render); webGLRenderer.render(scene, camera)&#125; 5. 轨道控制器和轨迹控制器类似，只是轨道控制器强制摄像头 up方向，而轨迹控制器允许相机倒置旋转。可以用于控制场景中的对象围绕场景中心旋转和平移。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;!-- chapter-09-04.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Orbit controls&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/OrbitControls.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0x000, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; // 创建球体网格对象 var sphere = createMesh(new THREE.SphereGeometry(20, 40, 40)); scene.add(sphere); camera.position.x = -20; camera.position.y = 30; camera.position.z = 40; camera.lookAt(new THREE.Vector3(00, 0, 0)); var ambiLight = new THREE.AmbientLight(0x111111); scene.add(ambiLight); var spotLight = new THREE.DirectionalLight(0xffffff); spotLight.position.set(-20, 30, 40); spotLight.intensity = 1.5; scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); // 使用外部纹理材质创建球体网格 function createMesh(geom) &#123; var planetTexture = THREE.ImageUtils.loadTexture(&quot;../assets/textures/planets/mars_1k_color.jpg&quot;); var normalTexture = THREE.ImageUtils.loadTexture(&quot;../assets/textures/planets/mars_1k_normal.jpg&quot;); // 加载外部图片纹理创建Phong材质 var planetMaterial = new THREE.MeshPhongMaterial(&#123;map: planetTexture, bumpMap: normalTexture&#125;); var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [planetMaterial]); return mesh; &#125; // 创建轨道控制器 var orbitControls = new THREE.OrbitControls(camera); orbitControls.autoRotate = true; var clock = new THREE.Clock(); function render() &#123; stats.update(); var delta = clock.getDelta(); orbitControls.update(delta); requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 四、高级动画1. 关键帧动画就是从动画开始到动画结束之间所有的顶点数据都会被存储下来，你需要做的就是定义好关键位置，并重复该过程。这种主要一个缺点就是对于大型网格和大型动画，模型文件会变得非常大。 Threejs库提供的使用关键字动画对象：THREE.MorphAnimMesh。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147&lt;!-- chapter-09-05.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Working with morph targets&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; camera.position.x = 250; camera.position.y = 250; camera.position.z = 350; camera.lookAt(new THREE.Vector3(100, 50, 0)); var spotLight = new THREE.DirectionalLight(0xffffff); spotLight.position.set(300, 200, 300); spotLight.intensity = 1; scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var controls = new function () &#123; this.keyframe = 0; // 关键帧位置 &#125;; var gui = new dat.GUI(); gui.add(controls, &quot;keyframe&quot;, 0, 15).step(1).onChange(function (e) &#123; showFrame(e); &#125;); var meshAnim; var frames = []; var currentMesh; var loader = new THREE.JSONLoader(); // 1. 加载帧动画模型 loader.load(&#x27;../assets/models/horse.js&#x27;, function (geometry, mat) &#123; // 创建左边静态马网格 var mat = new THREE.MeshLambertMaterial( &#123; morphTargets: true, // 设置为true网格才会动 vertexColors: THREE.FaceColors &#125;); var mesh = new THREE.Mesh(geometry, mat); mesh.position.x = -100; frames.push(mesh); currentMesh = mesh; morphColorsToFaceColors(geometry); // 修改各面颜色 // 创建动画所有关键帧网格 var mat2 = new THREE.MeshLambertMaterial( &#123;color: 0xffffff, vertexColors: THREE.FaceColors&#125;); // 遍历动画所有帧，并创建为网格对象添加到frames数值中 mesh.geometry.morphTargets.forEach(function (e) &#123; var geom = new THREE.Geometry(); geom.vertices = e.vertices; geom.faces = geometry.faces; var morpMesh = new THREE.Mesh(geom, mat2); frames.push(morpMesh); morpMesh.position.x = -100; &#125;); // 确保运动时光照、阴影和颜色的准确性 geometry.computeVertexNormals(); geometry.computeFaceNormals(); geometry.computeMorphNormals(); // 2. THREE.MorphAnimMesh创建帧动画网格，右边运动马 meshAnim = new THREE.MorphAnimMesh(geometry, mat); meshAnim.duration = 1000; meshAnim.position.x = 200; meshAnim.position.z = 0; scene.add(meshAnim); // 用第一帧创建右边的静态马 showFrame(0); &#125;, &#x27;../assets/models&#x27;); // 手的改变帧播放 function showFrame(idx) &#123; scene.remove(currentMesh); scene.add(frames[idx]); currentMesh = frames[idx]; console.log(currentMesh); &#125; function morphColorsToFaceColors(geometry) &#123; if (geometry.morphColors &amp;&amp; geometry.morphColors.length) &#123; var colorMap = geometry.morphColors[0]; for (var i = 0; i &lt; colorMap.colors.length; i++) &#123; geometry.faces[i].color = colorMap.colors[i]; geometry.faces[i].color.offsetHSL(0, 0.3, 0); &#125; &#125; &#125; var clock = new THREE.Clock(); function render() &#123; stats.update(); var delta = clock.getDelta(); webGLRenderer.clear(); if (meshAnim) &#123; // 3. 帧动画更新 meshAnim.updateAnimation(delta * 1000); meshAnim.rotation.y += 0.01; &#125; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2. 骨骼动画就是定义好网格的骨骼，并将顶点绑定到特定的骨骼上。当骨骼运动时，相连骨骼也会随着一起变换，同时骨骼上绑定的顶点也会随之移动。 Threejs库提供的创建骨骼网格的对象：THREE.SkinnedMesh。下面是一个手动变换骨骼对象的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;!-- chapter-09-06.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Load blender model &lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/tween.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; camera.position.x = 0; camera.position.y = 0; camera.position.z = 4; camera.lookAt(new THREE.Vector3(0, 0, 0)); var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(0, 50, 30); spotLight.intensity = 2; scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var mesh; var loader = new THREE.JSONLoader(); // 1. 加载Blender导出的骨骼模型 loader.load(&#x27;../assets/models/hand-1.js&#x27;, function (geometry, mat) &#123; var mat = new THREE.MeshLambertMaterial(&#123;color: 0xF0C8C9, skinning: true&#125;); // skinning要设置为true，否则骨骼不会动 // 2. 创建骨骼模型网格 mesh = new THREE.SkinnedMesh(geometry, mat); mesh.rotation.x = 0.5 * Math.PI; mesh.rotation.z = 0.7 * Math.PI; scene.add(mesh); // 开始运行 tween.start(); &#125;, &#x27;../assets/models&#x27;); // 3. 手动改变骨骼变换 var onUpdate = function () &#123; var pos = this.pos; console.log(mesh.skeleton); mesh.skeleton.bones[5].rotation.set(0, 0, pos); mesh.skeleton.bones[6].rotation.set(0, 0, pos); mesh.skeleton.bones[10].rotation.set(0, 0, pos); mesh.skeleton.bones[11].rotation.set(0, 0, pos); mesh.skeleton.bones[15].rotation.set(0, 0, pos); mesh.skeleton.bones[16].rotation.set(0, 0, pos); mesh.skeleton.bones[20].rotation.set(0, 0, pos); mesh.skeleton.bones[21].rotation.set(0, 0, pos); mesh.skeleton.bones[1].rotation.set(pos, 0, 0); &#125;; var tween = new TWEEN.Tween(&#123;pos: -1&#125;) .to(&#123;pos: 0&#125;, 3000) .easing(TWEEN.Easing.Cubic.InOut) // 缓动 .yoyo(true) // 设置为true，使得动画运动完后反着运行 .repeat(Infinity) // 重复运行 .onUpdate(onUpdate); var clock = new THREE.Clock(); function render() &#123; stats.update(); TWEEN.update(); var delta = clock.getDelta(); requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 五、使用外部模型创建动画1. 使用Blender创建骨骼动画 Blender使用threejs导出器，把.blend动画导出为.json，然后加载并播放动画。 播放外部骨骼动画使用：THREE.Animation。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;!-- chapter-09-07.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Animation from blender&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; camera.position.x = 0; camera.position.y = 0; camera.position.z = 4; camera.lookAt(new THREE.Vector3(0, 0, 0)); var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(0, 50, 30); spotLight.intensity = 2; scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var mesh; var helper; var controls = new function () &#123; this.showHelper = false; // 是否显示骨骼骨架 &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;showHelper&#x27;).onChange(function (state) &#123; helper.visible = state; &#125;); var loader = new THREE.JSONLoader(); // 加载骨骼动画模型 loader.load(&#x27;../assets/models/hand-2.js&#x27;, function (model, mat) &#123; var mat = new THREE.MeshLambertMaterial(&#123;color: 0xF0C8C9, skinning: true&#125;); mesh = new THREE.SkinnedMesh(model, mat); mesh.rotation.x = 0.5 * Math.PI; mesh.rotation.z = 0.7 * Math.PI; scene.add(mesh); // 创建骨骼动画对象，并开始播放 var animation = new THREE.Animation(mesh, model.animation); animation.play(); // 创建骨骼骨架 helper = new THREE.SkeletonHelper(mesh); helper.material.linewidth = 2; helper.visible = false; scene.add(helper); &#125;, &#x27;../assets/models&#x27;); var clock = new THREE.Clock(); function render() &#123; stats.update(); var delta = clock.getDelta(); if (mesh) &#123; // 更新骨骼动画 helper.update(); THREE.AnimationHandler.update(delta); &#125; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2. 从Collada模型加载动画使用方式和上面一样，只是加载模型文件格式变了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;!-- chapter-09-08.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Animation from collada&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/ColladaLoader.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; camera.position.x = 400; camera.position.y = 50; camera.position.z = 150; camera.lookAt(new THREE.Vector3(0, 0, 0)); var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(300, 500, 100); spotLight.intensity = 3; scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var meshAnim; // 加载.dae模型 var loader = new THREE.ColladaLoader(); loader.load(&#x27;../assets/models/monster.dae&#x27;, function (collada) &#123; // 模型第一帧网格添加进场景 var child = collada.skins[0]; scene.add(child); child.scale.set(0.15, 0.15, 0.15); child.rotation.x = -0.5 * Math.PI; child.position.x = -100; child.position.y = -60; // 创建动画并开始播放 var animation = new THREE.Animation(child, child.geometry.animation); animation.play(); &#125;); var clock = new THREE.Clock(); function render() &#123; stats.update(); var delta = clock.getDelta(); // 动画更新 THREE.AnimationHandler.update(delta); requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3. 其它整的来说动画就两类：帧动画和骨骼动画，使用方法都差不多。其它动画文件格式加载和使用可以查看官方示例。","categories":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/categories/threejs/"}],"tags":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/tags/threejs/"},{"name":"动画","slug":"动画","permalink":"https://cxx001.gitee.io/tags/%E5%8A%A8%E7%94%BB/"}],"keywords":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/categories/threejs/"}]},{"title":"threejs使用外部模型","slug":"threejs/threejs使用外部模型","date":"2023-02-09T07:48:55.000Z","updated":"2023-03-14T05:40:31.502Z","comments":true,"path":"2023/02/09/threejs/threejs使用外部模型/","link":"","permalink":"https://cxx001.gitee.io/2023/02/09/threejs/threejs%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"前面我们都是用Threejs提供的几何体来创建网格，对于简单几何体(如球体和方块)来说非常有效，但当你想要创建复杂的三维模型时，这不是最好的方法。通常情况下，你可以使用三维建模工具（如Blender和3D Studio Max）来创建复杂几何体。 本节就来学习如何加载和展示由这些三维建模工具所创建的模型。 网格对象组合与合并在学习使用外部三维建模工具所创建的模型前，我们先了解两个基本操作：将对象组合在一起，以及将多个网格合并为一个网格。 1. 网格组合这个不是什么新东西了，前面我们很多示例其实早就使用了。就是把多个网格对象添加到一个对象里(THREE.Group)，对这1个对象移动、缩放、旋转变换操作其子对象会一起变换。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179&lt;!-- chapter-08-01.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Group&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; camera.position.x = 30; camera.position.y = 30; camera.position.z = 30; camera.lookAt(new THREE.Vector3(0, 0, 0)); var ground = new THREE.PlaneGeometry(100, 100, 50, 50); var groundMesh = THREE.SceneUtils.createMultiMaterialObject(ground, [new THREE.MeshBasicMaterial(&#123;wireframe: true, overdraw: true, color: 000000&#125;), new THREE.MeshBasicMaterial(&#123;color: 0x00ff00, transparent: true, opacity: 0.5&#125; ) ]); groundMesh.rotation.x = -0.5 * Math.PI; scene.add(groundMesh); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var step = 0.03; var sphere; var cube; var group; var controls = new function () &#123; this.cubePosX = 0; this.cubePosY = 3; this.cubePosZ = 10; this.spherePosX = 10; this.spherePosY = 5; this.spherePosZ = 0; this.groupPosX = 10; this.groupPosY = 5; this.groupPosZ = 0; this.grouping = false; this.rotate = false; this.groupScale = 1; this.cubeScale = 1; this.sphereScale = 1; this.redraw = function () &#123; scene.remove(group); sphere = createMesh(new THREE.SphereGeometry(5, 10, 10)); cube = createMesh(new THREE.BoxGeometry(6, 6, 6)); sphere.position.set(controls.spherePosX, controls.spherePosY, controls.spherePosZ); cube.position.set(controls.cubePosX, controls.cubePosY, controls.cubePosZ); // 将球体和立方体网格添加到组合对象中 group = new THREE.Group(); group.add(sphere); group.add(cube); scene.add(group); // 在group组合对象中心位置标志一个箭头 var arrow = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), group.position, 10, 0x0000ff); scene.add(arrow); &#125;; &#125;; var gui = new dat.GUI(); var sphereFolder = gui.addFolder(&quot;sphere&quot;); sphereFolder.add(controls, &quot;spherePosX&quot;, -20, 20).onChange(function (e) &#123; sphere.position.x = e; &#125;); sphereFolder.add(controls, &quot;spherePosZ&quot;, -20, 20).onChange(function (e) &#123; sphere.position.z = e; &#125;); sphereFolder.add(controls, &quot;spherePosY&quot;, -20, 20).onChange(function (e) &#123; sphere.position.y = e; &#125;); sphereFolder.add(controls, &quot;sphereScale&quot;, 0, 3).onChange(function (e) &#123; sphere.scale.set(e, e, e); &#125;); var cubeFolder = gui.addFolder(&quot;cube&quot;); cubeFolder.add(controls, &quot;cubePosX&quot;, -20, 20).onChange(function (e) &#123; cube.position.x = e; &#125;); cubeFolder.add(controls, &quot;cubePosZ&quot;, -20, 20).onChange(function (e) &#123; cube.position.z = e; &#125;); cubeFolder.add(controls, &quot;cubePosY&quot;, -20, 20).onChange(function (e) &#123; cube.position.y = e; &#125;); cubeFolder.add(controls, &quot;cubeScale&quot;, 0, 3).onChange(function (e) &#123; cube.scale.set(e, e, e); &#125;); var cubeFolder = gui.addFolder(&quot;group&quot;); cubeFolder.add(controls, &quot;groupPosX&quot;, -20, 20).onChange(function (e) &#123; group.position.x = e; &#125;); cubeFolder.add(controls, &quot;groupPosZ&quot;, -20, 20).onChange(function (e) &#123; group.position.z = e; &#125;); cubeFolder.add(controls, &quot;groupPosY&quot;, -20, 20).onChange(function (e) &#123; group.position.y = e; &#125;); cubeFolder.add(controls, &quot;groupScale&quot;, 0, 3).onChange(function (e) &#123; group.scale.set(e, e, e); &#125;); gui.add(controls, &quot;grouping&quot;); gui.add(controls, &quot;rotate&quot;); controls.redraw(); render(); function createMesh(geom) &#123; var meshMaterial = new THREE.MeshNormalMaterial(); meshMaterial.side = THREE.DoubleSide; var wireFrameMat = new THREE.MeshBasicMaterial(); wireFrameMat.wireframe = true; var plane = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMat]); return plane; &#125; function render() &#123; stats.update(); if (controls.grouping &amp;&amp; controls.rotate) &#123; group.rotation.y += step; &#125; if (controls.rotate &amp;&amp; !controls.grouping) &#123; sphere.rotation.y += step; cube.rotation.y += step; &#125; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125;; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2. 网格合并通过THREE.Geometry.merge()函数可以将多个网格对象合并成一个。如果场景中网格太多是有性能瓶颈的，合并它们可以提升渲染效率。但是注意合并后你就不能再单独操作某个网格了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;!-- chapter-08-02.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Merge objects&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 500); var renderer = new THREE.WebGLRenderer(); renderer.setClearColor(new THREE.Color(0x00000, 1.0)); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMapEnabled = true; camera.position.x = 0; camera.position.y = 40; camera.position.z = 50; camera.lookAt(scene.position); document.getElementById(&quot;WebGL-output&quot;).appendChild(renderer.domElement); var step = 0; var cubeMaterial = new THREE.MeshNormalMaterial(&#123;color: 0x00ff00, transparent: true, opacity: 0.5&#125;); var controls = new function () &#123; this.combined = false; this.numberOfObjects = 500; this.redraw = function () &#123; var toRemove = []; // traverse遍历场景对象是不能增、删操作 scene.traverse(function (e) &#123; if (e instanceof THREE.Mesh) toRemove.push(e); &#125;); toRemove.forEach(function (e) &#123; scene.remove(e) &#125;); if (controls.combined) &#123; // 将所有网格对象合并到geometry一个对象中 var geometry = new THREE.Geometry(); for (var i = 0; i &lt; controls.numberOfObjects; i++) &#123; var cubeMesh = addCube(); cubeMesh.updateMatrix(); // 变换矩阵，保证合并后正确定位和旋转 geometry.merge(cubeMesh.geometry, cubeMesh.matrix); // 添加合并网格 &#125; scene.add(new THREE.Mesh(geometry, cubeMaterial)); &#125; else &#123; // 不合并，网格对象一个个添加到场景中 for (var i = 0; i &lt; controls.numberOfObjects; i++) &#123; scene.add(addCube()); &#125; &#125; &#125;; &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;numberOfObjects&#x27;, 0, 20000); gui.add(controls, &#x27;combined&#x27;).onChange(controls.redraw); gui.add(controls, &#x27;redraw&#x27;); controls.redraw(); render(); // 添加立方体 function addCube() &#123; var cubeSize = 1.0; var cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize); var cube = new THREE.Mesh(cubeGeometry, cubeMaterial); cube.position.x = -60 + Math.round((Math.random() * 100)); cube.position.y = Math.round((Math.random() * 10)); cube.position.z = -150 + Math.round((Math.random() * 175)); return cube; &#125; var rotation = 0; function render() &#123; rotation += 0.005; stats.update(); camera.position.x = Math.sin(rotation) * 50; camera.position.z = Math.cos(rotation) * 50; camera.lookAt(scene.position); requestAnimationFrame(render); renderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 创建2W个网格直接添加进场景，看帧率降到14了。 同样2W个，合并后，帧率正常了。 从外部资源加载网格threejs支持多种三维文件格式，可以读取并从中导入几何体和网格。下面是threejs支持的文件格式： 下面依次介绍这些三维文件格式在Threejs中怎么导入&#x2F;导出的。 1. 以Threejs的JSON格式保存和加载你可以在两种情形下使用Threejs的JSON文件格式：用它来保存和加载单个THREE.Mesh(网格)，或者用它来保存和加载整个场景。 保存和加载THREE.Mesh 保存：通过mesh.toJSON()可以将网格转换为json对象，后面就是js的常规保存了。 加载：Threejs提供了一个叫THREE.ObjectLoader的辅助对象，使用它可以将JSON转换成THREE.Mesh对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&lt;!-- chapter-08-03.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Save &amp; Load Mesh&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; var knot = createMesh(new THREE.TorusKnotGeometry(10, 1, 64, 8, 2, 3, 1)); scene.add(knot); camera.position.x = -30; camera.position.y = 40; camera.position.z = 50; camera.lookAt(new THREE.Vector3(-20, 0, 0)); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var loadedMesh; var controls = new function () &#123; this.radius = knot.geometry.parameters.radius; this.tube = 0.3; this.radialSegments = knot.geometry.parameters.radialSegments; this.tubularSegments = knot.geometry.parameters.tubularSegments; this.p = knot.geometry.parameters.p; this.q = knot.geometry.parameters.q; this.heightScale = knot.geometry.parameters.heightScale; this.redraw = function () &#123; scene.remove(knot); knot = createMesh(new THREE.TorusKnotGeometry(controls.radius, controls.tube, Math.round(controls.radialSegments), Math.round(controls.tubularSegments), Math.round(controls.p), Math.round(controls.q), controls.heightScale)); scene.add(knot); &#125;; // 保存 this.save = function () &#123; // 网格对象转换为JSON对象 var result = knot.toJSON(); // 调用HTML5本地保存数据接口 localStorage.setItem(&quot;json&quot;, JSON.stringify(result)); &#125;; // 加载 this.load = function () &#123; scene.remove(loadedMesh); // 调用HTML5本地读取数据接口 var json = localStorage.getItem(&quot;json&quot;); if (json) &#123; // JSON字符串转换为json对象 var loadedGeometry = JSON.parse(json); // JSON对象转换为网格对象 var loader = new THREE.ObjectLoader(); loadedMesh = loader.parse(loadedGeometry); loadedMesh.position.x -= 50; scene.add(loadedMesh); &#125; &#125; &#125;; var gui = new dat.GUI(); var ioGui = gui.addFolder(&#x27;Save &amp; Load&#x27;); ioGui.add(controls, &#x27;save&#x27;).onChange(controls.save); ioGui.add(controls, &#x27;load&#x27;).onChange(controls.load); var meshGui = gui.addFolder(&#x27;mesh&#x27;); meshGui.add(controls, &#x27;radius&#x27;, 0, 40).onChange(controls.redraw); meshGui.add(controls, &#x27;tube&#x27;, 0, 40).onChange(controls.redraw); meshGui.add(controls, &#x27;radialSegments&#x27;, 0, 400).step(1).onChange(controls.redraw); meshGui.add(controls, &#x27;tubularSegments&#x27;, 1, 20).step(1).onChange(controls.redraw); meshGui.add(controls, &#x27;p&#x27;, 1, 10).step(1).onChange(controls.redraw); meshGui.add(controls, &#x27;q&#x27;, 1, 15).step(1).onChange(controls.redraw); meshGui.add(controls, &#x27;heightScale&#x27;, 0, 5).onChange(controls.redraw); render(); function createMesh(geom) &#123; var meshMaterial = new THREE.MeshBasicMaterial(&#123; vertexColors: THREE.VertexColors, wireframe: true, wireframeLinewidth: 2, color: 0xaaaaaa &#125;); meshMaterial.side = THREE.DoubleSide; var mesh = new THREE.Mesh(geom, meshMaterial); return mesh; &#125; function render() &#123; stats.update(); knot.rotation.y += 0.01; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 保存和加载场景 使用Threejs提供的导出器和加载器: THREE.SceneExporter 、THREE.SceneLoader。也支持从URL地址加载。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;!-- chapter-08-04.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Load and save scene&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/SceneLoader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/SceneExporter.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var renderer = new THREE.WebGLRenderer(); renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); renderer.setSize(window.innerWidth, window.innerHeight); var planeGeometry = new THREE.PlaneGeometry(60, 20, 1, 1); var planeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xffffff&#125;); var plane = new THREE.Mesh(planeGeometry, planeMaterial); plane.rotation.x = -0.5 * Math.PI; plane.position.x = 15; plane.position.y = 0; plane.position.z = 0; scene.add(plane); var cubeGeometry = new THREE.BoxGeometry(4, 4, 4); var cubeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xff0000&#125;); var cube = new THREE.Mesh(cubeGeometry, cubeMaterial); cube.position.x = -4; cube.position.y = 3; cube.position.z = 0; scene.add(cube); var sphereGeometry = new THREE.SphereGeometry(4, 20, 20); var sphereMaterial = new THREE.MeshLambertMaterial(&#123;color: 0x7777ff&#125;); var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial); sphere.position.x = 20; sphere.position.y = 0; sphere.position.z = 2; scene.add(sphere); camera.position.x = -30; camera.position.y = 40; camera.position.z = 30; camera.lookAt(scene.position); var ambientLight = new THREE.AmbientLight(0x0c0c0c); scene.add(ambientLight); var spotLight = new THREE.PointLight(0xffffff); spotLight.position.set(-40, 60, -10); scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(renderer.domElement); var controls = new function () &#123; // 导出场景 this.exportScene = function () &#123; var exporter = new THREE.SceneExporter(); var sceneJson = JSON.stringify(exporter.parse(scene)); localStorage.setItem(&#x27;scene&#x27;, sceneJson); &#125;; // 清理场景 this.clearScene = function () &#123; scene = new THREE.Scene(); &#125;; // 导入场景 this.importScene = function () &#123; var json = (localStorage.getItem(&#x27;scene&#x27;)); var sceneLoader = new THREE.SceneLoader(); sceneLoader.parse(JSON.parse(json), function (e) &#123; scene = e.scene; &#125;, &#x27;.&#x27;); // 最后参数是外部纹理资源路径，这个示例没有使用外部资源，所以传入当前目录即可。 &#125; &#125;; var gui = new dat.GUI(); gui.add(controls, &quot;exportScene&quot;); gui.add(controls, &quot;clearScene&quot;); gui.add(controls, &quot;importScene&quot;); render(); function render() &#123; stats.update(); requestAnimationFrame(render); renderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2. 使用Blender导出JSON格式加载有很多三维软件可以用来创建复杂的网格。其中一个流行的开源的软件叫作Blender（www.blender.org）。 Threejs库目前已经提供了支持Blender以及Maya和3D Studio Max的导出器(插件扩展的形式)，可以直接将文件导出为Threejs的JSON格式。 注：怎么安装和使用Blender支持导出json格式的插件这里不详细介绍了，详情参考《Three.js开发指南-第八章》。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!-- chapter-08-05.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Load blender model &lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; camera.position.x = -30; camera.position.y = 40; camera.position.z = 50; camera.lookAt(new THREE.Vector3(0, 10, 0)); var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(0, 50, 30); spotLight.intensity = 2; scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var mesh; // 加载Blender导出的JSON模型文件 var loader = new THREE.JSONLoader(); /* 参数： * JSON模型文件 * 回调函数，返回几何体和材质数组 * 材质所在路径，即JSON中mapDiffuse字段图片路径 */ loader.load(&#x27;../assets/models/misc_chair01.js&#x27;, function (geometry, mat) &#123; mesh = new THREE.Mesh(geometry, mat[0]); mesh.scale.x = 15; mesh.scale.y = 15; mesh.scale.z = 15; scene.add(mesh); &#125;, &#x27;../assets/models/&#x27;); render(); function render() &#123; stats.update(); if (mesh) &#123; mesh.rotation.y += 0.02; &#125; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3. 加载OBJ&#x2F;MTL格式模型OBJ和MTL是相互配合的两种格式，经常一起使用。OBJ文件定义几何体，MTL文件定义所用材质。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!-- chapter-08-06.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Load OBJ and MTL &lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/OBJLoader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/MTLLoader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/OBJMTLLoader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xaaaaff, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; camera.position.x = -30; camera.position.y = 40; camera.position.z = 50; camera.lookAt(new THREE.Vector3(0, 10, 0)); var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(0, 40, 30); spotLight.intensity = 2; scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var mesh; // 加载OBJ/MTL格式 var loader = new THREE.OBJMTLLoader(); loader.load(&#x27;../assets/models/butterfly.obj&#x27;, &#x27;../assets/models/butterfly.mtl&#x27;, function (object) &#123; // 对加载的网格模型材质属性微调 var wing1 = object.children[4].children[0]; var wing2 = object.children[5].children[0]; wing1.material.opacity = 0.6; wing1.material.transparent = true; wing1.material.depthTest = false; wing1.material.side = THREE.DoubleSide; wing2.material.opacity = 0.6; wing2.material.depthTest = false; wing2.material.transparent = true; wing2.material.side = THREE.DoubleSide; object.scale.set(140, 140, 140); mesh = object; scene.add(mesh); object.rotation.x = 0.2; object.rotation.y = -1.3; &#125;); render(); function render() &#123; stats.update(); if (mesh) &#123; mesh.rotation.y += 0.006; &#125; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4. 加载Collada模型(.dae)这是另一种非常通用的格式，不仅可以定义模型(网格和材质)，还可以定义场景以及动画。 加载这种格式，使用上和加载OBJ&#x2F;MTL模型步骤基本一样。主要区别是回调函数的返回结构不同： 1234567891011var result = &#123; ... scene: scene, morphs: morphs, skins: skins, animations: animData, dae: &#123; ... &#125; ...&#125; 还一个需要注意的点是，导出.dae格式模型，如果描述文件中纹理是用的.tga格式，那么需要把它转换为.png，并对应修改.dae模型文件的XML元素，指向转换后的.png文件。因为WebGL不支持.tga格式的纹理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!-- chapter-08-07.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Load collada model &lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/ColladaLoader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xcccccc, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; camera.position.x = 150; camera.position.y = 150; camera.position.z = 150; camera.lookAt(new THREE.Vector3(0, 20, 0)); var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(150, 150, 150); spotLight.intensity = 2; scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var mesh; // 加载.dae模型文件 var loader = new THREE.ColladaLoader(); loader.load(&quot;../assets/models/dae/Truck_dae.dae&quot;, function (result) &#123; // 模型中找到我们需要的网格对象 mesh = result.scene.children[0].children[0].clone(); mesh.scale.set(4, 4, 4); scene.add(mesh); &#125;); render(); function render() &#123; stats.update(); requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5. 加载STL、CTM、VTK、AWD、Assimp、VRML和Babylon模型这些使用都基本相同，就不一一列完整示例了，下面是它们的加载方式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// STLvar loader = new THREE.STLLoader();loader.load(&quot;../assets/models/SolidHead_2_lowPoly_42k.stl&quot;, function (geometry) &#123; console.log(geometry); var mat = new THREE.MeshLambertMaterial(&#123;color: 0x7777ff&#125;); var mesh = new THREE.Mesh(geometry, mat); mesh.rotation.x = -0.5 * Math.PI; mesh.scale.set(0.6, 0.6, 0.6); scene.add(mesh);&#125;);// CTMvar loader = new THREE.CTMLoader();loader.load(&quot;../assets/models/auditt_wheel.ctm&quot;, function (geometry) &#123; var mat = new THREE.MeshLambertMaterial(&#123;color: 0xff8888&#125;); var group = new THREE.Mesh(geometry, mat); group.scale.set(20, 20, 20); scene.add(group);&#125;, &#123;&#125;);// VTKvar loader = new THREE.VTKLoader();loader.load(&quot;../assets/models/moai_fixed.vtk&quot;, function (geometry) &#123; var mat = new THREE.MeshLambertMaterial(&#123;color: 0xaaffaa&#125;); var group = new THREE.Mesh(geometry, mat); group.scale.set(9, 9, 9); scene.add(group);&#125;);// AWDvar loader = new THREE.AWDLoader();loader.load(&quot;../assets/models/awd/PolarBear.awd&quot;, function (model) &#123; console.log(model); model.traverse(function (child) &#123; if (child instanceof THREE.Mesh) &#123; child.material = new THREE.MeshLambertMaterial(&#123;color: 0xaaaaaa&#125;); console.log(child.geometry); &#125; &#125;); model.scale.set(0.1, 0.1, 0.1); scene.add(model);&#125;);// Assimpvar loader = new THREE.AssimpJSONLoader();loader.load(&quot;../assets/models/assimp/spider.obj.assimp.json&quot;, function (model) &#123; console.log(model); model.traverse(function (child) &#123; if (child instanceof THREE.Mesh) &#123; // child.material = new THREE.MeshLambertMaterial(&#123;color:0xaaaaaa&#125;); console.log(child.geometry); &#125; &#125;); model.scale.set(0.1, 0.1, 0.1); scene.add(model);&#125;);// VRMLvar loader = new THREE.VRMLLoader();loader.load(&quot;../assets/models/vrml/tree.wrl&quot;, function (model) &#123; console.log(model); model.traverse(function (child) &#123; if (child instanceof THREE.Mesh) &#123; // child.material = new THREE.MeshLambertMaterial(&#123;color:0xaaaaaa&#125;); console.log(child.geometry); &#125; &#125;); model.scale.set(10, 10, 10); scene.add(model);&#125;);// Babylonvar loader = new THREE.BabylonLoader();loader.load(&quot;../assets/models/babylon/skull.babylon&quot;, function (loadedScene) &#123; console.log(loadedScene.children[1].material = new THREE.MeshLambertMaterial()); scene = loadedScene;&#125;); 6. 加载PDB模型(分子结构)这是一种特殊的模型，用于显示分子结构。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;!-- chapter-08-08.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Load pdb model &lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/PDBLoader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0x000, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; camera.position.x = 6; camera.position.y = 6; camera.position.z = 6; camera.lookAt(new THREE.Vector3(0, 0, 0)); var dir1 = new THREE.DirectionalLight(0.4); dir1.position.set(-30, 30, -30); scene.add(dir1); var dir2 = new THREE.DirectionalLight(0.4); dir2.position.set(-30, 30, 30); scene.add(dir2); var dir3 = new THREE.DirectionalLight(0.4); dir3.position.set(30, 30, -30); scene.add(dir3); var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(30, 30, 30); scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var mesh; var loader = new THREE.PDBLoader(); var group = new THREE.Object3D(); loader.load(&quot;../assets/models/aspirin.pdb&quot;, function (geometry, geometryBonds) &#123; //loader.load(&quot;../assets/models/diamond.pdb&quot;, function (geometry, geometryBonds) &#123; // 在分子结构顶点处创建圆点 var i = 0; geometry.vertices.forEach(function (position) &#123; var sphere = new THREE.SphereGeometry(0.2); var material = new THREE.MeshPhongMaterial(&#123;color: geometry.colors[i++]&#125;); var mesh = new THREE.Mesh(sphere, material); mesh.position.copy(position); group.add(mesh); &#125;); // 分子圆点之间的键创建连接管 for (var j = 0; j &lt; geometryBonds.vertices.length; j += 2) &#123; var path = new THREE.SplineCurve3([geometryBonds.vertices[j], geometryBonds.vertices[j + 1]]); var tube = new THREE.TubeGeometry(path, 1, 0.04); var material = new THREE.MeshPhongMaterial(&#123;color: 0xcccccc&#125;); var mesh = new THREE.Mesh(tube, material); group.add(mesh); &#125; scene.add(group); &#125;); render(); function render() &#123; stats.update(); if (group) &#123; group.rotation.y += 0.006; group.rotation.x += 0.006; &#125; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 7. 把加载的外部模型创建为粒子系统这里用PLY格式模型举例，其加载流程都差不多，没什么要说的。我们做一些不一样的操作，将使用加载的模型信息来创建一个粒子系统。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;!-- chapter-08-09.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Load ply model &lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/PLYLoader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0x000, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; camera.position.x = 10; camera.position.y = 10; camera.position.z = 10; camera.lookAt(new THREE.Vector3(0, -2, 0)); var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(20, 20, 20); scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var loader = new THREE.PLYLoader(); var group = new THREE.Object3D(); loader.load(&quot;../assets/models/test.ply&quot;, function (geometry) &#123; // 粒子系统的点云材质 var material = new THREE.PointCloudMaterial(&#123; color: 0xffffff, size: 0.4, opacity: 0.6, transparent: true, blending: THREE.AdditiveBlending, map: generateSprite() // 外部纹理信息 &#125;); group = new THREE.PointCloud(geometry, material); group.sortParticles = true; scene.add(group); &#125;); render(); // 获取画布的纹理信息 function generateSprite() &#123; var canvas = document.createElement(&#x27;canvas&#x27;); canvas.width = 16; canvas.height = 16; var context = canvas.getContext(&#x27;2d&#x27;); var gradient = context.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2); gradient.addColorStop(0, &#x27;rgba(255,255,255,1)&#x27;); gradient.addColorStop(0.2, &#x27;rgba(0,255,255,1)&#x27;); gradient.addColorStop(0.4, &#x27;rgba(0,0,64,1)&#x27;); gradient.addColorStop(1, &#x27;rgba(0,0,0,1)&#x27;); context.fillStyle = gradient; context.fillRect(0, 0, canvas.width, canvas.height); var texture = new THREE.Texture(canvas); texture.needsUpdate = true; return texture; &#125; function render() &#123; stats.update(); if (group) &#123; group.rotation.y += 0.006; &#125; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/categories/threejs/"}],"tags":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/tags/threejs/"},{"name":"使用外部模型","slug":"使用外部模型","permalink":"https://cxx001.gitee.io/tags/%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E6%A8%A1%E5%9E%8B/"}],"keywords":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/categories/threejs/"}]},{"title":"threejs精灵和粒子系统","slug":"threejs/threejs精灵和粒子系统","date":"2023-02-08T07:31:15.000Z","updated":"2023-03-14T05:44:02.159Z","comments":true,"path":"2023/02/08/threejs/threejs精灵和粒子系统/","link":"","permalink":"https://cxx001.gitee.io/2023/02/08/threejs/threejs%E7%B2%BE%E7%81%B5%E5%92%8C%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"前面我们了解到了场景中的网格对象由几何体和材质组成，并且分别系统学习了它们。这节我们将学习一个特殊的网格对象—–粒子(精灵)。 了解粒子一个粒子(新版叫精灵)是 一个二维平面(小方块) ，它总是面向摄像机。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!-- chapter-07-01.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Particles&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; background-color: #000000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); //var canvasRenderer = new THREE.CanvasRenderer(); var canvasRenderer = new THREE.WebGLRenderer(); canvasRenderer.setClearColor(new THREE.Color(0x000000, 1.0)); canvasRenderer.setSize(window.innerWidth, window.innerHeight); camera.position.x = 0; camera.position.y = 0; camera.position.z = 150; document.getElementById(&quot;WebGL-output&quot;).appendChild(canvasRenderer.domElement); createSprites(); render(); function createSprites() &#123; // 创建精灵材质 var material = new THREE.SpriteMaterial(); for (var x = -5; x &lt; 5; x++) &#123; for (var y = -5; y &lt; 5; y++) &#123; // 创建精灵，只需要指定材质 var sprite = new THREE.Sprite(material); sprite.position.set(x * 10, y * 10, 0); scene.add(sprite); &#125; &#125; &#125; function render() &#123; stats.update(); requestAnimationFrame(render); canvasRenderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 大量粒子如果要创建大量粒子，使用上面THREE.Sprite一个个创建那就太耗性能了。对于这种场景，我们要使用THREE.PointCloudMaterial和THREE.PointCloud来管理。 THREE.PointCloud构造函数接收两个属性：几何体和材质，和创建网格对象类似。材质用来给粒子着色或添加纹理，而几何体则用来指定粒子的位置，几何体每个顶点将会以粒子的形态展示出来。 THREE.PointCloudMaterial材质的属性： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;!-- chapter-07-02.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Particle Basic Material&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; background-color: #000000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0x000000, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); camera.position.x = 20; camera.position.y = 0; camera.position.z = 150; document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var cloud; var controls = new function () &#123; this.size = 4; this.transparent = true; this.opacity = 0.6; this.vertexColors = true; this.color = 0xffffff; this.sizeAttenuation = true; this.rotateSystem = true; this.redraw = function () &#123; if (scene.getObjectByName(&quot;particles&quot;)) &#123; scene.remove(scene.getObjectByName(&quot;particles&quot;)); &#125; createParticles(controls.size, controls.transparent, controls.opacity, controls.vertexColors, controls.sizeAttenuation, controls.color); &#125;; &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;size&#x27;, 0, 10).onChange(controls.redraw); gui.add(controls, &#x27;transparent&#x27;).onChange(controls.redraw); gui.add(controls, &#x27;opacity&#x27;, 0, 1).onChange(controls.redraw); gui.add(controls, &#x27;vertexColors&#x27;).onChange(controls.redraw); gui.addColor(controls, &#x27;color&#x27;).onChange(controls.redraw); gui.add(controls, &#x27;sizeAttenuation&#x27;).onChange(controls.redraw); gui.add(controls, &#x27;rotateSystem&#x27;); controls.redraw(); render(); // 使用THREE.PointCloud创建大量粒子 function createParticles(size, transparent, opacity, vertexColors, sizeAttenuation, color) &#123; // 创建点云材质 var material = new THREE.PointCloudMaterial(&#123; size: size, transparent: transparent, opacity: opacity, vertexColors: vertexColors, sizeAttenuation: sizeAttenuation, color: color &#125;); // 创建自定义几何体 var geom = new THREE.Geometry(); var range = 500; for (var i = 0; i &lt; 15000; i++) &#123; var particle = new THREE.Vector3(Math.random() * range - range / 2, Math.random() * range - range / 2, Math.random() * range - range / 2); geom.vertices.push(particle); var color = new THREE.Color(0x00ff00); color.setHSL(color.getHSL().h, color.getHSL().s, Math.random() * color.getHSL().l); geom.colors.push(color); &#125; // 创建点云对象 cloud = new THREE.PointCloud(geom, material); cloud.name = &quot;particles&quot;; scene.add(cloud); &#125; var step = 0; function render() &#123; stats.update(); if (controls.rotateSystem) &#123; step += 0.01; cloud.rotation.x = step; cloud.rotation.z = step; &#125; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 样式化粒子默认粒子会渲染成小方块，下面来看看怎么改变粒子样式。 1. 使用HTML5画布样式化粒子前面提到过，THREE.PointCloudMaterial的map属性可以为粒子加载纹理，以此来改变粒子样式(关于纹理后续会详细介绍，这里只需关注使用)。首先我们看看把HTML5的画布转换为纹理来作为粒子的纹理运用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171&lt;!-- chapter-07-03.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Particles - Canvas based texture - WebGL&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; background-color: #000000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0x000000, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); camera.position.x = 20; camera.position.y = 0; camera.position.z = 150; document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); // 获取画布的纹理 var getTexture = function () &#123; var canvas = document.createElement(&#x27;canvas&#x27;); canvas.width = 32; canvas.height = 32; var ctx = canvas.getContext(&#x27;2d&#x27;); // the body ctx.translate(-81, -84); ctx.fillStyle = &quot;orange&quot;; ctx.beginPath(); ctx.moveTo(83, 116); ctx.lineTo(83, 102); ctx.bezierCurveTo(83, 94, 89, 88, 97, 88); ctx.bezierCurveTo(105, 88, 111, 94, 111, 102); ctx.lineTo(111, 116); ctx.lineTo(106.333, 111.333); ctx.lineTo(101.666, 116); ctx.lineTo(97, 111.333); ctx.lineTo(92.333, 116); ctx.lineTo(87.666, 111.333); ctx.lineTo(83, 116); ctx.fill(); // the eyes ctx.fillStyle = &quot;white&quot;; ctx.beginPath(); ctx.moveTo(91, 96); ctx.bezierCurveTo(88, 96, 87, 99, 87, 101); ctx.bezierCurveTo(87, 103, 88, 106, 91, 106); ctx.bezierCurveTo(94, 106, 95, 103, 95, 101); ctx.bezierCurveTo(95, 99, 94, 96, 91, 96); ctx.moveTo(103, 96); ctx.bezierCurveTo(100, 96, 99, 99, 99, 101); ctx.bezierCurveTo(99, 103, 100, 106, 103, 106); ctx.bezierCurveTo(106, 106, 107, 103, 107, 101); ctx.bezierCurveTo(107, 99, 106, 96, 103, 96); ctx.fill(); // the pupils ctx.fillStyle = &quot;blue&quot;; ctx.beginPath(); ctx.arc(101, 102, 2, 0, Math.PI * 2, true); ctx.fill(); ctx.beginPath(); ctx.arc(89, 102, 2, 0, Math.PI * 2, true); ctx.fill(); var texture = new THREE.Texture(canvas); texture.needsUpdate = true; return texture; &#125;; var cloud; var controls = new function () &#123; this.size = 15; this.transparent = true; this.opacity = 0.6; this.color = 0xffffff; this.rotateSystem = true; this.sizeAttenuation = true; this.redraw = function () &#123; if (scene.getObjectByName(&quot;pointcloud&quot;)) &#123; scene.remove(scene.getObjectByName(&quot;pointcloud&quot;)); &#125; createPointCloud(controls.size, controls.transparent, controls.opacity, controls.sizeAttenuation, controls.color); &#125;; &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;size&#x27;, 0, 20).onChange(controls.redraw); gui.add(controls, &#x27;transparent&#x27;).onChange(controls.redraw); gui.add(controls, &#x27;opacity&#x27;, 0, 1).onChange(controls.redraw); gui.addColor(controls, &#x27;color&#x27;).onChange(controls.redraw); gui.add(controls, &#x27;sizeAttenuation&#x27;).onChange(controls.redraw); gui.add(controls, &#x27;rotateSystem&#x27;); controls.redraw(); render(); function createPointCloud(size, transparent, opacity, sizeAttenuation, color) &#123; var geom = new THREE.Geometry(); var material = new THREE.PointCloudMaterial(&#123; size: size, transparent: transparent, opacity: opacity, map: getTexture(), // 使用外部纹理 sizeAttenuation: sizeAttenuation, color: color &#125;); var range = 500; for (var i = 0; i &lt; 5000; i++) &#123; var particle = new THREE.Vector3(Math.random() * range - range / 2, Math.random() * range - range / 2, Math.random() * range - range / 2); geom.vertices.push(particle); &#125; cloud = new THREE.PointCloud(geom, material); cloud.name = &#x27;pointcloud&#x27;; // 渲染之前所以粒子按z轴排序，解决部分粒子交叠问题，但是注意会影响性能。 cloud.sortParticles = true; // 开启后摄像机可见范围外的粒子不会渲染，必要时，使用可以提高性能和帧率。 cloud.FrustumCulled = true; scene.add(cloud); &#125; var step = 0; function render() &#123; stats.update(); if (controls.rotateSystem) &#123; step += 0.01; cloud.rotation.x = step; cloud.rotation.z = step; &#125; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2. 使用纹理样式化粒子前面使用HTML5画布输出纹理还是显得麻烦，我们还有一种更直接的方式，你可以使用THREE.ImageUtils.loadTexture()函数将图像加载为THREE.Texture，然后赋值给材质的map属性。 注意图片应该是正方形的，并且尺寸最好是2的幂，背景选择黑色(能够更正确地融合)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;!-- chapter-07-04.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Particles - Rainy scene&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; background-color: #000000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 200); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0x000000, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); camera.position.x = 20; camera.position.y = 40; camera.position.z = 110; camera.lookAt(new THREE.Vector3(20, 30, 0)); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var cloud; var controls = new function () &#123; this.size = 3; this.transparent = true; this.opacity = 0.6; this.color = 0xffffff; this.sizeAttenuation = true; this.redraw = function () &#123; scene.remove(scene.getObjectByName(&quot;particles1&quot;)); scene.remove(scene.getObjectByName(&quot;particles2&quot;)); createPointCloud(controls.size, controls.transparent, controls.opacity, controls.sizeAttenuation, controls.color); &#125;; &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;size&#x27;, 0, 20).onChange(controls.redraw); gui.add(controls, &#x27;transparent&#x27;).onChange(controls.redraw); gui.add(controls, &#x27;opacity&#x27;, 0, 1).onChange(controls.redraw); gui.addColor(controls, &#x27;color&#x27;).onChange(controls.redraw); gui.add(controls, &#x27;sizeAttenuation&#x27;).onChange(controls.redraw); controls.redraw(); render(); function createPointCloud(size, transparent, opacity, sizeAttenuation, color) &#123; // 加载本地图片作为粒子纹理 var texture = THREE.ImageUtils.loadTexture(&quot;../assets/textures/particles/raindrop-3.png&quot;); var geom = new THREE.Geometry(); var material = new THREE.ParticleBasicMaterial(&#123; size: size, transparent: transparent, opacity: opacity, map: texture, blending: THREE.AdditiveBlending, sizeAttenuation: sizeAttenuation, color: color &#125;); var range = 40; for (var i = 0; i &lt; 1500; i++) &#123; var particle = new THREE.Vector3( Math.random() * range - range / 2, Math.random() * range * 1.5, Math.random() * range - range / 2); particle.velocityY = 0.1 + Math.random() / 5; particle.velocityX = (Math.random() - 0.5) / 3; geom.vertices.push(particle); &#125; cloud = new THREE.ParticleSystem(geom, material); cloud.sortParticles = true; scene.add(cloud); &#125; function render() &#123; stats.update(); // 模拟下雨效果 var vertices = cloud.geometry.vertices; vertices.forEach(function (v) &#123; v.y = v.y - (v.velocityY); v.x = v.x - (v.velocityX); if (v.y &lt;= 0) v.y = 60; if (v.x &lt;= -20 || v.x &gt;= 20) v.velocityX = v.velocityX * -1; &#125;); requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用精灵贴图精灵贴图是很多小精灵图片打包在一张图片上，一次加载这张大图后，使用时通过纹理的偏移来选取需要的小图片。 这个示例展示了创建两个场景使用不同摄像机(游戏里场景和UI界面就可以这样使用) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;!-- chapter-07-05.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Particles - Sprites&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; background-color: #000000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); // 透视相机场景和正交相机场景 var scene = new THREE.Scene(); var sceneOrtho = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 250); var cameraOrtho = new THREE.OrthographicCamera(0, window.innerWidth, window.innerHeight, 0, -10, 10); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0x000000, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); camera.position.x = 0; camera.position.y = 0; camera.position.z = 50; document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); // 球体 var material = new THREE.MeshNormalMaterial(); var geom = new THREE.SphereGeometry(15, 20, 20); var mesh = new THREE.Mesh(geom, material); scene.add(mesh); // 获取精灵贴图纹理 var getTexture = function () &#123; var texture = new THREE.ImageUtils.loadTexture(&quot;../assets/textures/particles/sprite-sheet.png&quot;); return texture; &#125;; var controls = new function () &#123; this.size = 150; this.sprite = 0; this.transparent = true; this.opacity = 0.6; this.color = 0xffffff; this.rotateSystem = true; this.redraw = function () &#123; sceneOrtho.children.forEach(function (child) &#123; if (child instanceof THREE.Sprite) sceneOrtho.remove(child); &#125;); createSprite(controls.size, controls.transparent, controls.opacity, controls.color, controls.sprite); &#125;; &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;sprite&#x27;, 0, 4).step(1).onChange(controls.redraw); gui.add(controls, &#x27;size&#x27;, 0, 120).onChange(controls.redraw); gui.add(controls, &#x27;transparent&#x27;).onChange(controls.redraw); gui.add(controls, &#x27;opacity&#x27;, 0, 1).onChange(controls.redraw); gui.addColor(controls, &#x27;color&#x27;).onChange(controls.redraw); controls.redraw(); render(); function createSprite(size, transparent, opacity, color, spriteNumber) &#123; var spriteMaterial = new THREE.SpriteMaterial(&#123; opacity: opacity, color: color, transparent: transparent, map: getTexture() &#125; ); // 通过map的offset/repeat选择精灵贴图里的精灵图片,范围0~1 spriteMaterial.map.offset = new THREE.Vector2(0.2 * spriteNumber, 0); spriteMaterial.map.repeat = new THREE.Vector2(1 / 5, 1); var sprite = new THREE.Sprite(spriteMaterial); sprite.scale.set(size, size, size); sprite.position.set(100, 50, -10); sprite.velocityX = 5; // 精灵x轴移动速度因子 sceneOrtho.add(sprite); // 小人精灵添加到正交场景中 &#125; var step = 0; function render() &#123; stats.update(); // 透视相机y轴运动 camera.position.y = Math.sin(step += 0.01) * 20; // 正交相机里的精灵x轴左右移动 sceneOrtho.children.forEach(function (e) &#123; if (e instanceof THREE.Sprite) &#123; // move the sprite along the bottom e.position.x = e.position.x + e.velocityX; if (e.position.x &gt; window.innerWidth) &#123; e.velocityX = -5; e.material.map.offset.set(1 / 5 * (controls.sprite % 4), 0); &#125; if (e.position.x &lt; 0) &#123; e.velocityX = 5; &#125; &#125; &#125;); requestAnimationFrame(render); webGLRenderer.render(scene, camera); webGLRenderer.autoClear = false; // 关闭自动清理，不然在sceneOrtho render时会清理scene的，那么就会导致看不到scene里的球体了 webGLRenderer.render(sceneOrtho, cameraOrtho); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 从高级几何体创建THREE.PointCloud前面我们知道了THREE.PointCloud是基于几何体的顶点来渲染每个粒子的。前面我们都是使用的自定义顶点，其实也可以直接用高级几何体创建点云。 示例：使用上节的环状扭结几何体创建粒子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143&lt;!-- chapter-07-06.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;3D Torusknot&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0x000000, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; camera.position.x = -30; camera.position.y = 40; camera.position.z = 50; camera.lookAt(new THREE.Vector3(10, 0, 0)); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var knot; var controls = new function () &#123; this.radius = 13; this.tube = 1.7; this.radialSegments = 156; this.tubularSegments = 12; this.p = 5; this.q = 4; this.heightScale = 3.5; this.asParticles = false; this.rotate = false; this.redraw = function () &#123; if (knot) scene.remove(knot); // 创建环状扭结几何体 var geom = new THREE.TorusKnotGeometry(controls.radius, controls.tube, Math.round(controls.radialSegments), Math.round(controls.tubularSegments), Math.round(controls.p), Math.round(controls.q), controls.heightScale); if (controls.asParticles) &#123; // 创建点云对象 knot = createPointCloud(geom); &#125; else &#123; // 创建网格对象 knot = createMesh(geom); &#125; scene.add(knot); &#125;; &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;radius&#x27;, 0, 40).onChange(controls.redraw); gui.add(controls, &#x27;tube&#x27;, 0, 40).onChange(controls.redraw); gui.add(controls, &#x27;radialSegments&#x27;, 0, 400).step(1).onChange(controls.redraw); gui.add(controls, &#x27;tubularSegments&#x27;, 1, 20).step(1).onChange(controls.redraw); gui.add(controls, &#x27;p&#x27;, 1, 10).step(1).onChange(controls.redraw); gui.add(controls, &#x27;q&#x27;, 1, 15).step(1).onChange(controls.redraw); gui.add(controls, &#x27;heightScale&#x27;, 0, 5).onChange(controls.redraw); gui.add(controls, &#x27;asParticles&#x27;).onChange(controls.redraw); gui.add(controls, &#x27;rotate&#x27;).onChange(controls.redraw); controls.redraw(); render(); // 获取当前画布的纹理信息 function generateSprite() &#123; var canvas = document.createElement(&#x27;canvas&#x27;); canvas.width = 16; canvas.height = 16; var context = canvas.getContext(&#x27;2d&#x27;); var gradient = context.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2); gradient.addColorStop(0, &#x27;rgba(255,255,255,1)&#x27;); gradient.addColorStop(0.2, &#x27;rgba(0,255,255,1)&#x27;); gradient.addColorStop(0.4, &#x27;rgba(0,0,64,1)&#x27;); gradient.addColorStop(1, &#x27;rgba(0,0,0,1)&#x27;); context.fillStyle = gradient; context.fillRect(0, 0, canvas.width, canvas.height); var texture = new THREE.Texture(canvas); texture.needsUpdate = true; return texture; &#125; function createPointCloud(geom) &#123; var material = new THREE.PointCloudMaterial(&#123; color: 0xffffff, size: 3, transparent: true, blending: THREE.AdditiveBlending, map: generateSprite() // 使用HTML5画布的纹理 &#125;); var cloud = new THREE.PointCloud(geom, material); cloud.sortParticles = true; return cloud; &#125; function createMesh(geom) &#123; var meshMaterial = new THREE.MeshNormalMaterial(&#123;&#125;); meshMaterial.side = THREE.DoubleSide; var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial]); return mesh; &#125; function render() &#123; stats.update(); if (controls.rotate) &#123; knot.rotation.y += 0.01; &#125; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/categories/threejs/"}],"tags":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/tags/threejs/"},{"name":"精灵","slug":"精灵","permalink":"https://cxx001.gitee.io/tags/%E7%B2%BE%E7%81%B5/"},{"name":"粒子系统","slug":"粒子系统","permalink":"https://cxx001.gitee.io/tags/%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/"}],"keywords":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/categories/threejs/"}]},{"title":"threejs高级几何体","slug":"threejs/threejs高级几何体","date":"2023-02-07T09:17:15.000Z","updated":"2023-03-14T05:45:00.746Z","comments":true,"path":"2023/02/07/threejs/threejs高级几何体/","link":"","permalink":"https://cxx001.gitee.io/2023/02/07/threejs/threejs%E9%AB%98%E7%BA%A7%E5%87%A0%E4%BD%95%E4%BD%93/","excerpt":"","text":"1. THREE.ConvexGeometry它可以围绕一组点创建一个凸包，所谓凸包就是包围这组点得最小图形。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;!-- chapter-06-01.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Advanced 3D geometries - Convex Hull&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/ConvexGeometry.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; camera.position.x = -30; camera.position.y = 40; camera.position.z = 50; camera.lookAt(new THREE.Vector3(10, 0, 0)); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var spGroup; // 20个随机圆点网格组对象 var hullMesh; // 凸包网格 generatePoints(); var controls = new function () &#123; this.redraw = function () &#123; scene.remove(spGroup); scene.remove(hullMesh); generatePoints(); &#125;; &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;redraw&#x27;); function generatePoints() &#123; // 随机创建20个点坐标 var points = []; for (var i = 0; i &lt; 20; i++) &#123; var randomX = -15 + Math.round(Math.random() * 30); var randomY = -15 + Math.round(Math.random() * 30); var randomZ = -15 + Math.round(Math.random() * 30); points.push(new THREE.Vector3(randomX, randomY, randomZ)); &#125; // 创建20个圆点网格添加到spGroup spGroup = new THREE.Object3D(); var material = new THREE.MeshBasicMaterial(&#123;color: 0xff0000, transparent: false&#125;); points.forEach(function (point) &#123; var spGeom = new THREE.SphereGeometry(0.2); var spMesh = new THREE.Mesh(spGeom, material); spMesh.position.copy(point); spGroup.add(spMesh); &#125;); scene.add(spGroup); // 创建凸包网格 var hullGeometry = new THREE.ConvexGeometry(points); hullMesh = createMesh(hullGeometry); scene.add(hullMesh); &#125; function createMesh(geom) &#123; var meshMaterial = new THREE.MeshBasicMaterial(&#123;color: 0x00ff00, transparent: true, opacity: 0.2&#125;); meshMaterial.side = THREE.DoubleSide; var wireFrameMat = new THREE.MeshBasicMaterial(); wireFrameMat.wireframe = true; var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMat]); return mesh; &#125; var step = 0; function render() &#123; stats.update(); spGroup.rotation.y = step; hullMesh.rotation.y = step += 0.01; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2. THREE.LatheGeometry它允许你从一条光滑曲线创建图形。这条曲线绕物体的中心z轴旋转，就得到了类似花瓶或铃铛的图形。 属性 描述 points 指定构成曲线的点，然后基于这条曲线生成类似铃铛或花瓶的图形 segments 指定创建图形时所用分段数目。这个数值越高，最终的图形越圆。默认值为12 phiStart 指定创建图形时从何处开始画，默认值为0 phiLength 指定绘制多少(弧度)图形，默认360度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;!-- chapter-06-02.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Advanced 3D geometries - Lathe&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; camera.position.x = -30; camera.position.y = 40; camera.position.z = 50; camera.lookAt(new THREE.Vector3(10, 0, 0)); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); // 圆点网格组 var spGroup; // 样条曲线网格 var latheMesh; generatePoints(12, 2, 2 * Math.PI); var controls = new function () &#123; this.segments = 12; this.phiStart = 0; this.phiLength = 2 * Math.PI; this.redraw = function () &#123; scene.remove(spGroup); scene.remove(latheMesh); generatePoints(controls.segments, controls.phiStart, controls.phiLength); &#125;; &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;segments&#x27;, 0, 50).step(1).onChange(controls.redraw); gui.add(controls, &#x27;phiStart&#x27;, 0, 2 * Math.PI).onChange(controls.redraw); gui.add(controls, &#x27;phiLength&#x27;, 0, 2 * Math.PI).onChange(controls.redraw); function generatePoints(segments, phiStart, phiLength) &#123; // 通过sin/cos创建30个点坐标 var points = []; var height = 5; var count = 30; for (var i = 0; i &lt; count; i++) &#123; points.push(new THREE.Vector3((Math.sin(i * 0.2) + Math.cos(i * 0.3)) * height + 12, 0, ( i - count ) + count / 2)); &#125; // 在这30个点坐标位置创建圆点网格，添加到spGroup网格组中 spGroup = new THREE.Object3D(); var material = new THREE.MeshBasicMaterial(&#123;color: 0xff0000, transparent: false&#125;); points.forEach(function (point) &#123; var spGeom = new THREE.SphereGeometry(0.2); var spMesh = new THREE.Mesh(spGeom, material); spMesh.position.copy(point); spGroup.add(spMesh); &#125;); scene.add(spGroup); // 创建样条曲线网格 var latheGeometry = new THREE.LatheGeometry(points, segments, phiStart, phiLength); latheMesh = createMesh(latheGeometry); scene.add(latheMesh); &#125; function createMesh(geom) &#123; var meshMaterial = new THREE.MeshNormalMaterial(); meshMaterial.side = THREE.DoubleSide; var wireFrameMat = new THREE.MeshBasicMaterial(); wireFrameMat.wireframe = true; var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMat]); return mesh; &#125; var step = 0; function render() &#123; stats.update(); spGroup.rotation.x = step; latheMesh.rotation.x = step += 0.01; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3. 通过拉伸创建几何体THREE.ExtrudeGeometry它可以从一个二维图形通过沿着某个轴(默认z轴)拉伸创建出一个三维图形。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142&lt;!-- chapter-06-03.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Extrude Geometry&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; // 创建自定义二维图形 var shape = createMesh(new THREE.ShapeGeometry(drawShape())); scene.add(shape); camera.position.x = -20; camera.position.y = 60; camera.position.z = 60; camera.lookAt(new THREE.Vector3(20, 20, 0)); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var controls = new function () &#123; this.amount = 2; this.bevelThickness = 2; this.bevelSize = 0.5; this.bevelEnabled = true; this.bevelSegments = 3; this.bevelEnabled = true; this.curveSegments = 12; this.steps = 1; this.asGeom = function () &#123; scene.remove(shape); var options = &#123; amount: controls.amount, bevelThickness: controls.bevelThickness, bevelSize: controls.bevelSize, bevelSegments: controls.bevelSegments, bevelEnabled: controls.bevelEnabled, curveSegments: controls.curveSegments, steps: controls.steps &#125;; // 创建拉伸几何体网格 shape = createMesh(new THREE.ExtrudeGeometry(drawShape(), options)); scene.add(shape); &#125;; &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;amount&#x27;, 0, 20).onChange(controls.asGeom); gui.add(controls, &#x27;bevelThickness&#x27;, 0, 10).onChange(controls.asGeom); gui.add(controls, &#x27;bevelSize&#x27;, 0, 10).onChange(controls.asGeom); gui.add(controls, &#x27;bevelSegments&#x27;, 0, 30).step(1).onChange(controls.asGeom); gui.add(controls, &#x27;bevelEnabled&#x27;).onChange(controls.asGeom); gui.add(controls, &#x27;curveSegments&#x27;, 1, 30).step(1).onChange(controls.asGeom); gui.add(controls, &#x27;steps&#x27;, 1, 5).step(1).onChange(controls.asGeom); // 上一节面具示例 function drawShape() &#123; var shape = new THREE.Shape(); shape.moveTo(10, 10); shape.lineTo(10, 40); shape.bezierCurveTo(15, 25, 25, 25, 30, 40); shape.splineThru( [new THREE.Vector2(32, 30), new THREE.Vector2(28, 20), new THREE.Vector2(30, 10), ]); shape.quadraticCurveTo(20, 15, 10, 10); var hole1 = new THREE.Path(); hole1.absellipse(16, 24, 2, 3, 0, Math.PI * 2, true); shape.holes.push(hole1); var hole2 = new THREE.Path(); hole2.absellipse(23, 24, 2, 3, 0, Math.PI * 2, true); shape.holes.push(hole2); var hole3 = new THREE.Path(); hole3.absarc(20, 16, 2, 0, Math.PI, true); shape.holes.push(hole3); return shape; &#125; function createMesh(geom) &#123; geom.applyMatrix(new THREE.Matrix4().makeTranslation(-20, 0, 0)); var meshMaterial = new THREE.MeshNormalMaterial(&#123; shading: THREE.FlatShading, transparent: true, opacity: 0.7 &#125;); var wireFrameMat = new THREE.MeshBasicMaterial(); wireFrameMat.wireframe = true; var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial]); return mesh; &#125; function render() &#123; stats.update(); shape.rotation.y += 0.01; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; THREE.TubeGeometry它可以沿着一条三维样式曲线拉伸出一根管子。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129&lt;!-- chapter-06-04.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Extrude TubeGeometry&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; camera.position.x = -30; camera.position.y = 40; camera.position.z = 50; camera.lookAt(new THREE.Vector3(10, 0, 0)); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); // the points group var spGroup; // the mesh var tubeMesh; var controls = new function () &#123; this.numberOfPoints = 5; this.segments = 64; this.radius = 1; this.radiusSegments = 8; this.closed = false; this.points = []; this.newPoints = function () &#123; var points = []; for (var i = 0; i &lt; controls.numberOfPoints; i++) &#123; var randomX = -20 + Math.round(Math.random() * 50); var randomY = -15 + Math.round(Math.random() * 40); var randomZ = -20 + Math.round(Math.random() * 40); points.push(new THREE.Vector3(randomX, randomY, randomZ)); &#125; controls.points = points; controls.redraw(); &#125;; this.redraw = function () &#123; scene.remove(spGroup); scene.remove(tubeMesh); generatePoints(controls.points, controls.segments, controls.radius, controls.radiusSegments, controls.closed); &#125;; &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;newPoints&#x27;); gui.add(controls, &#x27;numberOfPoints&#x27;, 2, 15).step(1).onChange(controls.newPoints); gui.add(controls, &#x27;segments&#x27;, 0, 200).step(1).onChange(controls.redraw); gui.add(controls, &#x27;radius&#x27;, 0, 10).onChange(controls.redraw); gui.add(controls, &#x27;radiusSegments&#x27;, 0, 100).step(1).onChange(controls.redraw); gui.add(controls, &#x27;closed&#x27;).onChange(controls.redraw); function generatePoints(points, segments, radius, radiusSegments, closed) &#123; // 创建圆点网格组对象(三维样条曲线路径) spGroup = new THREE.Object3D(); var material = new THREE.MeshBasicMaterial(&#123;color: 0xff0000, transparent: false&#125;); points.forEach(function (point) &#123; var spGeom = new THREE.SphereGeometry(0.2); var spMesh = new THREE.Mesh(spGeom, material); spMesh.position.copy(point); spGroup.add(spMesh); &#125;); scene.add(spGroup); // 三维样条曲线拉伸出的管子网格 var tubeGeometry = new THREE.TubeGeometry(new THREE.SplineCurve3(points), segments, radius, radiusSegments, closed); tubeMesh = createMesh(tubeGeometry); scene.add(tubeMesh); &#125; function createMesh(geom) &#123; var meshMaterial = new THREE.MeshBasicMaterial(&#123;color: 0x00ff00, transparent: true, opacity: 0.2&#125;); var wireFrameMat = new THREE.MeshBasicMaterial(); wireFrameMat.wireframe = true; var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMat]); return mesh; &#125; var step = 0; function render() &#123; stats.update(); spGroup.rotation.y = step; tubeMesh.rotation.y = step += 0.01; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 从SVG拉伸读取SVG中路径信息转换为three.js图形。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148&lt;!-- chapter-06-05.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Extrude SVG&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/d3-threeD.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/OrbitControls.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;batman&quot; style=&quot;display:none&quot;&gt; &lt;svg version=&quot;1.0&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; x=&quot;0px&quot; y=&quot;0px&quot; width=&quot;1152px&quot; height=&quot;1152px&quot; xml:space=&quot;preserve&quot;&gt;&lt;g&gt;&lt;path id=&quot;batman-path&quot; style=&quot;fill:rgb(0,0,0);&quot; d=&quot;M 261.135 114.535 C 254.906 116.662 247.491 118.825 244.659 119.344 C 229.433 122.131 177.907 142.565 151.973 156.101 C 111.417 177.269 78.9808 203.399 49.2992 238.815 C 41.0479 248.66 26.5057 277.248 21.0148 294.418 C 14.873 313.624 15.3588 357.341 21.9304 376.806 C 29.244 398.469 39.6107 416.935 52.0865 430.524 C 58.2431 437.23 63.3085 443.321 63.3431 444.06 C 63.4748 446.883 102.278 479.707 120.51 492.418 C 131.003 499.734 148.168 509.93 158.654 515.075 C 169.139 520.22 179.431 525.34 181.524 526.454 C 187.725 529.754 187.304 527.547 179.472 515.713 C 164.806 493.553 158.448 464.659 164.322 446.861 C 169.457 431.303 192.013 421.501 214.324 425.132 C 234.042 428.341 252.142 439.186 270.958 459.064 C 286.677 475.67 292.133 482.967 295.31 491.634 C 297.466 497.514 298.948 495.91 304.862 481.293 C 313.673 459.519 329.808 445.735 346.35 445.851 C 367.654 446 399.679 478.239 412.801 512.745 C 414.093 516.144 416.593 522.632 418.355 527.163 C 420.118 531.695 423.604 542.319 426.103 550.773 C 430.848 566.832 432.355 566.851 434.872 550.88 C 436.395 541.215 451.403 502.522 455.655 497.298 C 457.038 495.599 460.63 489.896 463.636 484.625 C 471.696 470.498 492.318 452.688 505.387 448.568 C 514.602 445.663 517.533 445.549 525.51 447.782 C 539.676 451.749 553.43 467.773 560.706 488.788 L 563.242 496.114 L 567.096 490.012 C 577.709 473.208 593.665 453.899 602.47 447.206 C 607.884 443.09 613.378 438.825 614.679 437.729 C 615.98 436.632 622.927 433.259 630.118 430.233 C 655.159 419.693 681.195 423.407 693.273 439.241 C 697.957 445.382 698.932 448.971 699.538 462.294 C 700.174 476.284 699.51 479.864 693.686 493.854 C 690.073 502.533 684.912 512.883 682.217 516.854 C 679.523 520.825 678.172 524.074 679.215 524.074 C 681.932 524.074 718.787 504.481 732.525 495.734 C 760.018 478.228 788.909 452.599 803.9 432.418 C 807.266 427.886 810.569 423.715 811.239 423.149 C 814.498 420.395 828.253 393.099 833.17 379.627 C 838.223 365.782 838.713 361.822 838.741 334.582 C 838.776 300.425 836.431 291.124 820.154 260.873 C 810.649 243.207 807.498 239.005 788.417 218.543 C 751.511 178.968 688.147 142.549 621.582 122.654 C 581.7 110.734 580.388 110.465 580.388 114.195 C 580.388 115.328 581.302 116.255 582.418 116.255 C 584.279 116.255 587.705 122.106 603.399 152.085 C 613.977 172.29 618.077 189.427 618.264 214.21 C 618.42 234.928 617.88 238.368 612.285 252.269 C 604.327 272.04 590.066 286.889 572.829 293.352 C 558.526 298.714 549.193 297.86 535.704 289.955 C 526.777 284.723 512.304 267.644 509.816 259.404 C 509.132 257.138 507.129 251.358 505.366 246.558 C 503.602 241.759 501.646 231.564 501.018 223.902 C 500.39 216.24 498.491 198.402 496.797 184.261 C 495.104 170.121 493.307 152.047 492.803 144.097 C 492.299 136.147 491.292 125.625 490.565 120.715 L 489.242 111.787 L 483.323 118.267 C 480.067 121.832 477.404 125.618 477.404 126.681 C 477.404 127.744 476.603 128.613 475.624 128.613 C 474.645 128.613 471.275 132.321 468.135 136.852 L 462.426 145.091 L 431.038 145.091 L 399.65 145.091 L 386.811 128.494 C 379.749 119.365 373.509 112.36 372.943 112.926 C 372.377 113.491 371.57 118.875 371.15 124.888 C 370.73 130.902 368.94 147.744 367.172 162.315 C 365.405 176.887 363.523 195.424 362.99 203.509 C 360.283 244.622 352.784 266.044 335.323 282.544 C 326.456 290.923 312.488 297.497 303.508 297.518 C 294.864 297.539 278.732 290.063 269.473 281.748 C 246.952 261.521 238.846 229.614 245.481 187.314 C 247.894 171.928 266.562 131.612 275.927 121.56 C 277.987 119.348 279.673 116.786 279.673 115.867 C 279.673 114.947 279.905 113.593 280.188 112.856 C 281.28 110.017 271.977 110.837 261.136 114.536 L 261.135 114.535 &quot;/&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var orbit; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; // 根据svg绘制路径创建svg图形网格 var shape = createMesh(new THREE.ShapeGeometry(drawShape())); scene.add(shape); camera.position.x = -80; camera.position.y = 80; camera.position.z = 80; camera.lookAt(new THREE.Vector3(60, -60, 0)); var spotLight = new THREE.DirectionalLight(0xffffff); spotLight.position = new THREE.Vector3(70, 170, 70); spotLight.intensity = 0.7; spotLight.target = shape; scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); // 可以对三维场景进行缩放，平移，旋转操作，其本质上改变的幷不是场景，而是相机的参数 // 鼠标操作：通过拖动鼠标左键可以720旋转展示三维场景，通过拖动鼠标右键可以平移三维场景，通过上下滚动鼠标中键可以缩放三维场景。 orbit = new THREE.OrbitControls(camera, webGLRenderer.domElement); var controls = new function () &#123; this.amount = 2; this.bevelThickness = 2; this.bevelSize = 0.5; this.bevelEnabled = true; this.bevelSegments = 3; this.bevelEnabled = true; this.curveSegments = 12; this.steps = 1; this.asGeom = function () &#123; scene.remove(shape); var options = &#123; amount: controls.amount, bevelThickness: controls.bevelThickness, bevelSize: controls.bevelSize, bevelSegments: controls.bevelSegments, bevelEnabled: controls.bevelEnabled, curveSegments: controls.curveSegments, steps: controls.steps &#125;; // THREE.ExtrudeGeometry拉伸svg图形 shape = createMesh(new THREE.ExtrudeGeometry(drawShape(), options)); scene.add(shape); &#125;; &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;amount&#x27;, 0, 20).onChange(controls.asGeom); gui.add(controls, &#x27;bevelThickness&#x27;, 0, 10).onChange(controls.asGeom); gui.add(controls, &#x27;bevelSize&#x27;, 0, 10).onChange(controls.asGeom); gui.add(controls, &#x27;bevelSegments&#x27;, 0, 30).step(1).onChange(controls.asGeom); gui.add(controls, &#x27;bevelEnabled&#x27;).onChange(controls.asGeom); gui.add(controls, &#x27;curveSegments&#x27;, 1, 30).step(1).onChange(controls.asGeom); gui.add(controls, &#x27;steps&#x27;, 1, 5).step(1).onChange(controls.asGeom); function drawShape() &#123; // 获取svg中绘制图形的路径信息 var svgString = document.querySelector(&quot;#batman-path&quot;).getAttribute(&quot;d&quot;); // 将svg图形路径转换为threejs的shape几何体 var shape = transformSVGPathExposed(svgString); return shape; &#125; function createMesh(geom) &#123; // 矩阵变换(平移、旋转、缩放)， geom.applyMatrix(new THREE.Matrix4().makeTranslation(-390, -74, 0)); // 平移矩阵 var meshMaterial = new THREE.MeshPhongMaterial(&#123;color: 0x333333, shininess: 100, metal: true&#125;); var mesh = new THREE.Mesh(geom, meshMaterial); mesh.scale.x = 0.1; mesh.scale.y = 0.1; mesh.rotation.z = Math.PI; mesh.rotation.x = -1.1; return mesh; &#125; function render() &#123; stats.update(); shape.rotation.y += 0.005; orbit.update(); requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4. THREE.ParametricGeometry它可以创建基于公式的几何体。 属性 描述 function 该函数以u、v值作为参数来定义每个顶点的位置，参数取值范围都是0~1 slices 该属性定义u值应该分成多少份 stacks 该属性定义v值应该分成多少份 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;!-- chapter-06-06.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Parametric geometries&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; camera.position.x = -30; camera.position.y = 50; camera.position.z = 50; camera.lookAt(new THREE.Vector3(10, -20, 0)); var spotLight = new THREE.DirectionalLight(); spotLight.position = new THREE.Vector3(-20, 250, -50); spotLight.target.position.x = 30; spotLight.target.position.y = -40; spotLight.target.position.z = -20; spotLight.intensity = 0.3; scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); // 公式1 klein = function (u, v) &#123; u *= Math.PI; v *= 2 * Math.PI; u = u * 2; var x, y, z; if (u &lt; Math.PI) &#123; x = 3 * Math.cos(u) * (1 + Math.sin(u)) + (2 * (1 - Math.cos(u) / 2)) * Math.cos(u) * Math.cos(v); z = -8 * Math.sin(u) - 2 * (1 - Math.cos(u) / 2) * Math.sin(u) * Math.cos(v); &#125; else &#123; x = 3 * Math.cos(u) * (1 + Math.sin(u)) + (2 * (1 - Math.cos(u) / 2)) * Math.cos(v + Math.PI); z = -8 * Math.sin(u); &#125; y = -2 * (1 - Math.cos(u) / 2) * Math.sin(v); return new THREE.Vector3(x, y, z); &#125;; // 公式2, 类似波浪 radialWave = function (u, v) &#123; var r = 50; var x = Math.sin(u) * r; var z = Math.sin(v / 2) * 2 * r; var y = (Math.sin(u * 4 * Math.PI) + Math.cos(v * 2 * Math.PI)) * 2.8; return new THREE.Vector3(x, y, z); &#125;; // 通过公式创建几何体网格 var mesh = createMesh(new THREE.ParametricGeometry(radialWave, 120, 120, false)); scene.add(mesh); function createMesh(geom) &#123; // 平移矩阵变换 geom.applyMatrix(new THREE.Matrix4().makeTranslation(-25, 0, -25)); var meshMaterial = new THREE.MeshPhongMaterial(&#123; specular: 0xaaaafff, color: 0x3399ff, shininess: 40, metal: true &#125;); meshMaterial.side = THREE.DoubleSide; var plane = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial]); return plane; &#125; var step = 0; function render() &#123; stats.update(); mesh.rotation.y = step += 0.01; mesh.rotation.x = step; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5. THREE.TextGeometry创建三维字体文本。其内部使用的是THREE.ExtrudeGeometry拉伸。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&lt;!-- chapter-06-07.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Text geometry&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../assets/fonts/helvetiker_regular.typeface.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../assets/fonts/helvetiker_bold.typeface.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../assets/fonts/bitstream_vera_sans_mono_roman.typeface.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0x000000, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; camera.position.x = 100; camera.position.y = 300; camera.position.z = 600; camera.lookAt(new THREE.Vector3(400, 0, -300)); var dirLight = new THREE.DirectionalLight(); dirLight.position.set(25, 23, 15); scene.add(dirLight); var dirLight2 = new THREE.DirectionalLight(); dirLight2.position.set(-25, 23, 15); scene.add(dirLight2); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var text1; var text2; var controls = new function () &#123; this.size = 90; this.height = 90; this.bevelThickness = 2; this.bevelSize = 0.5; this.bevelEnabled = true; this.bevelSegments = 3; this.bevelEnabled = true; this.curveSegments = 12; this.steps = 1; this.font = &quot;helvetiker&quot;; this.weight = &quot;normal&quot;;// this.style = &quot;italics&quot;; this.asGeom = function () &#123; scene.remove(text1); scene.remove(text2); var options = &#123; size: controls.size, height: controls.height, weight: controls.weight, font: controls.font, bevelThickness: controls.bevelThickness, bevelSize: controls.bevelSize, bevelSegments: controls.bevelSegments, bevelEnabled: controls.bevelEnabled, curveSegments: controls.curveSegments, steps: controls.steps &#125;; // 创建三维字体 text1 = createMesh(new THREE.TextGeometry(&quot;Learning&quot;, options)); text1.position.z = -100; text1.position.y = 100; scene.add(text1); text2 = createMesh(new THREE.TextGeometry(&quot;Three.js&quot;, options)); scene.add(text2); &#125;; &#125;; controls.asGeom(); var gui = new dat.GUI(); gui.add(controls, &#x27;size&#x27;, 0, 200).onChange(controls.asGeom); gui.add(controls, &#x27;height&#x27;, 0, 200).onChange(controls.asGeom); gui.add(controls, &#x27;font&#x27;, [&#x27;bitstream vera sans mono&#x27;, &#x27;helvetiker&#x27;]).onChange(controls.asGeom); gui.add(controls, &#x27;bevelThickness&#x27;, 0, 10).onChange(controls.asGeom); gui.add(controls, &#x27;bevelSize&#x27;, 0, 10).onChange(controls.asGeom); gui.add(controls, &#x27;bevelSegments&#x27;, 0, 30).step(1).onChange(controls.asGeom); gui.add(controls, &#x27;bevelEnabled&#x27;).onChange(controls.asGeom); gui.add(controls, &#x27;curveSegments&#x27;, 1, 30).step(1).onChange(controls.asGeom); gui.add(controls, &#x27;steps&#x27;, 1, 5).step(1).onChange(controls.asGeom); function createMesh(geom) &#123; var meshMaterial = new THREE.MeshPhongMaterial(&#123; specular: 0xffffff, color: 0xeeffff, shininess: 100, metal: true &#125;); var plane = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial]); return plane; &#125; function render() &#123; stats.update(); requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 6. 二元操作就是将各种标准几何体组合在一起创建出新的几何体。这被称为CSG技术，在ThreeBSP扩展库中(https://github.com/skalnik/ThreeBSP)。这个扩展库提供了如下三个函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233&lt;!-- chapter-06-08.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Binary operations&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/spin.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/ThreeBSP.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(0x999999, 1.0); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; var sphere1 = createMesh(new THREE.SphereGeometry(5, 20, 30)); sphere1.position.x = -2; var sphere2 = createMesh(new THREE.SphereGeometry(5, 20, 30)); sphere2.position.set(3, 0, 0); var cube = createMesh(new THREE.BoxGeometry(5, 5, 5)); cube.position.x = -7; scene.add(sphere1); scene.add(sphere2); scene.add(cube); camera.position.x = 0; camera.position.y = 20; camera.position.z = 20; camera.lookAt(new THREE.Vector3(0, 0, 0)); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var controls = new function () &#123; this.sphere1PosX = sphere1.position.x; this.sphere1PosY = sphere1.position.y; this.sphere1PosZ = sphere1.position.z; this.sphere1Scale = 1; this.sphere2PosX = sphere2.position.x; this.sphere2PosY = sphere2.position.y; this.sphere2PosZ = sphere2.position.z; this.sphere2Scale = 1; this.cubePosX = cube.position.x; this.cubePosY = cube.position.y; this.cubePosZ = cube.position.z; this.scaleX = 1; this.scaleY = 1; this.scaleZ = 1; this.actionCube = &quot;subtract&quot;; // add, substract, intersect this.actionSphere = &quot;subtract&quot;; this.showResult = function () &#123; redrawResult(); &#125;; this.hideWireframes = false; this.rotateResult = false; &#125;; var gui = new dat.GUI(); var guiSphere1 = gui.addFolder(&quot;Sphere1&quot;); guiSphere1.add(controls, &quot;sphere1PosX&quot;, -15, 15).onChange(function () &#123; sphere1.position.set(controls.sphere1PosX, controls.sphere1PosY, controls.sphere1PosZ) &#125;); guiSphere1.add(controls, &quot;sphere1PosY&quot;, -15, 15).onChange(function () &#123; sphere1.position.set(controls.sphere1PosX, controls.sphere1PosY, controls.sphere1PosZ) &#125;); guiSphere1.add(controls, &quot;sphere1PosZ&quot;, -15, 15).onChange(function () &#123; sphere1.position.set(controls.sphere1PosX, controls.sphere1PosY, controls.sphere1PosZ) &#125;); guiSphere1.add(controls, &quot;sphere1Scale&quot;, 0, 10).onChange(function (e) &#123; sphere1.scale.set(e, e, e) &#125;); var guiSphere2 = gui.addFolder(&quot;Sphere2&quot;); guiSphere2.add(controls, &quot;sphere2PosX&quot;, -15, 15).onChange(function () &#123; sphere2.position.set(controls.sphere2PosX, controls.sphere2PosY, controls.sphere2PosZ) &#125;); guiSphere2.add(controls, &quot;sphere2PosY&quot;, -15, 15).onChange(function () &#123; sphere2.position.set(controls.sphere2PosX, controls.sphere2PosY, controls.sphere2PosZ) &#125;); guiSphere2.add(controls, &quot;sphere2PosZ&quot;, -15, 15).onChange(function () &#123; sphere2.position.set(controls.sphere2PosX, controls.sphere2PosY, controls.sphere2PosZ) &#125;); guiSphere2.add(controls, &quot;sphere2Scale&quot;, 0, 10).onChange(function (e) &#123; sphere2.scale.set(e, e, e) &#125;); guiSphere2.add(controls, &quot;actionSphere&quot;, [&quot;subtract&quot;, &quot;intersect&quot;, &quot;union&quot;, &quot;none&quot;]); var guiCube = gui.addFolder(&quot;cube&quot;); guiCube.add(controls, &quot;cubePosX&quot;, -15, 15).onChange(function () &#123; cube.position.set(controls.cubePosX, controls.cubePosY, controls.cubePosZ) &#125;); guiCube.add(controls, &quot;cubePosY&quot;, -15, 15).onChange(function () &#123; cube.position.set(controls.cubePosX, controls.cubePosY, controls.cubePosZ) &#125;); guiCube.add(controls, &quot;cubePosZ&quot;, -15, 15).onChange(function () &#123; cube.position.set(controls.cubePosX, controls.cubePosY, controls.cubePosZ) &#125;); guiCube.add(controls, &quot;scaleX&quot;, 0, 10).onChange(function (e) &#123; cube.scale.x = e &#125;); guiCube.add(controls, &quot;scaleY&quot;, 0, 10).onChange(function (e) &#123; cube.scale.y = e &#125;); guiCube.add(controls, &quot;scaleZ&quot;, 0, 10).onChange(function (e) &#123; cube.scale.z = e &#125;); guiCube.add(controls, &quot;actionCube&quot;, [&quot;subtract&quot;, &quot;intersect&quot;, &quot;union&quot;, &quot;none&quot;]); gui.add(controls, &quot;showResult&quot;); gui.add(controls, &quot;rotateResult&quot;); gui.add(controls, &quot;hideWireframes&quot;).onChange(function () &#123; if (controls.hideWireframes) &#123; sphere1.material.visible = false; sphere2.material.visible = false; cube.material.visible = false; &#125; else &#123; sphere1.material.visible = true; sphere2.material.visible = true; cube.material.visible = true; &#125; &#125;); var result; function redrawResult() &#123; scene.remove(result); // 将网格对象转成ThreeBSP对象(才能使用subtract/intersect/union方法) var sphere1BSP = new ThreeBSP(sphere1); var sphere2BSP = new ThreeBSP(sphere2); var cube2BSP = new ThreeBSP(cube); var resultBSP; // 中间圆与右边圆二元操作 switch (controls.actionSphere) &#123; case &quot;subtract&quot;: resultBSP = sphere1BSP.subtract(sphere2BSP); break; case &quot;intersect&quot;: resultBSP = sphere1BSP.intersect(sphere2BSP); break; case &quot;union&quot;: resultBSP = sphere1BSP.union(sphere2BSP); break; case &quot;none&quot;: // noop; &#125; // 中间圆与左边立方二元操作 if (!resultBSP) resultBSP = sphere1BSP; switch (controls.actionCube) &#123; case &quot;subtract&quot;: resultBSP = resultBSP.subtract(cube2BSP); break; case &quot;intersect&quot;: resultBSP = resultBSP.intersect(cube2BSP); break; case &quot;union&quot;: resultBSP = resultBSP.union(cube2BSP); break; case &quot;none&quot;: // noop; &#125; if (controls.actionCube === &quot;none&quot; &amp;&amp; controls.actionSphere === &quot;none&quot;) &#123; // do nothing &#125; else &#123; // BSP对象转网格对象 result = resultBSP.toMesh(); // 二元操作后重新计算 result.geometry.computeFaceNormals(); result.geometry.computeVertexNormals(); scene.add(result); &#125; &#125; function createMesh(geom) &#123; var meshMaterial = new THREE.MeshNormalMaterial(); meshMaterial.side = THREE.DoubleSide; var wireFrameMat = new THREE.MeshBasicMaterial(&#123;transparency: true, opacity: 0.5, wireframeLinewidth: 0.5&#125;); wireFrameMat.wireframe = true; var mesh = new THREE.Mesh(geom, wireFrameMat); return mesh; &#125; function render() &#123; stats.update(); if (controls.rotateResult &amp;&amp; result) &#123; result.rotation.y += 0.04; result.rotation.z -= 0.005; &#125; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125;; window.onload = init();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/categories/threejs/"}],"tags":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/tags/threejs/"},{"name":"高级几何体","slug":"高级几何体","permalink":"https://cxx001.gitee.io/tags/%E9%AB%98%E7%BA%A7%E5%87%A0%E4%BD%95%E4%BD%93/"}],"keywords":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/categories/threejs/"}]},{"title":"threejs几何体","slug":"threejs/threejs几何体","date":"2023-02-07T01:47:15.000Z","updated":"2023-03-14T05:41:30.942Z","comments":true,"path":"2023/02/07/threejs/threejs几何体/","link":"","permalink":"https://cxx001.gitee.io/2023/02/07/threejs/threejs%E5%87%A0%E4%BD%95%E4%BD%93/","excerpt":"","text":"前面在场景那节只是简单介绍了threejs中可用的几何体，本节和下一节将深入讨论threejs提供的所有几何体(不包括上一节探讨过的THREE.Line)。 二维几何体THREE.PlaneGeometry它可以用来创建一个非常简单的二维矩形。 属性 描述 width（宽度） 指定矩形宽度 height（高度） 指定矩形高度 widthSegments（宽度段数） 指定矩形宽度应该划分为几段，默认为1 heightSegments（高度段数） 指定矩形高度应该划分为几段，默认为1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;!-- chapter-05-01.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Basic 2D geometries - Plane&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; // 创建平面网格 var plane = createMesh(new THREE.PlaneGeometry(10, 14, 4, 4)); scene.add(plane); camera.position.x = -20; camera.position.y = 30; camera.position.z = 40; camera.lookAt(new THREE.Vector3(10, 0, 0)); var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(-40, 60, -10); scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var controls = new function () &#123; // 因为plane是使用组合材质创建，所以这里取children的第一个 this.width = plane.children[0].geometry.parameters.width; this.height = plane.children[0].geometry.parameters.height; this.widthSegments = plane.children[0].geometry.parameters.widthSegments; this.heightSegments = plane.children[0].geometry.parameters.heightSegments; // 重新绘制 this.redraw = function () &#123; scene.remove(plane); plane = createMesh(new THREE.PlaneGeometry(controls.width, controls.height, Math.round(controls.widthSegments), Math.round(controls.heightSegments))); scene.add(plane); &#125;; &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;width&#x27;, 0, 40).onChange(controls.redraw); gui.add(controls, &#x27;height&#x27;, 0, 40).onChange(controls.redraw); gui.add(controls, &#x27;widthSegments&#x27;, 0, 10).onChange(controls.redraw); gui.add(controls, &#x27;heightSegments&#x27;, 0, 10).onChange(controls.redraw); render(); // 创建平面网格 function createMesh(geom) &#123; var meshMaterial = new THREE.MeshNormalMaterial(); meshMaterial.side = THREE.DoubleSide; // 背面/前面两面可见 var wireFrameMat = new THREE.MeshBasicMaterial(); wireFrameMat.wireframe = true; var plane = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMat]); return plane; &#125; function render() &#123; stats.update(); plane.rotation.y += 0.01; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; THREE.CircleGeometry它可以创建一个非常简单的二维圆(或部分圆)。 属性 描述 radius 设置圆的半径，默认为50 segments 设置创建圆所用面的数量，最小值是3，默认是8。值越大，圆越光滑 thetaStart 设置从哪里开始画圆，取值范围是0到2*PI， 默认为0 thetaLength 设置圆画的弧度，默认是2*PI(整圆) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;!-- chapter-05-02.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Basic 2D geometries - Circle&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; // 创建圆形网格 var circle = createMesh(new THREE.CircleGeometry(4, 10, 0.3 * Math.PI * 2, 0.3 * Math.PI * 2)); scene.add(circle); camera.position.x = -20; camera.position.y = 30; camera.position.z = 40; camera.lookAt(new THREE.Vector3(10, 0, 0)); var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(-40, 60, -10); scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var controls = new function () &#123; this.radius = 4; this.thetaStart = 0.3 * Math.PI * 2; this.thetaLength = 0.3 * Math.PI * 2; this.segments = 10; this.redraw = function () &#123; scene.remove(circle); circle = createMesh(new THREE.CircleGeometry(controls.radius, controls.segments, controls.thetaStart, controls.thetaLength)); scene.add(circle); &#125;; &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;radius&#x27;, 0, 40).onChange(controls.redraw); gui.add(controls, &#x27;segments&#x27;, 0, 40).onChange(controls.redraw); gui.add(controls, &#x27;thetaStart&#x27;, 0, 2 * Math.PI).onChange(controls.redraw); gui.add(controls, &#x27;thetaLength&#x27;, 0, 2 * Math.PI).onChange(controls.redraw); render(); // 创建圆形网格 function createMesh(geom) &#123; var meshMaterial = new THREE.MeshNormalMaterial(); meshMaterial.side = THREE.DoubleSide; var wireFrameMat = new THREE.MeshBasicMaterial(); wireFrameMat.wireframe = true; var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMat]); return mesh; &#125; function render() &#123; stats.update(); circle.rotation.y += 0.01; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; THREE.RingGeometry它和上面圆类似，但它可以在中心定义一个孔。 属性 描述 innerRadius 圆环的内半径，它定义中心圆孔的尺寸。如果设置为0，则不会显示圆孔。默认值为0 outerRadius 圆环的外半径，它定义圆环的尺寸。默认值为50 thetaSegments 指定圆环的对角线段数量，越大则圆环更平滑。默认为8 phiSegments 指定沿着圆环的长度所需要使用的线段数量。默认为8。它不会影响圆的平滑度，只会增加面的数量 thetaStart 指定从哪里开始画圆 thetaLength 指定画圆的弧度大小 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!-- chapter-05-03.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Basic 2D geometries - Ring&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; // 创建圆环网格 var torus = createMesh(new THREE.RingGeometry()); scene.add(torus); camera.position.x = -30; camera.position.y = 40; camera.position.z = 50; camera.lookAt(new THREE.Vector3(10, 0, 0)); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var controls = new function () &#123; this.innerRadius = 0; this.outerRadius = 50; this.thetaSegments = 8; this.phiSegments = 8; this.thetaStart = 0; this.thetaLength = Math.PI * 2; this.redraw = function () &#123; scene.remove(torus); torus = createMesh(new THREE.RingGeometry(controls.innerRadius, controls.outerRadius, controls.thetaSegments, controls.phiSegments, controls.thetaStart, controls.thetaLength)); scene.add(torus); &#125;; &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;innerRadius&#x27;, 0, 40).onChange(controls.redraw); gui.add(controls, &#x27;outerRadius&#x27;, 0, 100).onChange(controls.redraw); gui.add(controls, &#x27;thetaSegments&#x27;, 1, 40).step(1).onChange(controls.redraw); gui.add(controls, &#x27;phiSegments&#x27;, 1, 20).step(1).onChange(controls.redraw); gui.add(controls, &#x27;thetaStart&#x27;, 0, Math.PI * 2).onChange(controls.redraw); gui.add(controls, &#x27;thetaLength&#x27;, 0, Math.PI * 2).onChange(controls.redraw); // 创建圆环网格 function createMesh(geom) &#123; var meshMaterial = new THREE.MeshNormalMaterial(); meshMaterial.side = THREE.DoubleSide; var wireFrameMat = new THREE.MeshBasicMaterial(); wireFrameMat.wireframe = true; var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMat]); return mesh; &#125; render(); function render() &#123; stats.update(); torus.rotation.y += 0.01; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; THREE.ShapeGeometry它可以自定义二维图形。 先来看看THREE.ShapeGeometry方法的参数： 上面传入参数最重要的就是shapes，THREE.Shape对象的创建。它可以用来创建图形，所以下面介绍它的绘图函数。 THREE.Shape对象的一些辅助函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167&lt;!-- chapter-05-04.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Basic 2D geometries - Shape&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; // 创建自定义网格 var shape = createMesh(new THREE.ShapeGeometry(drawShape())); scene.add(shape); camera.position.x = -30; camera.position.y = 70; camera.position.z = 70; camera.lookAt(new THREE.Vector3(10, 0, 0)); var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(-40, 60, -10); scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var controls = new function () &#123; // 重绘自定义网格 this.asGeom = function () &#123; scene.remove(shape); shape = createMesh(new THREE.ShapeGeometry(drawShape())); scene.add(shape); &#125;; // 重绘自定义几何体线框 this.asPoints = function () &#123; scene.remove(shape); shape = createLine(drawShape(), false); scene.add(shape); &#125;; // 同上，使用另一种方式创建 this.asSpacedPoints = function () &#123; scene.remove(shape); shape = createLine(drawShape(), true); scene.add(shape); &#125;; &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;asGeom&#x27;); gui.add(controls, &#x27;asPoints&#x27;); gui.add(controls, &#x27;asSpacedPoints&#x27;); // 创建自定义的Shape对象 function drawShape() &#123; // create a basic shape var shape = new THREE.Shape(); // startpoint shape.moveTo(10, 10); // straight line upwards shape.lineTo(10, 40); // the top of the figure, curve to the right shape.bezierCurveTo(15, 25, 25, 25, 30, 40); // spline back down shape.splineThru( [new THREE.Vector2(32, 30), new THREE.Vector2(28, 20), new THREE.Vector2(30, 10), ]); // curve at the bottom shape.quadraticCurveTo(20, 15, 10, 10); // add &#x27;eye&#x27; hole one var hole1 = new THREE.Path(); hole1.absellipse(16, 24, 2, 3, 0, Math.PI * 2, true); shape.holes.push(hole1); // add &#x27;eye hole 2&#x27; var hole2 = new THREE.Path(); hole2.absellipse(23, 24, 2, 3, 0, Math.PI * 2, true); shape.holes.push(hole2); // add &#x27;mouth&#x27; var hole3 = new THREE.Path(); hole3.absarc(20, 16, 2, 0, Math.PI, true); shape.holes.push(hole3); // return the shape return shape; &#125; // 创建自定义网格 function createMesh(geom) &#123; var meshMaterial = new THREE.MeshNormalMaterial(); meshMaterial.side = THREE.DoubleSide; var wireFrameMat = new THREE.MeshBasicMaterial(); wireFrameMat.wireframe = true; var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMat]); return mesh; &#125; // 使用THREE.Shape的两个辅助函数创建自定义网格的线框 function createLine(shape, spaced) &#123; if (!spaced) &#123; var mesh = new THREE.Line(shape.createPointsGeometry(10), new THREE.LineBasicMaterial(&#123; color: 0xff3333, linewidth: 2 &#125;)); return mesh; &#125; else &#123; // TODO: 目前测试这个方式会报错? var mesh = new THREE.Line(shape.createSpacedPointsGeometry(3), new THREE.LineBasicMaterial(&#123; color: 0xff3333, linewidth: 2 &#125;)); return mesh; &#125; &#125; render(); function render() &#123; stats.update(); shape.rotation.y += 0.01; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 三维几何体THREE.BoxGeometry这是一个非常简单的三维几何体，只需要指定宽、高和深度就可以创建一个长方体。 属性 描述 width 指定长方体的宽度 height 指定长方体的高度 depth 指定长方体的深度 widthSegments 指定宽分成多少份，默认值为1 heightSegments 指定高分成多少份，默认值为1 depthSegments 指定深度分成多少份，默认值为1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;!-- chapter-05-05.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Basic 2D geometries - Cube&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; // 创建长方体网格 var cube = createMesh(new THREE.BoxGeometry(10, 10, 10, 1, 1, 1)); scene.add(cube); camera.position.x = -20; camera.position.y = 30; camera.position.z = 40; camera.lookAt(new THREE.Vector3(10, 0, 0)); var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(-40, 60, -10); scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var controls = new function () &#123; this.width = cube.children[0].geometry.parameters.width; this.height = cube.children[0].geometry.parameters.height; this.depth = cube.children[0].geometry.parameters.depth; this.widthSegments = cube.children[0].geometry.parameters.widthSegments; this.heightSegments = cube.children[0].geometry.parameters.heightSegments; this.depthSegments = cube.children[0].geometry.parameters.depthSegments; this.redraw = function () &#123; scene.remove(cube); cube = createMesh(new THREE.BoxGeometry(controls.width, controls.height, controls.depth, Math.round(controls.widthSegments), Math.round(controls.heightSegments), Math.round(controls.depthSegments))); scene.add(cube); &#125;; &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;width&#x27;, 0, 40).onChange(controls.redraw); gui.add(controls, &#x27;height&#x27;, 0, 40).onChange(controls.redraw); gui.add(controls, &#x27;depth&#x27;, 0, 40).onChange(controls.redraw); gui.add(controls, &#x27;widthSegments&#x27;, 0, 10).onChange(controls.redraw); gui.add(controls, &#x27;heightSegments&#x27;, 0, 10).onChange(controls.redraw); gui.add(controls, &#x27;depthSegments&#x27;, 0, 10).onChange(controls.redraw); // 创建网格 function createMesh(geom) &#123; var meshMaterial = new THREE.MeshNormalMaterial(); meshMaterial.side = THREE.DoubleSide; var wireFrameMat = new THREE.MeshBasicMaterial(); wireFrameMat.wireframe = true; var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMat]); return mesh; &#125; function render() &#123; stats.update(); cube.rotation.y += 0.01; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; THREE.SphereGeometry它可以创建一个三维的球体。这个几何体非常灵活，可以用来创建所有跟球体相关的几何体。通过下面这些属性调节球体相关几何体网格的外观： 属性 描述 radius 设置球体的半径，默认值为50 widthSegments 球体竖直方向分段数，值越大，球体表面越光滑。默认值为8，最小值为3 heightSegments 水平方向分段数，同上 phiStart 指定从x轴的什么地方开始绘制球体 phiLength 指定从phiStart开始画多少弧度 thetaStart 指定从y轴的什么地方开始绘制球体 thetaLength 指定从phetaStart开始画多少弧度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;!-- chapter-05-06.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Basic 3D geometries - Sphere&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; // 创建球体网格 var sphere = createMesh(new THREE.SphereGeometry(4, 10, 10)); scene.add(sphere); camera.position.x = -20; camera.position.y = 30; camera.position.z = 40; camera.lookAt(new THREE.Vector3(10, 0, 0)); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var controls = new function () &#123; this.radius = sphere.children[0].geometry.parameters.radius; this.widthSegments = sphere.children[0].geometry.parameters.widthSegments; this.heightSegments = sphere.children[0].geometry.parameters.heightSegments; this.phiStart = 0; this.phiLength = Math.PI * 2; this.thetaStart = 0; this.thetaLength = Math.PI; this.redraw = function () &#123; scene.remove(sphere); sphere = createMesh(new THREE.SphereGeometry(controls.radius, controls.widthSegments, controls.heightSegments, controls.phiStart, controls.phiLength, controls.thetaStart, controls.thetaLength)); scene.add(sphere); &#125;; &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;radius&#x27;, 0, 40).onChange(controls.redraw); gui.add(controls, &#x27;widthSegments&#x27;, 0, 20).onChange(controls.redraw); gui.add(controls, &#x27;heightSegments&#x27;, 0, 20).onChange(controls.redraw); gui.add(controls, &#x27;phiStart&#x27;, 0, 2 * Math.PI).onChange(controls.redraw); gui.add(controls, &#x27;phiLength&#x27;, 0, 2 * Math.PI).onChange(controls.redraw); gui.add(controls, &#x27;thetaStart&#x27;, 0, 2 * Math.PI).onChange(controls.redraw); gui.add(controls, &#x27;thetaLength&#x27;, 0, 2 * Math.PI).onChange(controls.redraw); // 创建网格 function createMesh(geom) &#123; var meshMaterial = new THREE.MeshNormalMaterial(); meshMaterial.side = THREE.DoubleSide; var wireFrameMat = new THREE.MeshBasicMaterial(); wireFrameMat.wireframe = true; var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMat]); return mesh; &#125; function render() &#123; stats.update(); sphere.rotation.y += 0.01; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; THREE.CylinderGeometry它可以创建圆柱和类似圆柱的物体。 属性 描述 radiusTop 设置圆柱顶部的尺寸，默认值为20 radiusBottom 设置圆柱底部的尺寸，默认值为20 height 设置圆柱的高度，默认值为100 radialSegments 设置沿半径分为多少段。默认值为8，值越大越光滑 heightSegments 设置沿高度分成多少段。默认值为1，值越大面越多 openEnded 设置网格顶部和底部是否封闭。默认为false 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!-- chapter-05-07.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Basic 3D geometries - Cylinder&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; // 创建圆柱体 var cylinder = createMesh(new THREE.CylinderGeometry(20, 20, 20)); scene.add(cylinder); camera.position.x = -30; camera.position.y = 40; camera.position.z = 50; camera.lookAt(new THREE.Vector3(10, 0, 0)); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var controls = new function () &#123; this.radiusTop = 20; this.radiusBottom = 20; this.height = 20; this.radialSegments = 8; this.heightSegments = 8; this.openEnded = false; this.redraw = function () &#123; scene.remove(cylinder); cylinder = createMesh(new THREE.CylinderGeometry(controls.radiusTop, controls.radiusBottom, controls.height, controls.radialSegments, controls.heightSegments, controls.openEnded)); scene.add(cylinder); &#125;; &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;radiusTop&#x27;, -40, 40).onChange(controls.redraw); gui.add(controls, &#x27;radiusBottom&#x27;, -40, 40).onChange(controls.redraw); gui.add(controls, &#x27;height&#x27;, 0, 40).onChange(controls.redraw); gui.add(controls, &#x27;radialSegments&#x27;, 1, 20).step(1).onChange(controls.redraw); gui.add(controls, &#x27;heightSegments&#x27;, 1, 20).step(1).onChange(controls.redraw); gui.add(controls, &#x27;openEnded&#x27;).onChange(controls.redraw); function createMesh(geom) &#123; var meshMaterial = new THREE.MeshNormalMaterial(); meshMaterial.side = THREE.DoubleSide; var wireFrameMat = new THREE.MeshBasicMaterial(); wireFrameMat.wireframe = true; var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMat]); return mesh; &#125; function render() &#123; stats.update(); cylinder.rotation.y += 0.01; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ​ 把顶部或底部设置为负数的半径，可以创建一个类似沙漏的图形。 THREE.TorusGeometry它可以创建圆环。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;!-- chapter-05-08.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Basic 3D geometries - Torus&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; // 创建圆环网格 var torus = createMesh(new THREE.TorusGeometry(10, 10, 8, 6, Math.PI * 2)); scene.add(torus); camera.position.x = -30; camera.position.y = 40; camera.position.z = 50; camera.lookAt(new THREE.Vector3(10, 0, 0)); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var controls = new function () &#123; this.radius = torus.children[0].geometry.parameters.radius; this.tube = torus.children[0].geometry.parameters.tube; this.radialSegments = torus.children[0].geometry.parameters.radialSegments; this.tubularSegments = torus.children[0].geometry.parameters.tubularSegments; this.arc = torus.children[0].geometry.parameters.arc; this.redraw = function () &#123; scene.remove(torus); torus = createMesh(new THREE.TorusGeometry(controls.radius, controls.tube, Math.round(controls.radialSegments), Math.round(controls.tubularSegments), controls.arc)); scene.add(torus); &#125;; &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;radius&#x27;, 0, 40).onChange(controls.redraw); gui.add(controls, &#x27;tube&#x27;, 0, 40).onChange(controls.redraw); gui.add(controls, &#x27;radialSegments&#x27;, 0, 40).onChange(controls.redraw); gui.add(controls, &#x27;tubularSegments&#x27;, 1, 20).onChange(controls.redraw); gui.add(controls, &#x27;arc&#x27;, 0, Math.PI * 2).onChange(controls.redraw); function createMesh(geom) &#123; var meshMaterial = new THREE.MeshNormalMaterial(); meshMaterial.side = THREE.DoubleSide; var wireFrameMat = new THREE.MeshBasicMaterial(); wireFrameMat.wireframe = true; var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMat]); return mesh; &#125; function render() &#123; stats.update(); torus.rotation.y += 0.01; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; THREE.TorusKnotGeometry它可以创建一个环状扭结，看起来像一根管子绕自己转了几圈。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;!-- chapter-05-09.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Basic 3D geometries - Torusknot&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; // 创建环状扭结 var knot = createMesh(new THREE.TorusKnotGeometry(10, 1, 64, 8, 2, 3, 1)); scene.add(knot); camera.position.x = -30; camera.position.y = 40; camera.position.z = 50; camera.lookAt(new THREE.Vector3(10, 0, 0)); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var controls = new function () &#123; this.radius = knot.children[0].geometry.parameters.radius; this.tube = 0.3; this.radialSegments = knot.children[0].geometry.parameters.radialSegments; this.tubularSegments = knot.children[0].geometry.parameters.tubularSegments; this.p = knot.children[0].geometry.parameters.p; this.q = knot.children[0].geometry.parameters.q; this.heightScale = knot.children[0].geometry.parameters.heightScale; this.redraw = function () &#123; scene.remove(knot); knot = createMesh(new THREE.TorusKnotGeometry(controls.radius, controls.tube, Math.round(controls.radialSegments), Math.round(controls.tubularSegments), Math.round(controls.p), Math.round(controls.q), controls.heightScale)); scene.add(knot); &#125;; &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;radius&#x27;, 0, 40).onChange(controls.redraw); gui.add(controls, &#x27;tube&#x27;, 0, 40).onChange(controls.redraw); gui.add(controls, &#x27;radialSegments&#x27;, 0, 400).step(1).onChange(controls.redraw); gui.add(controls, &#x27;tubularSegments&#x27;, 1, 20).step(1).onChange(controls.redraw); gui.add(controls, &#x27;p&#x27;, 1, 10).step(1).onChange(controls.redraw); gui.add(controls, &#x27;q&#x27;, 1, 15).step(1).onChange(controls.redraw); gui.add(controls, &#x27;heightScale&#x27;, 0, 5).onChange(controls.redraw); function createMesh(geom) &#123; var meshMaterial = new THREE.MeshNormalMaterial(&#123;&#125;); meshMaterial.side = THREE.DoubleSide; var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial]); return mesh; &#125; function render() &#123; stats.update(); knot.rotation.y += 0.01; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; THREE.PolyhedronGeometry它可以很容易的创建多面体，它是只有平面和直边的几何体。大多数情况下，你不需要直接使用这种几何体，Threejs提供了几种特定的多面体可以直接使用，而不必自己去指定THREE.PolyhedronGeometry的顶点和面。 THREE.PolyhedronGeometry属性： 属性 描述 vertices 设置构成多面体的顶点 indices 设置由vertices创建出的面 radius 设置多面体的大小，默认值为1 detail 如果设置为1，这个多面体每个三角形都会分成4个小三角形，如果设置为2，那4个小三角形中每一个将会继续分成4个小三角形，以此类推 下面是Threejs提供的几个开箱即用的多面体： THREE.lcosahedronGeometry 20面体 THREE.TetrahedronGeometry 4面体 THREE.OctahedronGeometry 8面体 THREE.DodecahedronGeometry 12面体 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!-- chapter-05-10.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Basic 3D geometries - Polyhedron&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; // 创建20面体网格 var polyhedron = createMesh(new THREE.IcosahedronGeometry(10, 0)); scene.add(polyhedron); camera.position.x = -30; camera.position.y = 40; camera.position.z = 50; camera.lookAt(new THREE.Vector3(10, 0, 0)); document.getElementById(&quot;WebGL-output&quot;).appendChild(webGLRenderer.domElement); var controls = new function () &#123; this.radius = 10; this.detail = 0; this.type = &#x27;Icosahedron&#x27;; this.redraw = function () &#123; scene.remove(polyhedron); switch (controls.type) &#123; case &#x27;Icosahedron&#x27;: polyhedron = createMesh(new THREE.IcosahedronGeometry(controls.radius, controls.detail)); break; case &#x27;Tetrahedron&#x27;: polyhedron = createMesh(new THREE.TetrahedronGeometry(controls.radius, controls.detail)); break; case &#x27;Octahedron&#x27;: polyhedron = createMesh(new THREE.OctahedronGeometry(controls.radius, controls.detail)); break; case &#x27;Dodecahedron&#x27;: polyhedron = createMesh(new THREE.DodecahedronGeometry(controls.radius, controls.detail)); break; case &#x27;Custom&#x27;: var vertices = [ 1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1 ]; var indices = [ 2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1 ]; polyhedron = createMesh(new THREE.PolyhedronGeometry(vertices, indices, controls.radius, controls.detail)); break; &#125; scene.add(polyhedron); &#125;; &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;radius&#x27;, 0, 40).step(1).onChange(controls.redraw); gui.add(controls, &#x27;detail&#x27;, 0, 3).step(1).onChange(controls.redraw); gui.add(controls, &#x27;type&#x27;, [&#x27;Icosahedron&#x27;, &#x27;Tetrahedron&#x27;, &#x27;Octahedron&#x27;, &#x27;Dodecahedron&#x27;, &#x27;Custom&#x27;]).onChange(controls.redraw); function createMesh(geom) &#123; var meshMaterial = new THREE.MeshNormalMaterial(); meshMaterial.side = THREE.DoubleSide; var wireFrameMat = new THREE.MeshBasicMaterial(); wireFrameMat.wireframe = true; var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMat]); return mesh; &#125; function render() &#123; stats.update(); polyhedron.rotation.y += 0.01; requestAnimationFrame(render); webGLRenderer.render(scene, camera); &#125; render(); function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/categories/threejs/"}],"tags":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/tags/threejs/"},{"name":"几何体","slug":"几何体","permalink":"https://cxx001.gitee.io/tags/%E5%87%A0%E4%BD%95%E4%BD%93/"}],"keywords":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/categories/threejs/"}]},{"title":"threejs材质","slug":"threejs/threejs材质","date":"2023-02-03T05:30:15.000Z","updated":"2023-03-14T05:43:14.871Z","comments":true,"path":"2023/02/03/threejs/threejs材质/","link":"","permalink":"https://cxx001.gitee.io/2023/02/03/threejs/threejs%E6%9D%90%E8%B4%A8/","excerpt":"","text":"前言前面简单的介绍了材质，你已经了解到材质结合几何体就可以创建网格，网格对象才可以添加到Threejs渲染的场景中。材质就像物体的皮肤，决定了几何体的外表。如，几何体看起来是否像金属、透明与否，或者显示为线框。 threejs提供的材质： 名称 描述 MeshBasicMaterial（网格基础材质） 用于给几何体赋予一种简单的颜色，可显示几何体的线框 MeshDepthMaterial（网格深度材质） 这个材质使用从摄像机到网格的距离来决定如何给网格上色 MeshNormalMaterial（网格法向材质） 根据法向量计算物体表面的颜色 MeshFaceMaterial（网格面材质） 这是一个容器，可以为几何体的各个表面指定不同的材质 MeshLambertMaterial（网格Lambert材质） 这是一种考虑光照影响的材质，用于创建暗淡的、不光亮的物体 MeshPhongMaterial（网格Phong材质） 也是一种考虑光照影响的材质，不过它用于创建光亮的物体 ShaderMaterial（着色器材质） 可以使用自定义的着色器程序，直接控制顶点的放置方式以及像素的着色方式 LineBasicMaterial（直线基础材质） 用于THREE.Line(直线)几何体，用来创建着色的直线 LineDashMaterial（虚线材质） 同上，但允许创建出一种虚线的效果 下面这些特殊材质不在本节讨论，后续章节再讨论 RawShaderMaterial 一种特殊的材质，只能和BufferedGeometry一起使用。会在后面【自定义着色器】那节使用。 SpriteCanvasMaterial 用于给单个点设置样式，在后面【粒子、精灵和点云】那节再讨论 SpriteMaterial 用于给单个点设置样式，在后面【粒子、精灵和点云】那节再讨论 PointCloudMaterial 用于给单个点设置样式，在后面【粒子、精灵和点云】那节再讨论 材质的共有属性Threejs提供了一个材质基类THREE.Material，它列出了所有的共有属性。我们把它分为了下面3类。 请注意，本节不会讨论材质关于纹理和贴图的相关属性以及与动画相关的特殊属性，这些后面再详细讨论。 1. 基础属性最常用的，通过这些属性，可以控制物体的不透明度、是否可见以及如何被引用(id或name)。 属性 描述 id（标志符） 用来标识材质，在创建时自动赋值。第一个材质的值为0，每新增一个值加1 uuid（唯一ID） 这是生成的唯一ID，在内部使用 name（名称） 通过这个属性可以给材质一个名称，用于调试标识 opacity（透明度） 定义物体透明度，赋值范围0~1 transparent（是否透明） 如果为true，会使用指定的透明度为0的渲染物体。如果设置为false，这个物体就不透明(着色更明亮些)。如果使用alpha通道的纹理，该属性就应该设置为true overdraw（过度描绘） 当使用THREE.CanvasRender渲染器时，多边形会被渲染得稍微大些。如果两个多边形边缘有明显间隙时，可以将这个属性设置为true visible（是否可见） 材质是否可见 side（侧面） 定义几何体那个面使用材质，有前面&#x2F;外侧(THREE.FrontSide)是默认值，后面&#x2F;内侧(THREE.BackSide)，双侧(THREE.DoubleSide)，即材质应用到物体得内外两侧 needsUpdate(是否更新) 对于材质的某些修改(threejs默认哪些不会发生变化的属性)，你需要告诉threejs材质已经修改了。如果设置为true，会使用新材质属性更新它的缓存 2. 融合属性每个物体都有一系列的融合属性。这些属性决定了物体如何与背景融合。即两种颜色值混合，得到新的颜色值。 属性 描述 blending（融合） 标准融合方式，一般选择THREE.NormalBlending，这种模式下只显示材质的上层 blendsrc（融合源） 除了使用标准融合模式外，还可以使用blendsrc、blenddst、blendequation来创建自定义的融合模式。这个属性定义源的融合方式，默认值THREE.SrcAlphaFactor，即使用alpha通道进行融合 blenddst（融合目标） 定义目标的融合方式，默认值THREE.OneMinusSrcAlphaFactor，即目标也使用源的alpha通道进行融合，只是使用的值是1 blendequation（融合公式） 定义如何使用blendsrc和blenddst的值。默认为使它们相加(AddEquation) 3. 高级属性可以控制底层的WebGL上下文对象渲染物体的方式。大多数情况下不需要使用这些属性。这里不深入讨论，如果想了解内部工作细节，可以查看我CSDN博客里OpenGL相关介绍。 属性 描述 depthTest 深度测试，控制是否使用像素深度来计算新像素的值 polygonOffset、polygonOffsetFactor和polygonOffsetUnits 可以控制WebGL的POLYGON_OFFSET_FILL特性。详情参考OpenGL规范 alphatest 如果某个像素的alpha值小于该值，那么该像素不会显示出来。可以使用这个属性移除一些与透明度相关的毛边 Threejs提供的材质1. 简单材质THREE.MeshBasicMaterial这种材质不考虑场景中光照的影响，主要用于绘制简单的平面多边形而且可以显示几何体线框。除了上面提及的共有属性之外，还可以设置下面所列的这些属性: THREE.MeshDepthMaterial这种材质外观不是由光照或某个材质属性决定，而是由物体到摄像机得距离决定的。一般将这种材质与其它材质结合一起使用(这也是材质融合起作用的地方)，从而很容易创建出渐变效果。 额外属性： 名称 描述 wireframe 该属性指定是否显示线框 wireframeLineWidth 该属性指定线框的宽度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;!-- chapter-04-01.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;MeshDepth-Combined Material&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 10, 130); var renderer = new THREE.WebGLRenderer(); renderer.sortObjects = false; // 物体的渲染顺序由他们添加到场景中的顺序所决定(默认是根据它们距离摄像机的空间位置来排序的) renderer.setClearColor(new THREE.Color(0x00000, 1.0)); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMapEnabled = true; camera.position.x = -50; camera.position.y = 40; camera.position.z = 50; camera.near = 7; camera.far = 139; camera.lookAt(scene.position); document.getElementById(&quot;WebGL-output&quot;).appendChild(renderer.domElement); var controls = new function () &#123; // 通过设置摄像机远、近平面距离来观察深度材质物体的表现 this.cameraNear = camera.near; this.cameraFar = camera.far; this.addCube = function () &#123; var cubeSize = Math.ceil(3 + (Math.random() * 3)); // 创建立方几何体 var cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize); // 创建深度材质和基础材质两种材质混合 var cubeMaterial = new THREE.MeshDepthMaterial(); var colorMaterial = new THREE.MeshBasicMaterial(&#123; color: 0x00ff00, transparent: true, blending: THREE.MultiplyBlending &#125;); var cube = new THREE.SceneUtils.createMultiMaterialObject(cubeGeometry, [colorMaterial, cubeMaterial]); // 多种材质创建网格 cube.children[1].scale.set(0.99, 0.99, 0.99); // 避免两个完全相同网格创建在同一位置时可能闪烁的现象 cube.castShadow = true; cube.position.x = -60 + Math.round((Math.random() * 100)); cube.position.y = Math.round((Math.random() * 10)); cube.position.z = -100 + Math.round((Math.random() * 150)); scene.add(cube); &#125;; &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;cameraNear&#x27;, 0, 50).onChange(function (e) &#123; camera.near = e; &#125;); gui.add(controls, &#x27;cameraFar&#x27;, 50, 200).onChange(function (e) &#123; camera.far = e; &#125;); var i = 0; while (i &lt; 20) &#123; controls.addCube(); i++; &#125; render(); function render() &#123; stats.update(); scene.traverse(function (e) &#123; if (e instanceof THREE.Mesh) &#123; e.rotation.x += 0.02; e.rotation.y += 0.02; e.rotation.z += 0.02; &#125; &#125;); requestAnimationFrame(render); renderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init; // 改变窗口大小后适配 function onResize() &#123; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); &#125; window.addEventListener(&#x27;resize&#x27;, onResize, false);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; THREE.MeshNormalMaterial这种材质网格的每一个面颜色都稍有不同，每一个面的颜色由从该面向外指的法向量计算得到的。所谓法向量是指与面垂直的向量。 法向量应用很广泛，它可以决定光的反射，可以用于将纹理映射到三维模型上。幸运的是具体怎么计算Threejs库内部已经帮我们处理了，我们不需要自己计算。 额外属性： 名称 描述 wireframe 该属性指定是否显示线框 wireframeLinewidth 该属性指定线框的宽度 shading 该属性用来设置着色方法: THREE.FlatShading表示平面着色，THREE.SmoothShading表示平滑着色 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171&lt;!-- chapter-04-02.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Mesh normal material&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/CanvasRenderer.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/Projector.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var webGLRenderer = new THREE.WebGLRenderer(); webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); webGLRenderer.setSize(window.innerWidth, window.innerHeight); webGLRenderer.shadowMapEnabled = true; var renderer = webGLRenderer; var groundGeom = new THREE.PlaneGeometry(100, 100, 4, 4); var groundMesh = new THREE.Mesh(groundGeom, new THREE.MeshBasicMaterial(&#123;color: 0x777777&#125;)); groundMesh.rotation.x = -Math.PI / 2; groundMesh.position.y = -20; scene.add(groundMesh); // 添加法向材质球体 var sphereGeometry = new THREE.SphereGeometry(14, 20, 20); var meshMaterial = new THREE.MeshNormalMaterial(&#123;color: 0x7777ff&#125;); var sphere = new THREE.Mesh(sphereGeometry, meshMaterial); sphere.position.x = 0; sphere.position.y = 3; sphere.position.z = 2; scene.add(sphere); camera.position.x = -20; camera.position.y = 30; camera.position.z = 40; camera.lookAt(new THREE.Vector3(10, 0, 0)); var ambientLight = new THREE.AmbientLight(0x0c0c0c); scene.add(ambientLight); var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(-40, 60, -10); spotLight.castShadow = true; scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(renderer.domElement); var controls = new function () &#123; this.wireframe = meshMaterial.wireframe; this.wireframeLinewidth = meshMaterial.wireframeLinewidth; this.shadow = &quot;flat&quot;; this.addArrow = false; &#125;; var gui = new dat.GUI(); var spGui = gui.addFolder(&quot;Mesh&quot;); spGui.add(controls, &#x27;addArrow&#x27;).onChange(function (e) &#123; if(e) &#123; addArrow(sphere); &#125; else &#123; var oldPos = sphere.position.clone(); scene.remove(sphere); sphere = new THREE.Mesh(sphere.geometry.clone(), meshMaterial); sphere.position = oldPos; scene.add(sphere); meshMaterial.needsUpdate = true; &#125; &#125;); spGui.add(controls, &#x27;wireframe&#x27;).onChange(function (e) &#123; meshMaterial.wireframe = e &#125;); spGui.add(controls, &#x27;wireframeLinewidth&#x27;, 0, 20).onChange(function (e) &#123; meshMaterial.wireframeLinewidth = e &#125;); spGui.add(controls, &#x27;shadow&#x27;, [&quot;flat&quot;, &quot;smooth&quot;]).onChange(function (e) &#123; switch (e) &#123; case &quot;flat&quot;: // https://github.com/mrdoob/three.js/issues/1929 meshMaterial.shading = THREE.FlatShading; // 平面着色 break; case &quot;smooth&quot;: meshMaterial.shading = THREE.SmoothShading; // 平滑着色，更加光滑 break; &#125; var oldPos = sphere.position.clone(); scene.remove(sphere); sphere = new THREE.Mesh(sphere.geometry.clone(), meshMaterial); sphere.position = oldPos; scene.add(sphere); meshMaterial.needsUpdate = true; &#125;); // 为几何体每个面添加法向量标志 function addArrow(sphere) &#123; for (var f = 0, fl = sphere.geometry.faces.length; f &lt; fl; f++) &#123; var face = sphere.geometry.faces[f]; var centroid = new THREE.Vector3(0, 0, 0); // 面的3个顶点相加再除以3来计算中心 centroid.add(sphere.geometry.vertices[face.a]); centroid.add(sphere.geometry.vertices[face.b]); centroid.add(sphere.geometry.vertices[face.c]); centroid.divideScalar(3); var arrow = new THREE.ArrowHelper( face.normal, centroid, 2, 0x3333FF, 0.5, 0.5); sphere.add(arrow); &#125; &#125; var step = 0; render(); function render() &#123; stats.update(); sphere.rotation.y = step += 0.01; requestAnimationFrame(render); renderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125;; window.onload = init; // 改变窗口大小后适配 function onResize() &#123; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); &#125; window.addEventListener(&#x27;resize&#x27;, onResize, false);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; THREE.MeshFaceMaterial这种材质并不是一种真正的材质，更像是一种材质容器。它可以给几何体的每个面指定不同的材质。例如立方体的12个面(注意threejs面的基础单元是三角形)，你可以用这种材质给它每个面指定一种材质。 下面使用这种材质创建一个立方魔方： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;!-- chapter-04-03.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Mesh face material&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var renderer = new THREE.WebGLRenderer(); renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMapEnabled = false; var planeGeometry = new THREE.PlaneGeometry(60, 40, 1, 1); var planeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xffffff&#125;); var plane = new THREE.Mesh(planeGeometry, planeMaterial); plane.receiveShadow = true; plane.rotation.x = -0.5 * Math.PI; plane.position.x = 0; plane.position.y = -2; plane.position.z = 0; scene.add(plane); camera.position.x = -40; camera.position.y = 40; camera.position.z = 40; camera.lookAt(scene.position); var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(-40, 60, -10); spotLight.castShadow = true; scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(renderer.domElement); // 创建一个网格父对象(组)用来保存所有的方块网格 var group = new THREE.Mesh(); // 使用网格面材质指定方块每个面材质(默认通过数组下标对应面的materialIndex属性) // 注意方块有12个三角形面，为什么下面只指定了6种材质，是因为默认一个面的2个三角形面的materialIndex是相等的（把每个面的materialIndex属性打印出来就知道了） var mats = []; mats.push(new THREE.MeshBasicMaterial(&#123;color: 0x009e60&#125;)); mats.push(new THREE.MeshBasicMaterial(&#123;color: 0x0051ba&#125;)); mats.push(new THREE.MeshBasicMaterial(&#123;color: 0xffd500&#125;)); mats.push(new THREE.MeshBasicMaterial(&#123;color: 0xff5800&#125;)); mats.push(new THREE.MeshBasicMaterial(&#123;color: 0xC41E3A&#125;)); mats.push(new THREE.MeshBasicMaterial(&#123;color: 0xffffff&#125;)); var faceMaterial = new THREE.MeshFaceMaterial(mats); // 使用网格面材质创建魔方 for (var x = 0; x &lt; 3; x++) &#123; for (var y = 0; y &lt; 3; y++) &#123; for (var z = 0; z &lt; 3; z++) &#123; var cubeGeom = new THREE.BoxGeometry(2.9, 2.9, 2.9); var cube = new THREE.Mesh(cubeGeom, faceMaterial); cube.position.set(x * 3 - 3, y * 3, z * 3 - 3); group.add(cube); &#125; &#125; &#125; scene.add(group); group.translateY(8); render(); function render() &#123; stats.update(); group.rotation.x += 0.02; group.rotation.y += 0.02; group.rotation.z += 0.02; requestAnimationFrame(render); renderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init; // 改变窗口大小后适配 function onResize() &#123; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); &#125; window.addEventListener(&#x27;resize&#x27;, onResize, false);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2. 高级材质THREE.MeshLambertMaterial这种材质可以用来创建暗淡的并不光亮的表面，而且会对场景中的光源产生反应。 除了共有属性外，它还有一些独有的属性： 名称 描述 ambient（环境色） 和环境光源一起使用，这个颜色会与环境光颜色相乘。默认值为白色 emissive（发射颜色） 这个该材质发射的颜色。它其实并不像光源，只是一种纯粹的、不受其它光照影响的颜色。默认为黑色 wrapAround 如果设置为true，则启动半lambert光照技术。可以使光下降得更微妙，柔和并且分布更加均匀 wrapRGB 当wrapAround设置为true时，可以使用THREE.Vector3来控制光下降得速度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130&lt;!-- chapter-04-04.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Mesh Lambert material&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/CanvasRenderer.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/Projector.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var renderer = new THREE.WebGLRenderer(); renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMapEnabled = true; var groundGeom = new THREE.PlaneGeometry(100, 100, 4, 4); var groundMesh = new THREE.Mesh(groundGeom, new THREE.MeshBasicMaterial(&#123;color: 0x555555&#125;)); groundMesh.rotation.x = -Math.PI / 2; groundMesh.position.y = -20; scene.add(groundMesh); // 创建Lambert材质的球体 var sphereGeometry = new THREE.SphereGeometry(14, 20, 20); var meshMaterial = new THREE.MeshLambertMaterial(&#123;color: 0x7777ff&#125;); var sphere = new THREE.Mesh(sphereGeometry, meshMaterial); sphere.position.x = 0; sphere.position.y = 3; sphere.position.z = 2; scene.add(sphere); camera.position.x = -20; camera.position.y = 30; camera.position.z = 40; camera.lookAt(new THREE.Vector3(10, 0, 0)); // 环境光 var ambientLight = new THREE.AmbientLight(0x0c0c0c); scene.add(ambientLight); // 聚光灯 var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(-30, 60, 60); spotLight.castShadow = true; scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(renderer.domElement); var controls = new function () &#123; this.emissive = meshMaterial.emissive.getHex(); // 该材质的环境色属性 this.ambient = meshMaterial.ambient.getHex(); // 该材质的发射颜色属性 this.wrapAround = false; // 是否开启lambert光照技术 this.wrapR = 1; this.wrapG = 1; this.wrapB = 1; &#125;; var gui = new dat.GUI(); var spGui = gui.addFolder(&quot;Mesh&quot;); spGui.addColor(controls, &#x27;ambient&#x27;).onChange(function (e) &#123; meshMaterial.ambient = new THREE.Color(e) &#125;); spGui.addColor(controls, &#x27;emissive&#x27;).onChange(function (e) &#123; meshMaterial.emissive = new THREE.Color(e) &#125;); spGui.add(controls, &#x27;wrapAround&#x27;).onChange(function (e) &#123; meshMaterial.wrapAround = e; meshMaterial.needsUpdate = true; &#125;); spGui.add(controls, &#x27;wrapR&#x27;, 0, 1).step(0.01).onChange(function (e) &#123; meshMaterial.wrapRGB.x = e; &#125;); spGui.add(controls, &#x27;wrapG&#x27;, 0, 1).step(0.01).onChange(function (e) &#123; meshMaterial.wrapRGB.y = e; &#125;); spGui.add(controls, &#x27;wrapB&#x27;, 0, 1).step(0.01).onChange(function (e) &#123; meshMaterial.wrapRGB.z = e; &#125;); render(); function render() &#123; stats.update(); sphere.rotation.y += 0.01; requestAnimationFrame(render); renderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init; // 改变窗口大小后适配 function onResize() &#123; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); &#125; window.addEventListener(&#x27;resize&#x27;, onResize, false);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; THREE.MeshPhongMaterial这种材质可以创建一种光亮的材质，和上面一样，也会对场景中的光源产生反应。 除了共有属性外，这种材质比较有意义的属性如下： 名称 描述 ambient（环境色） 和环境光源一起使用，这个颜色会与环境光颜色相乘。默认值为白色 emissive（发射颜色） 这个该材质发射的颜色。它其实并不像光源，只是一种纯粹的、不受其它光照影响的颜色。默认为黑色 wrapAround 如果设置为true，则启动半lambert光照技术。可以使光下降得更微妙，柔和并且分布更加均匀 wrapRGB 当wrapAround设置为true时，可以使用THREE.Vector3来控制光下降得速度 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;以上同上&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; specular 该属性指定材质的光亮程度及高光部分的颜色。如果将它设置成与color属性相同颜色，将会得到一个更加类似金属的材质。如果设置为灰色，材质将变得更像塑料 shininess 该属性指定镜面高光部分的亮度。默认值为30 metal 如果设置为true，会使用不同的方式计算像素的颜色，使物体看起来更像金属。要注意的是，这个效果非常小 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147&lt;!-- chapter-04-05.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Mesh Phong material&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/CanvasRenderer.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/Projector.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var renderer = new THREE.WebGLRenderer(); renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMapEnabled = true; var groundGeom = new THREE.PlaneGeometry(100, 100, 4, 4); var groundMesh = new THREE.Mesh(groundGeom, new THREE.MeshBasicMaterial(&#123;color: 0x555555&#125;)); groundMesh.rotation.x = -Math.PI / 2; groundMesh.position.y = -20; scene.add(groundMesh); // 创建Phong材质的球体 var sphereGeometry = new THREE.SphereGeometry(14, 20, 20); var meshMaterial = new THREE.MeshPhongMaterial(&#123;color: 0x7777ff&#125;); var sphere = new THREE.Mesh(sphereGeometry, meshMaterial); sphere.position.x = 0; sphere.position.y = 3; sphere.position.z = 2; scene.add(sphere); camera.position.x = -20; camera.position.y = 30; camera.position.z = 40; camera.lookAt(new THREE.Vector3(10, 0, 0)); // 环境光 var ambientLight = new THREE.AmbientLight(0x0c0c0c); scene.add(ambientLight); // 聚光灯 var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(-30, 60, 60); spotLight.castShadow = true; scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(renderer.domElement); var controls = new function () &#123; this.emissive = meshMaterial.emissive.getHex(); // 该材质的环境色属性 this.ambient = meshMaterial.ambient.getHex(); // 该材质的发射颜色属性 this.wrapAround = false; // 是否开启lambert光照技术 this.wrapR = 1; this.wrapG = 1; this.wrapB = 1; this.specular = meshMaterial.specular.getHex(); this.shininess = meshMaterial.shininess; this.metal = false; &#125;; var gui = new dat.GUI(); var spGui = gui.addFolder(&quot;Mesh&quot;); spGui.addColor(controls, &#x27;ambient&#x27;).onChange(function (e) &#123; meshMaterial.ambient = new THREE.Color(e) &#125;); spGui.addColor(controls, &#x27;emissive&#x27;).onChange(function (e) &#123; meshMaterial.emissive = new THREE.Color(e) &#125;); spGui.add(controls, &#x27;wrapAround&#x27;).onChange(function (e) &#123; meshMaterial.wrapAround = e; meshMaterial.needsUpdate = true; &#125;); spGui.add(controls, &#x27;wrapR&#x27;, 0, 1).step(0.01).onChange(function (e) &#123; meshMaterial.wrapRGB.x = e; &#125;); spGui.add(controls, &#x27;wrapG&#x27;, 0, 1).step(0.01).onChange(function (e) &#123; meshMaterial.wrapRGB.y = e; &#125;); spGui.add(controls, &#x27;wrapB&#x27;, 0, 1).step(0.01).onChange(function (e) &#123; meshMaterial.wrapRGB.z = e; &#125;); spGui.addColor(controls, &#x27;specular&#x27;).onChange(function (e) &#123; meshMaterial.specular = new THREE.Color(e) &#125;); spGui.add(controls, &#x27;shininess&#x27;, 0, 200).onChange(function (e) &#123; meshMaterial.shininess = e &#125;); spGui.add(controls, &#x27;metal&#x27;).onChange(function (e) &#123; meshMaterial.metal = e; meshMaterial.needsUpdate = true; &#125;); render(); function render() &#123; stats.update(); sphere.rotation.y += 0.01; requestAnimationFrame(render); renderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init; // 改变窗口大小后适配 function onResize() &#123; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); &#125; window.addEventListener(&#x27;resize&#x27;, onResize, false);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; THREE.ShaderMaterial这种材质可以自己定制着色器，直接在WebGL环境运行。要使用这种材质，必须传入两个不同的着色器： vertexShader：顶点着色器，它会在几何体每一个顶点上执行。可以用它改变顶点位置来对几何体进行变换。 fragmentShader：片段着色器，它会在几何体的每一个片段上执行。片段通常指单独的像素，将顶点着色器传递来的数据进行计算得出需要绘制的像素颜色值。 着色器材质几个特别的属性： 名称 描述 vertexShader 顶点着色器 fragmentShader 片段着色器 uniforms 通过这个属性可以向你的着色器发消息 defines 可以用来设置着色器程序里的一些额外的全局变量 attributes 该属性可以修改每个顶点和片段数据，通常用来传递位置数据和法向量相关数据。 lights 该属性定义光照数据是否传递给着色器。默认为false 这里主要是简单介绍着色器材质如何使用，关于着色器程序相关详情后续单独介绍。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411&lt;!-- chapter-04-06.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Shader material&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;// 顶点着色器&lt;script id=&quot;vertex-shader&quot; type=&quot;x-shader/x-vertex&quot;&gt; uniform float time; varying vec2 vUv; void main() &#123; vec3 posChanged = position; posChanged.x = posChanged.x*(abs(sin(time*1.0))); posChanged.y = posChanged.y*(abs(cos(time*1.0))); posChanged.z = posChanged.z*(abs(sin(time*1.0))); //gl_Position = projectionMatrix * modelViewMatrix * vec4(position*(abs(sin(time)/2.0)+0.5),1.0); gl_Position = projectionMatrix * modelViewMatrix * vec4(posChanged,1.0); &#125;&lt;/script&gt;// 片段着色器_1&lt;script id=&quot;fragment-shader-1&quot; type=&quot;x-shader/x-fragment&quot;&gt; precision highp float; uniform float time; uniform float alpha; uniform vec2 resolution; varying vec2 vUv; void main2(void) &#123; vec2 position = vUv; float red = 1.0; float green = 0.25 + sin(time) * 0.25; float blue = 0.0; vec3 rgb = vec3(red, green, blue); vec4 color = vec4(rgb, alpha); gl_FragColor = color; &#125; #define PI 3.14159 #define TWO_PI (PI*2.0) #define N 68.5 void main(void) &#123; vec2 center = (gl_FragCoord.xy); center.x=-10.12*sin(time/200.0); center.y=-10.12*cos(time/200.0); vec2 v = (gl_FragCoord.xy - resolution/20.0) / min(resolution.y,resolution.x) * 15.0; v.x=v.x-10.0; v.y=v.y-200.0; float col = 0.0; for(float i = 0.0; i &lt; N; i++) &#123; float a = i * (TWO_PI/N) * 61.95; col += cos(TWO_PI*(v.y * cos(a) + v.x * sin(a) + sin(time*0.004)*100.0 )); &#125; col /= 5.0; gl_FragColor = vec4(col*1.0, -col*1.0,-col*4.0, 1.0); &#125;&lt;/script&gt;// 片段着色器_2&lt;script id=&quot;fragment-shader-2&quot; type=&quot;x-shader/x-fragment&quot;&gt; // from http://glsl.heroku.com/e#7906.0 uniform float time; uniform vec2 resolution; #define CGFloat float #define M_PI 3.14159265359 vec3 hsvtorgb(float h, float s, float v) &#123; float c = v * s; h = mod((h * 6.0), 6.0); float x = c * (1.0 - abs(mod(h, 2.0) - 1.0)); vec3 color; if (0.0 &lt;= h &amp;&amp; h &lt; 1.0) &#123; color = vec3(c, x, 0.0); &#125; else if (1.0 &lt;= h &amp;&amp; h &lt; 2.0) &#123; color = vec3(x, c, 0.0); &#125; else if (2.0 &lt;= h &amp;&amp; h &lt; 3.0) &#123; color = vec3(0.0, c, x); &#125; else if (3.0 &lt;= h &amp;&amp; h &lt; 4.0) &#123; color = vec3(0.0, x, c); &#125; else if (4.0 &lt;= h &amp;&amp; h &lt; 5.0) &#123; color = vec3(x, 0.0, c); &#125; else if (5.0 &lt;= h &amp;&amp; h &lt; 6.0) &#123; color = vec3(c, 0.0, x); &#125; else &#123; color = vec3(0.0); &#125; color += v - c; return color; &#125; void main(void) &#123; vec2 position = (gl_FragCoord.xy - 0.5 * resolution) / resolution.y; float x = position.x; float y = position.y; CGFloat a = atan(x, y); CGFloat d = sqrt(x*x+y*y); CGFloat d0 = 0.5*(sin(d-time)+1.5)*d; CGFloat d1 = 5.0; CGFloat u = mod(a*d1+sin(d*10.0+time), M_PI*2.0)/M_PI*0.5 - 0.5; CGFloat v = mod(pow(d0*4.0, 0.75),1.0) - 0.5; CGFloat dd = sqrt(u*u+v*v); CGFloat aa = atan(u, v); CGFloat uu = mod(aa*3.0+3.0*cos(dd*30.0-time), M_PI*2.0)/M_PI*0.5 - 0.5; // CGFloat vv = mod(dd*4.0,1.0) - 0.5; CGFloat d2 = sqrt(uu*uu+v*v)*1.5; gl_FragColor = vec4( hsvtorgb(dd+time*0.5/d1, sin(dd*time), d2), 1.0 ); &#125;&lt;/script&gt;// 片段着色器_3&lt;script id=&quot;fragment-shader-3&quot; type=&quot;x-shader/x-fragment&quot;&gt; uniform vec2 resolution; uniform float time; vec2 rand(vec2 pos) &#123; return fract( 0.00005 * (pow(pos+2.0, pos.yx + 1.0) * 22222.0)); &#125; vec2 rand2(vec2 pos) &#123; return rand(rand(pos)); &#125; float softnoise(vec2 pos, float scale) &#123; vec2 smplpos = pos * scale; float c0 = rand2((floor(smplpos) + vec2(0.0, 0.0)) / scale).x; float c1 = rand2((floor(smplpos) + vec2(1.0, 0.0)) / scale).x; float c2 = rand2((floor(smplpos) + vec2(0.0, 1.0)) / scale).x; float c3 = rand2((floor(smplpos) + vec2(1.0, 1.0)) / scale).x; vec2 a = fract(smplpos); return mix( mix(c0, c1, smoothstep(0.0, 1.0, a.x)), mix(c2, c3, smoothstep(0.0, 1.0, a.x)), smoothstep(0.0, 1.0, a.y)); &#125; void main(void) &#123; vec2 pos = gl_FragCoord.xy / resolution.y; pos.x += time * 0.1; float color = 0.0; float s = 1.0; for(int i = 0; i &lt; 8; i++) &#123; color += softnoise(pos+vec2(i)*0.02, s * 4.0) / s / 2.0; s *= 2.0; &#125; gl_FragColor = vec4(color); &#125;&lt;/script&gt;// 片段着色器_4&lt;script id=&quot;fragment-shader-4&quot; type=&quot;x-shader/x-fragment&quot;&gt; uniform float time; uniform vec2 resolution; vec2 rand(vec2 pos) &#123; return fract( ( pow( pos+2.0, pos.yx+2.0 )*555555.0 ) ); &#125; vec2 rand2(vec2 pos) &#123; return rand(rand(pos)); &#125; float softnoise(vec2 pos, float scale) &#123; vec2 smplpos = pos * scale; float c0 = rand2((floor(smplpos) + vec2(0.0, 0.0)) / scale).x; float c1 = rand2((floor(smplpos) + vec2(1.0, 0.0)) / scale).x; float c2 = rand2((floor(smplpos) + vec2(0.0, 1.0)) / scale).x; float c3 = rand2((floor(smplpos) + vec2(1.0, 1.0)) / scale).x; vec2 a = fract(smplpos); return mix(mix(c0, c1, smoothstep(0.0, 1.0, a.x)), mix(c2, c3, smoothstep(0.0, 1.0, a.x)), smoothstep(0.0, 1.0, a.x)); &#125; void main( void ) &#123; vec2 pos = gl_FragCoord.xy / resolution.y - time * 0.4; float color = 0.0; float s = 1.0; for (int i = 0; i &lt; 6; ++i) &#123; color += softnoise(pos + vec2(0.01 * float(i)), s * 4.0) / s / 2.0; s *= 2.0; &#125; gl_FragColor = vec4(color,mix(color,cos(color),sin(color)),color,1); &#125;&lt;/script&gt;// 片段着色器_5&lt;script id=&quot;fragment-shader-5&quot; type=&quot;x-shader/x-fragment&quot;&gt; uniform float time; uniform vec2 resolution; // tie nd die by Snoep Games. void main( void ) &#123; vec3 color = vec3(1.0, 0., 0.); vec2 pos = (( 1.4 * gl_FragCoord.xy - resolution.xy) / resolution.xx)*1.5; float r=sqrt(pos.x*pos.x+pos.y*pos.y)/15.0; float size1=2.0*cos(time/60.0); float size2=2.5*sin(time/12.1); float rot1=13.00; //82.0+16.0*sin(time/4.0); float rot2=-50.00; //82.0+16.0*sin(time/8.0); float t=sin(time); float a = (60.0)*sin(rot1*atan(pos.x-size1*pos.y/r,pos.y+size1*pos.x/r)+time); a += 200.0*acos(pos.x*2.0+cos(time/2.0))+asin(pos.y*5.0+sin(time/2.0)); a=a*(r/50.0); a=200.0*sin(a*5.0)*(r/30.0); if(a&gt;5.0) a=a/200.0; if(a&lt;0.5) a=a*22.5; gl_FragColor = vec4( cos(a/20.0),a*cos(a/200.0),sin(a/8.0), 1.0 ); &#125;&lt;/script&gt;// 片段着色器_6&lt;script id=&quot;fragment-shader-6&quot; type=&quot;x-shader/x-fragment&quot;&gt; uniform float time; uniform vec2 resolution; void main( void ) &#123; vec2 uPos = ( gl_FragCoord.xy / resolution.xy );//normalize wrt y axis //suPos -= vec2((resolution.x/resolution.y)/2.0, 0.0);//shift origin to center uPos.x -= 1.0; uPos.y -= 0.5; vec3 color = vec3(0.0); float vertColor = 2.0; for( float i = 0.0; i &lt; 15.0; ++i ) &#123; float t = time * (0.9); uPos.y += sin( uPos.x*i + t+i/2.0 ) * 0.1; float fTemp = abs(1.0 / uPos.y / 100.0); vertColor += fTemp; color += vec3( fTemp*(10.0-i)/10.0, fTemp*i/10.0, pow(fTemp,1.5)*1.5 ); &#125; vec4 color_final = vec4(color, 1.0); gl_FragColor = color_final; &#125;&lt;/script&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var renderer = new THREE.WebGLRenderer(); renderer.setClearColor(new THREE.Color(0x000000, 1.0)); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMapEnabled = true; var cubeGeometry = new THREE.BoxGeometry(20, 20, 20); // 创建6种着色器材质 var meshMaterial1 = createMaterial(&quot;vertex-shader&quot;, &quot;fragment-shader-1&quot;); var meshMaterial2 = createMaterial(&quot;vertex-shader&quot;, &quot;fragment-shader-2&quot;); var meshMaterial3 = createMaterial(&quot;vertex-shader&quot;, &quot;fragment-shader-3&quot;); var meshMaterial4 = createMaterial(&quot;vertex-shader&quot;, &quot;fragment-shader-4&quot;); var meshMaterial5 = createMaterial(&quot;vertex-shader&quot;, &quot;fragment-shader-5&quot;); var meshMaterial6 = createMaterial(&quot;vertex-shader&quot;, &quot;fragment-shader-6&quot;); // 每个面使用一种着色器材质 var material = new THREE.MeshFaceMaterial( [meshMaterial1, meshMaterial2, meshMaterial3, meshMaterial4, meshMaterial5, meshMaterial6]); var cube = new THREE.Mesh(cubeGeometry, material); scene.add(cube); camera.position.x = 30; camera.position.y = 30; camera.position.z = 30; camera.lookAt(new THREE.Vector3(0, 0, 0)); var ambientLight = new THREE.AmbientLight(0x0c0c0c); scene.add(ambientLight); var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(-40, 60, -10); spotLight.castShadow = true; scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(renderer.domElement); render(); var step = 0; function render() &#123; stats.update(); cube.rotation.y = step += 0.01; cube.rotation.x = step; cube.rotation.z = step; // 通过uniforms属性给着色器传递数据 cube.material.materials.forEach(function (e) &#123; e.uniforms.time.value += 0.01; &#125;); requestAnimationFrame(render); renderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; // 创建着色器材质 function createMaterial(vertexShader, fragmentShader) &#123; var vertShader = document.getElementById(vertexShader).innerHTML; var fragShader = document.getElementById(fragmentShader).innerHTML; var attributes = &#123;&#125;; var uniforms = &#123; time: &#123;type: &#x27;f&#x27;, value: 0.2&#125;, scale: &#123;type: &#x27;f&#x27;, value: 0.2&#125;, alpha: &#123;type: &#x27;f&#x27;, value: 0.6&#125;, resolution: &#123;type: &quot;v2&quot;, value: new THREE.Vector2()&#125; &#125;; uniforms.resolution.value.x = window.innerWidth; uniforms.resolution.value.y = window.innerHeight; var meshMaterial = new THREE.ShaderMaterial(&#123; uniforms: uniforms, // 传递数据给内部着色器程序(共享内存差不多意思) attributes: attributes, vertexShader: vertShader, fragmentShader: fragShader, transparent: true &#125;); return meshMaterial; &#125; &#125; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3. 线性几何体的材质这些材质只能用于特定的几何体: THREE.Line线段。线段由顶点组成，不包含任何面。THREE.js库提供了两种可用于线段的材质，如下： THREE.LineBasicMaterial：用于线段基础材质，可设置colors、linewidth、linecap和linejoin属性。 THREE.LineDashedMaterial：属性同上，只是多了可以创建虚线效果属性。 THREE.LineBasicMaterial123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200&lt;!-- chapter-04-07.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Line Basic material&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var renderer = new THREE.WebGLRenderer(); renderer.setClearColor(new THREE.Color(0x000000, 1.0)); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMapEnabled = true; camera.position.x = -30; camera.position.y = 40; camera.position.z = 30; camera.lookAt(scene.position); var ambientLight = new THREE.AmbientLight(0x0c0c0c); scene.add(ambientLight); var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(-40, 60, -10); spotLight.castShadow = true; scene.add(spotLight); // 获取一些(x,y)坐标，返回一个gosper曲线 var points = gosper(4, 60); // 使用上面曲线坐标点创建一个几何体对象，设置对应顶点和颜色属性 var lines = new THREE.Geometry(); var colors = []; var i = 0; points.forEach(function (e) &#123; lines.vertices.push(new THREE.Vector3(e.x, e.z, e.y)); colors[i] = new THREE.Color(0xffffff); colors[i].setHSL(e.x / 100 + 0.5, ( e.y * 20 ) / 300, 0.8); i++; &#125;); lines.colors = colors; // 创建线段基础材质 var material = new THREE.LineBasicMaterial(&#123; opacity: 1.0, linewidth: 1, vertexColors: THREE.VertexColors &#125;); // 创建线段网格 var line = new THREE.Line(lines, material); line.position.set(25, -30, -60); scene.add(line); document.getElementById(&quot;WebGL-output&quot;).appendChild(renderer.domElement); render(); function render() &#123; stats.update(); line.rotation.z += 0.01; requestAnimationFrame(render); renderer.render(scene, camera); &#125; // 获取gosper曲线(参考:http://en.wikipedia.org/wiki/Gosper_curve) function gosper(a, b) &#123; var turtle = [0, 0, 0]; var points = []; var count = 0; rg(a, b, turtle); return points; function rt(x) &#123; turtle[2] += x; &#125; function lt(x) &#123; turtle[2] -= x; &#125; function fd(dist) &#123; //ctx.beginPath(); points.push(&#123;x: turtle[0], y: turtle[1], z: Math.sin(count) * 5&#125;); //ctx.moveTo(turtle[0], turtle[1]); var dir = turtle[2] * (Math.PI / 180); turtle[0] += Math.cos(dir) * dist; turtle[1] += Math.sin(dir) * dist; points.push(&#123;x: turtle[0], y: turtle[1], z: Math.sin(count) * 5&#125;); //ctx.lineTo(turtle[0], turtle[1]); //ctx.stroke(); &#125; function rg(st, ln, turtle) &#123; st--; ln = ln / 2.6457; if (st &gt; 0) &#123; //ctx.strokeStyle = &#x27;#111&#x27;; rg(st, ln, turtle); rt(60); gl(st, ln, turtle); rt(120); gl(st, ln, turtle); lt(60); rg(st, ln, turtle); lt(120); rg(st, ln, turtle); rg(st, ln, turtle); lt(60); gl(st, ln, turtle); rt(60); &#125; if (st == 0) &#123; fd(ln); rt(60); fd(ln); rt(120); fd(ln); lt(60); fd(ln); lt(120); fd(ln); fd(ln); lt(60); fd(ln); rt(60) &#125; &#125; function gl(st, ln, turtle) &#123; st--; ln = ln / 2.6457; if (st &gt; 0) &#123; //ctx.strokeStyle = &#x27;#555&#x27;; lt(60); rg(st, ln, turtle); rt(60); gl(st, ln, turtle); gl(st, ln, turtle); rt(120); gl(st, ln, turtle); rt(60); rg(st, ln, turtle); lt(120); rg(st, ln, turtle); lt(60); gl(st, ln, turtle); &#125; if (st == 0) &#123; lt(60); fd(ln); rt(60); fd(ln); fd(ln); rt(120); fd(ln); rt(60); fd(ln); lt(120); fd(ln); lt(60); fd(ln); &#125; &#125; &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125;; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; THREE.LineDashedMaterial这种材质与上面THREE.LineBasicMaterial一样的属性，还有几个额外的属性，可用来定义虚线的宽度和虚线之间的间隙的宽度。 名称 描述 scale 缩放dashSize和gapSize。如果scale值小于1，dashSize和gapSize就会增大，如果大于1，dashSize和gapSize就会减小 dashSize 虚线的长度 gapSize 虚线间隔的宽度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202&lt;!-- chapter-04-08.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Line material Dashed&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var renderer = new THREE.WebGLRenderer(); renderer.setClearColor(new THREE.Color(0x000000, 1.0)); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMapEnabled = true; camera.position.x = -30; camera.position.y = 40; camera.position.z = 30; camera.lookAt(scene.position); var ambientLight = new THREE.AmbientLight(0x0c0c0c); scene.add(ambientLight); var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(-40, 60, -10); spotLight.castShadow = true; scene.add(spotLight); // 创建gosper曲线几何体，设置对应顶点和颜色 var points = gosper(4, 60); var lines = new THREE.Geometry(); var colors = []; var i = 0; points.forEach(function (e) &#123; lines.vertices.push(new THREE.Vector3(e.x, e.z, e.y)); colors[i] = new THREE.Color(0xffffff); colors[i].setHSL(e.x / 100 + 0.5, ( e.y * 20 ) / 300, 0.8); i++; &#125;); lines.colors = colors; lines.computeLineDistances(); // 与上面的区别，这里要加这个。用来计算线段顶点之间的距离，不然间隔就不会正确显示。 // 创建虚线材质 var material = new THREE.LineDashedMaterial(&#123; vertexColors: true, color: 0xffffff, dashSize: 2, gapSize: 2, scale: 0.1 &#125;); // 创建虚线网格对象 var line = new THREE.Line(lines, material); line.position.set(25, -30, -60); scene.add(line); document.getElementById(&quot;WebGL-output&quot;).appendChild(renderer.domElement); render(); function render() &#123; stats.update(); line.rotation.z += 0.01; requestAnimationFrame(render); renderer.render(scene, camera); &#125; // 同上例 function gosper(a, b) &#123; var turtle = [0, 0, 0]; var points = []; var count = 0; rg(a, b, turtle); return points; function rt(x) &#123; turtle[2] += x; &#125; function lt(x) &#123; turtle[2] -= x; &#125; function fd(dist) &#123;// ctx.beginPath(); points.push(&#123;x: turtle[0], y: turtle[1], z: Math.sin(count) * 5&#125;);// ctx.moveTo(turtle[0], turtle[1]); var dir = turtle[2] * (Math.PI / 180); turtle[0] += Math.cos(dir) * dist; turtle[1] += Math.sin(dir) * dist; points.push(&#123;x: turtle[0], y: turtle[1], z: Math.sin(count) * 5&#125;);// ctx.lineTo(turtle[0], turtle[1]);// ctx.stroke(); &#125; function rg(st, ln, turtle) &#123; st--; ln = ln / 2.6457; if (st &gt; 0) &#123;// ctx.strokeStyle = &#x27;#111&#x27;; rg(st, ln, turtle); rt(60); gl(st, ln, turtle); rt(120); gl(st, ln, turtle); lt(60); rg(st, ln, turtle); lt(120); rg(st, ln, turtle); rg(st, ln, turtle); lt(60); gl(st, ln, turtle); rt(60); &#125; if (st == 0) &#123; fd(ln); rt(60); fd(ln); rt(120); fd(ln); lt(60); fd(ln); lt(120); fd(ln); fd(ln); lt(60); fd(ln); rt(60) &#125; &#125; function gl(st, ln, turtle) &#123; st--; ln = ln / 2.6457; if (st &gt; 0) &#123;// ctx.strokeStyle = &#x27;#555&#x27;; lt(60); rg(st, ln, turtle); rt(60); gl(st, ln, turtle); gl(st, ln, turtle); rt(120); gl(st, ln, turtle); rt(60); rg(st, ln, turtle); lt(120); rg(st, ln, turtle); lt(60); gl(st, ln, turtle); &#125; if (st == 0) &#123; lt(60); fd(ln); rt(60); fd(ln); fd(ln); rt(120); fd(ln); rt(60); fd(ln); lt(120); fd(ln); lt(60); fd(ln); &#125; &#125; &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125;; window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/categories/threejs/"}],"tags":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/tags/threejs/"},{"name":"材质","slug":"材质","permalink":"https://cxx001.gitee.io/tags/%E6%9D%90%E8%B4%A8/"}],"keywords":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/categories/threejs/"}]},{"title":"threejs光源","slug":"threejs/threejs光源","date":"2023-01-12T06:47:10.000Z","updated":"2023-03-14T05:40:45.577Z","comments":true,"path":"2023/01/12/threejs/threejs光源/","link":"","permalink":"https://cxx001.gitee.io/2023/01/12/threejs/threejs%E5%85%89%E6%BA%90/","excerpt":"","text":"前言没有光源，渲染场景将不可见。threejs中已经帮我们实现了大量的光源，我们可以直接使用，主要分为两类：基础光源和特殊光源，下面将依次详细介绍。 基础光源1. THREE.AmbientLight(环境光)该光源颜色会应用到场景全局，光源没有特别的来源方向，并且不会生成阴影。通常，不会将环境光作为场景中唯一的光源，因为它会将场景中的所有物体渲染为相同颜色。一般和其它光源一起使用，它只是为了弱化阴影或给场景添加一些额外的颜色，所以它的用色应该尽量保守，如果设置的颜色过于明亮，那么画面颜色就过于饱和了。 下面示例帮助你理解，试试改变AmbientLight光颜色或开启&#x2F;关闭spotLight光源，观察场景变化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163&lt;!-- chapter-03-01.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Ambient Light&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; // 初始化fps显示插件 var stats = initStats(); // 创建场景对象 var scene = new THREE.Scene(); // 创建透视投影摄像机 var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); // 创建渲染器 var renderer = new THREE.WebGLRenderer(); renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); // 设置背景颜色 renderer.setSize(window.innerWidth, window.innerHeight); // 设置渲染窗口大小 renderer.shadowMapEnabled = true; // 激活阴影 // 创建平面 var planeGeometry = new THREE.PlaneGeometry(60, 20, 1, 1); var planeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xffffff&#125;); var plane = new THREE.Mesh(planeGeometry, planeMaterial); plane.receiveShadow = true; // 接收阴影 // 设置平面位置 plane.rotation.x = -0.5 * Math.PI; plane.position.x = 15; plane.position.y = 0; plane.position.z = 0; scene.add(plane); // 创建立方体对象 var cubeGeometry = new THREE.BoxGeometry(4, 4, 4); var cubeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xff0000&#125;); var cube = new THREE.Mesh(cubeGeometry, cubeMaterial); cube.castShadow = true; // 投射阴影 // 设置立方体位置 cube.position.x = -4; cube.position.y = 3; cube.position.z = 0; scene.add(cube); // 创建球体 var sphereGeometry = new THREE.SphereGeometry(4, 20, 20); var sphereMaterial = new THREE.MeshLambertMaterial(&#123;color: 0x7777ff&#125;); var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial); // 设置球体位置 sphere.position.x = 20; sphere.position.y = 0; sphere.position.z = 2; sphere.castShadow = true; // 投射阴影 scene.add(sphere); // 设置摄像机位置 camera.position.x = -25; camera.position.y = 30; camera.position.z = 25; // 设置摄像机镜头朝向 camera.lookAt(new THREE.Vector3(10, 0, 0)); // 创建环境光 var ambiColor = &quot;#0c0c0c&quot;; // 使用的是比较暗淡的灰色 var ambientLight = new THREE.AmbientLight(ambiColor); scene.add(ambientLight); // 创建聚光灯并开启投射阴影 var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(-40, 60, -10); spotLight.castShadow = true; scene.add(spotLight); // 将渲染器添加到DOM里显示 document.getElementById(&quot;WebGL-output&quot;).appendChild(renderer.domElement); // 设置dat.GUI插件显示属性 var controls = new function () &#123; this.ambientColor = ambiColor; // 环境光颜色 this.disableSpotlight = false; // 聚光灯是否可见 &#125;; // 将添加的控制属性添加到gui界面 var gui = new dat.GUI(); // 颜色设置 gui.addColor(controls, &#x27;ambientColor&#x27;).onChange(function (e) &#123; ambientLight.color = new THREE.Color(e); &#125;); // 开关设置 gui.add(controls, &#x27;disableSpotlight&#x27;).onChange(function (e) &#123; spotLight.visible = !e; // 聚光灯是否可见 &#125;); // 开始渲染 render(); var step = 0; function render() &#123; // 更新fps显示 stats.update(); // 旋转立方体 cube.rotation.x += 0.02; cube.rotation.y += 0.02; cube.rotation.z += 0.02; // 跳动球体 step += 0.03; sphere.position.x = 20 + ( 10 * (Math.cos(step))); sphere.position.y = 2 + ( 10 * Math.abs(Math.sin(step))); // 重新渲染 requestAnimationFrame(render); renderer.render(scene, camera); &#125; // 初始化fps显示插件 function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms // Align top-left stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init; // 改变窗口大小后适配 function onResize() &#123; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); &#125; window.addEventListener(&#x27;resize&#x27;, onResize, false);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果： 2. THREE.PointLight(点光源)点光源发射光线示意图： 从特定的一点向所有方向发射光线。夜空中的照明弹就是一个很好的点光源例子。 threejs里的点光源也没有阴影，因为它朝所有方向发射光线，这种情况下计算阴影对GPU是一个沉重的负担。 下面我们依旧通过示例来理解，这是一个点光源绕场景移动，为了看到点光源位置，我们让一个橙色的小球沿着相同的轨迹移动。你可以看到随着光源的移动，红色的方块和蓝色的球被这个光源从不同的侧面照亮。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175&lt;!-- chapter-03-02.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;point Light&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var renderer = new THREE.WebGLRenderer(); renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); renderer.setSize(window.innerWidth, window.innerHeight); // renderer.shadowMapEnabled = true; // 点光源没有阴影 var planeGeometry = new THREE.PlaneGeometry(60, 20, 20, 20); var planeMaterial = new THREE.MeshPhongMaterial(&#123;color: 0xffffff&#125;); var plane = new THREE.Mesh(planeGeometry, planeMaterial); // plane.receiveShadow = true; plane.rotation.x = -0.5 * Math.PI; plane.position.x = 15; plane.position.y = 0; plane.position.z = 0; scene.add(plane); var cubeGeometry = new THREE.BoxGeometry(4, 4, 4); var cubeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xff7777&#125;); var cube = new THREE.Mesh(cubeGeometry, cubeMaterial); // cube.castShadow = true; cube.position.x = -4; cube.position.y = 3; cube.position.z = 0; scene.add(cube); var sphereGeometry = new THREE.SphereGeometry(4, 20, 20); var sphereMaterial = new THREE.MeshLambertMaterial(&#123;color: 0x7777ff&#125;); var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial); sphere.position.x = 20; sphere.position.y = 0; sphere.position.z = 2; sphere.castShadow = true; scene.add(sphere); camera.position.x = -25; camera.position.y = 30; camera.position.z = 25; camera.lookAt(new THREE.Vector3(10, 0, 0)); // 镜头照射位置 // 添加环境光，弱的灰色，为了柔化场景 var ambiColor = &quot;#0c0c0c&quot;; var ambientLight = new THREE.AmbientLight(ambiColor); scene.add(ambientLight); // 添加点光源 var pointColor = &quot;#ccffcc&quot;; var pointLight = new THREE.PointLight(pointColor); pointLight.distance = 100; // 光源照射距离 scene.add(pointLight); var sphereLight = new THREE.SphereGeometry(0.2); var sphereLightMaterial = new THREE.MeshBasicMaterial(&#123;color: 0xac6c25&#125;); var sphereLightMesh = new THREE.Mesh(sphereLight, sphereLightMaterial); // sphereLightMesh.castShadow = true; sphereLightMesh.position = new THREE.Vector3(3, 0, 3); scene.add(sphereLightMesh); document.getElementById(&quot;WebGL-output&quot;).appendChild(renderer.domElement); var controls = new function () &#123; this.ambientColor = ambiColor; // 环境光颜色 this.pointColor = pointColor; // 点光源颜色 this.intensity = 1; // 光照强度 this.distance = 100; // 光照距离 &#125;; var gui = new dat.GUI(); gui.addColor(controls, &#x27;ambientColor&#x27;).onChange(function (e) &#123; ambientLight.color = new THREE.Color(e); &#125;); gui.addColor(controls, &#x27;pointColor&#x27;).onChange(function (e) &#123; pointLight.color = new THREE.Color(e); &#125;); gui.add(controls, &#x27;intensity&#x27;, 0, 3).onChange(function (e) &#123; pointLight.intensity = e; &#125;); gui.add(controls, &#x27;distance&#x27;, 0, 100).onChange(function (e) &#123; pointLight.distance = e; &#125;); render(); var step = 0; var invert = 1; var phase = 0; function render() &#123; stats.update(); cube.rotation.x += 0.03; cube.rotation.y += 0.03; cube.rotation.z += 0.03; step += 0.03; sphere.position.x = 20 + ( 10 * (Math.cos(step))); sphere.position.y = 2 + ( 10 * Math.abs(Math.sin(step))); // 模拟光源移动 if (phase &gt; 2 * Math.PI) &#123; invert = invert * -1; phase -= 2 * Math.PI; &#125; else &#123; phase += 0.03; &#125; sphereLightMesh.position.z = +(7 * (Math.sin(phase))); sphereLightMesh.position.x = +(14 * (Math.cos(phase))); sphereLightMesh.position.y = 5; if (invert &lt; 0) &#123; var pivot = 14; sphereLightMesh.position.x = (invert * (sphereLightMesh.position.x - pivot)) + pivot; &#125; // 光源和球体一起移动 pointLight.position.copy(sphereLightMesh.position); // 重新渲染 requestAnimationFrame(render); renderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms // Align top-left stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init; // 改变窗口大小后适配 function onResize() &#123; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); &#125; window.addEventListener(&#x27;resize&#x27;, onResize, false);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 所使用的点光源属性： 属性 描述 color(颜色) 光源的颜色 distance(距离) 光源照射的距离。默认值为0，这意味着光的强度不会随着距离增加而减少 intensity(强度) 光源照射的强度。默认值1 position(位置) 光源在场景中的位置 visible(是否可见) 默认为true，光源会打开；如果设置为false，光源就会关闭 效果： 3. THREE.SpotLight(聚光灯)聚光灯发射光线示意图： 从特定的一点发射锥形形状的光线，这是最常使用的光源之一，特别是你想要使用阴影的话。该光源具有产生光的方向和角度，类似手电筒。 聚光灯光源的所有属性： 属性 描述 angle(角度) 光源发射出的光束的宽度。默认是Math.PI&#x2F;3 castShadow(投影) 如果设置为true，这个光源就会投射阴影 color(颜色) 光源颜色 distance(距离) 光源照射的距离。默认值为0，这意味着光的强度不会随着距离增加而减少 intensity(强度) 光源照射的强度。默认值1 exponent(光强衰减指数) 发射的光线强度随着光源距离的增加而减弱，这个属性决定了光线强度递减的速度。使用小值，从光源发出的光线可以达到远处的物体，而使用大值，光线仅能到达非常接近光源的物体。 onlyShadow(仅阴影) 如果此属性设置为true，则该光源只生成阴影，不会在场景中添加任何光照 position(位置) 光源在场景中的位置 shadowBias(阴影偏移) 用来偏移阴影位置。当你使用非常薄的对象时，可能出现奇怪的渲染失真现象，如果你看到奇怪的阴影效果，将该属性设置为很小的值(如0.01)通过可以解决问题。此属性默认值为0 shadowCameraFar(投影远点) 到距离光源的哪一个位置可以生成阴影。默认值为5000（这几个参考投射投影摄像机理解） shadowCameraNear(投影近点) 从距离光源的哪一个位置开始生成阴影。默认值为50 shadowCameraFov(投影视场) 用于生成阴影的视场有多大。默认值为50 shadowCameraVisible(投影方式是否可见) 如果设置为true，可以看到光源在哪里以及如何生成阴影的(看到光源照射锥体)。默认值为false shadowDarkness(投影暗度) 定义阴影的暗度。在场景渲染后无法修改。默认值为0.5 shadowMapWidth和shadowMapHeight(阴影映射的宽&#x2F;高) 决定有多少像素用来生成阴影。当阴影有锯齿或看起来不光滑时，可以增加这个值。在场景渲染后无法修改。两者默认值为512 target(目标) 可以将光源指向场景中特定的对象或位置(位置需要是THREE.Object3Dd对象，不是THREE.Vectors3对象)。 visible() 默认为true，光源会打开；如果设置为false，光源就会关闭 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243&lt;!-- chapter-03-03.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Spot Light&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; // 是否停止移动光源 var stopMovingLight = false; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var renderer = new THREE.WebGLRenderer(); renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMapEnabled = true; renderer.shadowMapType = THREE.PCFShadowMap; // 这是默认值，如果设置为PCFSoftShadowMap则会使阴影更柔和 var planeGeometry = new THREE.PlaneGeometry(60, 20, 1, 1); var planeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xffffff&#125;); var plane = new THREE.Mesh(planeGeometry, planeMaterial); plane.receiveShadow = true; plane.rotation.x = -0.5 * Math.PI; plane.position.x = 15; plane.position.y = 0; plane.position.z = 0; scene.add(plane); var cubeGeometry = new THREE.BoxGeometry(4, 4, 4); var cubeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xff3333&#125;); var cube = new THREE.Mesh(cubeGeometry, cubeMaterial); cube.castShadow = true; cube.position.x = -4; cube.position.y = 3; cube.position.z = 0; scene.add(cube); var sphereGeometry = new THREE.SphereGeometry(4, 20, 20); var sphereMaterial = new THREE.MeshLambertMaterial(&#123;color: 0x7777ff&#125;); var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial); sphere.position.x = 20; sphere.position.y = 0; sphere.position.z = 2; sphere.castShadow = true; scene.add(sphere); camera.position.x = -35; camera.position.y = 30; camera.position.z = 25; camera.lookAt(new THREE.Vector3(10, 0, 0)); // 添加环境光 var ambiColor = &quot;#1c1c1c&quot;; var ambientLight = new THREE.AmbientLight(ambiColor); scene.add(ambientLight); // 添加1个聚光灯光源，设置位置和照射方向(和摄像机设置类似), 这个固定照射地面 var spotLight0 = new THREE.SpotLight(0xcccccc); spotLight0.position.set(-40, 30, -10); spotLight0.lookAt(plane); scene.add(spotLight0); // 添加另一个聚光灯光源，和小球一起运动 //var target = new THREE.Object3D(); //target.position = new THREE.Vector3(5, 0, 0); var pointColor = &quot;#ffffff&quot;; var spotLight = new THREE.SpotLight(pointColor); spotLight.position.set(-40, 60, -10); spotLight.castShadow = true; spotLight.shadowCameraNear = 2; spotLight.shadowCameraFar = 200; spotLight.shadowCameraFov = 30; spotLight.target = plane; // 照射方向，可以是这里的网格物体，也可以是上面的target具体某点对象 spotLight.distance = 0; spotLight.angle = 0.4; scene.add(spotLight); var sphereLight = new THREE.SphereGeometry(0.2); var sphereLightMaterial = new THREE.MeshBasicMaterial(&#123;color: 0xac6c25&#125;); var sphereLightMesh = new THREE.Mesh(sphereLight, sphereLightMaterial); sphereLightMesh.castShadow = true; sphereLightMesh.position = new THREE.Vector3(3, 20, 3); scene.add(sphereLightMesh); document.getElementById(&quot;WebGL-output&quot;).appendChild(renderer.domElement); var step = 0; var invert = 1; var phase = 0; var controls = new function () &#123; this.ambientColor = ambiColor; this.pointColor = pointColor; this.intensity = 1; // 光照强度 this.distance = 0; // 光照距离 this.exponent = 30; // 随着距离光源越远，光强度衰减指数 this.angle = 0.1; // 光源视场角度 this.debug = false; // 是否开启调试模式(打开投影方式可见) this.castShadow = true; // 是否投射阴影，false则不会产生阴影 this.onlyShadow = false; // 是否只生成阴影，true则不会在场景中产生光照 this.target = &quot;Plane&quot;; // 光源照射目标 this.stopMovingLight = false; // 是否停止移动光源 &#125;; var gui = new dat.GUI(); gui.addColor(controls, &#x27;ambientColor&#x27;).onChange(function (e) &#123; ambientLight.color = new THREE.Color(e); &#125;); gui.addColor(controls, &#x27;pointColor&#x27;).onChange(function (e) &#123; spotLight.color = new THREE.Color(e); &#125;); gui.add(controls, &#x27;angle&#x27;, 0, Math.PI * 2).onChange(function (e) &#123; spotLight.angle = e; &#125;); gui.add(controls, &#x27;intensity&#x27;, 0, 5).onChange(function (e) &#123; spotLight.intensity = e; &#125;); gui.add(controls, &#x27;distance&#x27;, 0, 200).onChange(function (e) &#123; spotLight.distance = e; &#125;); gui.add(controls, &#x27;exponent&#x27;, 0, 100).onChange(function (e) &#123; spotLight.exponent = e; &#125;); gui.add(controls, &#x27;debug&#x27;).onChange(function (e) &#123; spotLight.shadowCameraVisible = e; &#125;); gui.add(controls, &#x27;castShadow&#x27;).onChange(function (e) &#123; spotLight.castShadow = e; &#125;); gui.add(controls, &#x27;onlyShadow&#x27;).onChange(function (e) &#123; spotLight.onlyShadow = e; &#125;); // gui添加选择列表方式 gui.add(controls, &#x27;target&#x27;, [&#x27;Plane&#x27;, &#x27;Sphere&#x27;, &#x27;Cube&#x27;]).onChange(function (e) &#123; console.log(e); switch (e) &#123; case &quot;Plane&quot;: spotLight.target = plane; break; case &quot;Sphere&quot;: spotLight.target = sphere; break; case &quot;Cube&quot;: spotLight.target = cube; break; &#125; &#125;); gui.add(controls, &#x27;stopMovingLight&#x27;).onChange(function (e) &#123; stopMovingLight = e; &#125;); render(); function render() &#123; stats.update(); cube.rotation.x += 0.03; cube.rotation.y += 0.03; cube.rotation.z += 0.03; step += 0.03; sphere.position.x = 20 + ( 10 * (Math.cos(step))); sphere.position.y = 2 + ( 10 * Math.abs(Math.sin(step))); // 小球和spotLight光源一起移动 if (!stopMovingLight) &#123; if (phase &gt; 2 * Math.PI) &#123; invert = invert * -1; phase -= 2 * Math.PI; &#125; else &#123; phase += 0.03; &#125; sphereLightMesh.position.z = +(7 * (Math.sin(phase))); sphereLightMesh.position.x = +(14 * (Math.cos(phase))); sphereLightMesh.position.y = 10; if (invert &lt; 0) &#123; var pivot = 14; sphereLightMesh.position.x = (invert * (sphereLightMesh.position.x - pivot)) + pivot; &#125; spotLight.position.copy(sphereLightMesh.position); &#125; // 重新渲染 requestAnimationFrame(render); renderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms // Align top-left stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init; // 改变窗口大小后适配 function onResize() &#123; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); &#125; window.addEventListener(&#x27;resize&#x27;, onResize, false);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果： 4. THREE.DirectionalLight(平行光)平行光发生光线示意图: 从二维平面发射光线，光线彼此平行。这种类型的光可以看作是距离很远的光，如太阳光，它如此遥远，以至于达到地球时所有的光线几乎都是相互平行的。它不像前面聚光灯那样离目标越远越暗淡，被平行光照亮的整个区域接收到的光强度是一样的。它也可以产生阴影，很多属性和上面SpotLight一样，它的光照区域是一个立方体，类似正交投影摄像机，而SpotLight则类似透视投影摄像机。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210&lt;!-- chapter-03-04.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Directional Light&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var renderer = new THREE.WebGLRenderer(); renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMapEnabled = true; // 平面 var planeGeometry = new THREE.PlaneGeometry(600, 200, 20, 20); var planeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xffffff&#125;); var plane = new THREE.Mesh(planeGeometry, planeMaterial); plane.receiveShadow = true; plane.rotation.x = -0.5 * Math.PI; plane.position.x = 15; plane.position.y = -5; plane.position.z = 0; scene.add(plane); // 立方体 var cubeGeometry = new THREE.BoxGeometry(4, 4, 4); var cubeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xff3333&#125;); var cube = new THREE.Mesh(cubeGeometry, cubeMaterial); cube.castShadow = true; cube.position.x = -4; cube.position.y = 3; cube.position.z = 0; scene.add(cube); // 球 var sphereGeometry = new THREE.SphereGeometry(4, 20, 20); var sphereMaterial = new THREE.MeshLambertMaterial(&#123;color: 0x7777ff&#125;); var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial); sphere.position.x = 20; sphere.position.y = 0; sphere.position.z = 2; sphere.castShadow = true; scene.add(sphere); camera.position.x = -35; camera.position.y = 30; camera.position.z = 25; camera.lookAt(new THREE.Vector3(10, 0, 0)); // 添加环境光，给场景润色 var ambiColor = &quot;#1c1c1c&quot;; var ambientLight = new THREE.AmbientLight(ambiColor); scene.add(ambientLight); // 添加平行光 var pointColor = &quot;#ff5808&quot;; var directionalLight = new THREE.DirectionalLight(pointColor); directionalLight.position.set(-40, 60, -10); directionalLight.castShadow = true; // 设置光照立方体区域 directionalLight.shadowCameraNear = 2; directionalLight.shadowCameraFar = 200; directionalLight.shadowCameraLeft = -50; directionalLight.shadowCameraRight = 50; directionalLight.shadowCameraTop = 50; directionalLight.shadowCameraBottom = -50; // 同前面聚光灯属性 directionalLight.distance = 0; directionalLight.intensity = 0.5; directionalLight.shadowMapHeight = 1024; directionalLight.shadowMapWidth = 1024; scene.add(directionalLight); // 和光源一起移动的小球 var sphereLight = new THREE.SphereGeometry(1); var sphereLightMaterial = new THREE.MeshBasicMaterial(&#123;color: 0xac6c25&#125;); var sphereLightMesh = new THREE.Mesh(sphereLight, sphereLightMaterial); sphereLightMesh.castShadow = true; sphereLightMesh.position = new THREE.Vector3(3, 20, 3); scene.add(sphereLightMesh); document.getElementById(&quot;WebGL-output&quot;).appendChild(renderer.domElement); // 属性同上面聚光灯 var controls = new function () &#123; this.ambientColor = ambiColor; this.pointColor = pointColor; this.intensity = 0.5; this.distance = 0; this.exponent = 30; this.angle = 0.1; this.debug = false; this.castShadow = true; this.onlyShadow = false; this.target = &quot;Plane&quot;; &#125;; var gui = new dat.GUI(); gui.addColor(controls, &#x27;ambientColor&#x27;).onChange(function (e) &#123; ambientLight.color = new THREE.Color(e); &#125;); gui.addColor(controls, &#x27;pointColor&#x27;).onChange(function (e) &#123; directionalLight.color = new THREE.Color(e); &#125;); gui.add(controls, &#x27;intensity&#x27;, 0, 5).onChange(function (e) &#123; directionalLight.intensity = e; &#125;); gui.add(controls, &#x27;distance&#x27;, 0, 200).onChange(function (e) &#123; directionalLight.distance = e; &#125;); gui.add(controls, &#x27;debug&#x27;).onChange(function (e) &#123; directionalLight.shadowCameraVisible = e; &#125;); gui.add(controls, &#x27;castShadow&#x27;).onChange(function (e) &#123; directionalLight.castShadow = e; &#125;); gui.add(controls, &#x27;onlyShadow&#x27;).onChange(function (e) &#123; directionalLight.onlyShadow = e; &#125;); gui.add(controls, &#x27;target&#x27;, [&#x27;Plane&#x27;, &#x27;Sphere&#x27;, &#x27;Cube&#x27;]).onChange(function (e) &#123; console.log(e); switch (e) &#123; case &quot;Plane&quot;: directionalLight.target = plane; break; case &quot;Sphere&quot;: directionalLight.target = sphere; break; case &quot;Cube&quot;: directionalLight.target = cube; break; &#125; &#125;); render(); var step = 0; function render() &#123; stats.update(); cube.rotation.x += 0.03; cube.rotation.y += 0.03; cube.rotation.z += 0.03; step += 0.03; sphere.position.x = 20 + ( 10 * (Math.cos(step))); sphere.position.y = 2 + ( 10 * Math.abs(Math.sin(step))); sphereLightMesh.position.z = -8; sphereLightMesh.position.y = +(27 * (Math.sin(step / 3))); sphereLightMesh.position.x = 10 + (26 * (Math.cos(step / 3))); directionalLight.position.copy(sphereLightMesh.position); requestAnimationFrame(render); renderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms // Align top-left stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init; // 改变窗口大小后适配 function onResize() &#123; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); &#125; window.addEventListener(&#x27;resize&#x27;, onResize, false);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果： 特殊光源1. THREE.HemisphereLight(半球光源)使用半球光源可以创建出更加贴近自然的户外光照效果。在户外，并不是所有的光照都来自上方，还有大气的散射和地面以及其它物体的反射。THREE.HemisphereLight光源就是为了这种情形创建的。 它的属性很简单： 属性 描述 groundColor 从地面发出的光线的颜色 color 从天空发出的光线的颜色 intensity 光线照射的强度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172&lt;!-- chapter-03-05.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hemisphere Light&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); scene.fog = new THREE.Fog(0xaaaaaa, 0.010, 200); // 添加雾化效果 var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var renderer = new THREE.WebGLRenderer(); renderer.setClearColor(new THREE.Color(0xaaaaff, 1.0)); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMapEnabled = true; // 添加本地图片纹理（草地地面） var textureGrass = THREE.ImageUtils.loadTexture(&quot;../assets/textures/ground/grasslight-big.jpg&quot;); textureGrass.wrapS = THREE.RepeatWrapping; textureGrass.wrapT = THREE.RepeatWrapping; textureGrass.repeat.set(4, 4); // 用本地图片做网格对象的材质 var planeGeometry = new THREE.PlaneGeometry(1000, 200, 20, 20); var planeMaterial = new THREE.MeshLambertMaterial(&#123;map: textureGrass&#125;); // 本地纹理材质 var plane = new THREE.Mesh(planeGeometry, planeMaterial); plane.receiveShadow = true; plane.rotation.x = -0.5 * Math.PI; plane.position.x = 15; plane.position.y = 0; plane.position.z = 0; scene.add(plane); var cubeGeometry = new THREE.BoxGeometry(4, 4, 4); var cubeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xff3333&#125;); var cube = new THREE.Mesh(cubeGeometry, cubeMaterial); cube.castShadow = true; cube.position.x = -4; cube.position.y = 3; cube.position.z = 0; scene.add(cube); var sphereGeometry = new THREE.SphereGeometry(4, 25, 25); var sphereMaterial = new THREE.MeshLambertMaterial(&#123;color: 0x7777ff&#125;); var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial); sphere.position.x = 10; sphere.position.y = 5; sphere.position.z = 10; sphere.castShadow = true; scene.add(sphere); camera.position.x = -20; camera.position.y = 15; camera.position.z = 45; camera.lookAt(new THREE.Vector3(10, 0, 0)); // 添加聚光灯光源 var spotLight0 = new THREE.SpotLight(0xcccccc); spotLight0.position.set(-40, 60, -10); spotLight0.lookAt(plane); scene.add(spotLight0); // 添加半球光源 var hemiLight = new THREE.HemisphereLight(0x0000ff, 0x00ff00, 0.6); hemiLight.position.set(0, 500, 0); scene.add(hemiLight); // 添加平行光源 var pointColor = &quot;#ffffff&quot;; var dirLight = new THREE.DirectionalLight(pointColor); dirLight.position.set(30, 10, -50); dirLight.castShadow = true; dirLight.target = plane; dirLight.shadowCameraNear = 0.1; dirLight.shadowCameraFar = 200; dirLight.shadowCameraLeft = -50; dirLight.shadowCameraRight = 50; dirLight.shadowCameraTop = 50; dirLight.shadowCameraBottom = -50; dirLight.shadowMapWidth = 2048; dirLight.shadowMapHeight = 2048; scene.add(dirLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(renderer.domElement); var controls = new function () &#123; this.hemisphere = true; // 是否开启半球光源(通过光强为0来设置) this.color = 0x00ff00; // 从地面发出的光线颜色 this.skyColor = 0x0000ff; // 从天空发出的光线颜色 this.intensity = 0.6; // 光照强度 &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;hemisphere&#x27;).onChange(function (e) &#123; if (!e) &#123; hemiLight.intensity = 0; &#125; else &#123; hemiLight.intensity = controls.intensity; &#125; &#125;); gui.addColor(controls, &#x27;color&#x27;).onChange(function (e) &#123; hemiLight.groundColor = new THREE.Color(e); &#125;); gui.addColor(controls, &#x27;skyColor&#x27;).onChange(function (e) &#123; hemiLight.color = new THREE.Color(e); &#125;); gui.add(controls, &#x27;intensity&#x27;, 0, 5).onChange(function (e) &#123; hemiLight.intensity = e; &#125;); render(); var step = 0; function render() &#123; stats.update(); cube.rotation.x += 0.03; cube.rotation.y += 0.03; cube.rotation.z += 0.03; step += 0.03; sphere.position.x = 20 + ( 10 * (Math.cos(step))); sphere.position.y = 2 + ( 10 * Math.abs(Math.sin(step))); requestAnimationFrame(render); renderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms // Align top-left stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init; // 改变窗口大小后适配 function onResize() &#123; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); &#125; window.addEventListener(&#x27;resize&#x27;, onResize, false);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 观察示例，通过开启&#x2F;关闭半球光源，看场景中物体受反射光的影响。 2. THREE.AreaLight(区域光源)区域光不是从某一个点发光，它是从一块区域发光，可以定义长方形的发光区域。它没有定义在WebGLRenderer渲染器中，因为会带来非常严重的性能损失。而是定义在WebGLDeferredRenderer渲染器中，它使用了一种不同的方法(分成多个步骤)，相对标志渲染器WebGLRenderer，可以更好地处理复杂地光照(或者非常大量地光源)。 使用WebGLDeferredRenderer要额外引入一些外部库。好像新版区域光源也给加到标志渲染器了，本示例用的旧版。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199&lt;!-- chapter-03-06.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Area Light&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; // 引入WebGLDeferredRenderer渲染器 &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/WebGLDeferredRenderer.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/ShaderDeferred.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/RenderPass.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/EffectComposer.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/CopyShader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/ShaderPass.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/FXAAShader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/MaskPass.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var camera; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); scene.add(camera); // 针对区域光源这种大量光源性能优化的渲染器 var renderer = new THREE.WebGLDeferredRenderer(&#123; width: window.innerWidth, height: window.innerHeight, scale: 1, antialias: true, tonemapping: THREE.FilmicOperator, brightness: 2.5 &#125;); // 地面 var planeGeometry = new THREE.PlaneGeometry(70, 70, 1, 1); var planeMaterial = new THREE.MeshPhongMaterial(&#123;color: 0xffffff, specular: 0xffffff, shininess: 200&#125;); var plane = new THREE.Mesh(planeGeometry, planeMaterial); plane.rotation.x = -0.5 * Math.PI; plane.position.x = 0; plane.position.y = 0; plane.position.z = 0; scene.add(plane); camera.position.x = 20; camera.position.y = 30; camera.position.z = 21; camera.lookAt(new THREE.Vector3(0, 0, -30)); document.getElementById(&quot;WebGL-output&quot;).appendChild(renderer.domElement); // 固定的聚光灯光源 var spotLight0 = new THREE.SpotLight(0xcccccc); spotLight0.position.set(-40, 60, -10); spotLight0.intensity = 0.1; spotLight0.lookAt(plane); scene.add(spotLight0); // 添加红色区域光源1 var areaLight1 = new THREE.AreaLight(0xff0000, 3); areaLight1.position.set(-10, 10, -35); areaLight1.rotation.set(-Math.PI / 2, 0, 0); areaLight1.width = 4; areaLight1.height = 9.9; scene.add(areaLight1); // 添加绿色区域光源2 var areaLight2 = new THREE.AreaLight(0x00ff00, 3); areaLight2.position.set(0, 10, -35); areaLight2.rotation.set(-Math.PI / 2, 0, 0); areaLight2.width = 4; areaLight2.height = 9.9; scene.add(areaLight2); // 添加蓝色区域光源3 var areaLight3 = new THREE.AreaLight(0x0000ff, 3); areaLight3.position.set(10, 10, -35); areaLight3.rotation.set(-Math.PI / 2, 0, 0); areaLight3.width = 4; areaLight3.height = 9.9; scene.add(areaLight3); // 红色长方形1(z为0)设置到区域光源1位置，用于标志光源的位置 var planeGeometry1 = new THREE.BoxGeometry(4, 10, 0); var planeGeometry1Mat = new THREE.MeshBasicMaterial(&#123;color: 0xff0000&#125;); var plane1 = new THREE.Mesh(planeGeometry1, planeGeometry1Mat); plane1.position.copy(areaLight1.position); scene.add(plane1); // 绿色长方形2设置到区域光源2位置 var planeGeometry2 = new THREE.BoxGeometry(4, 10, 0); var planeGeometry2Mat = new THREE.MeshBasicMaterial(&#123;color: 0x00ff00&#125;); var plane2 = new THREE.Mesh(planeGeometry2, planeGeometry2Mat); plane2.position.copy(areaLight2.position); scene.add(plane2); // 蓝色长方形3设置到区域光源3位置 var planeGeometry3 = new THREE.BoxGeometry(4, 10, 0); var planeGeometry3Mat = new THREE.MeshBasicMaterial(&#123;color: 0x0000ff&#125;); var plane3 = new THREE.Mesh(planeGeometry3, planeGeometry3Mat); plane3.position.copy(areaLight3.position); scene.add(plane3); var controls = new function () &#123; // 对应3块区域光的颜色和强度 this.color1 = 0xff0000; this.intensity1 = 2; this.color2 = 0x00ff00; this.intensity2 = 2; this.color3 = 0x0000ff; this.intensity3 = 2; &#125;; var gui = new dat.GUI(); // 改变光颜色和对应的长方形颜色 gui.addColor(controls, &#x27;color1&#x27;).onChange(function (e) &#123; areaLight1.color = new THREE.Color(e); planeGeometry1Mat.color = new THREE.Color(e); scene.remove(plane1); plane1 = new THREE.Mesh(planeGeometry1, planeGeometry1Mat); plane1.position.copy(areaLight1.position); scene.add(plane1); &#125;); gui.add(controls, &#x27;intensity1&#x27;, 0, 5).onChange(function (e) &#123; areaLight1.intensity = e; &#125;); gui.addColor(controls, &#x27;color2&#x27;).onChange(function (e) &#123; areaLight2.color = new THREE.Color(e); planeGeometry2Mat.color = new THREE.Color(e); scene.remove(plane2); plane2 = new THREE.Mesh(planeGeometry2, planeGeometry2Mat); plane2.position.copy(areaLight2.position); scene.add(plane2); &#125;); gui.add(controls, &#x27;intensity2&#x27;, 0, 5).onChange(function (e) &#123; areaLight2.intensity = e; &#125;); gui.addColor(controls, &#x27;color3&#x27;).onChange(function (e) &#123; areaLight3.color = new THREE.Color(e); planeGeometry3Mat.color = new THREE.Color(e); scene.remove(plane3); plane3 = new THREE.Mesh(planeGeometry1, planeGeometry3Mat); plane3.position.copy(areaLight3.position); scene.add(plane3); &#125;); gui.add(controls, &#x27;intensity3&#x27;, 0, 5).onChange(function (e) &#123; areaLight3.intensity = e; &#125;); render(); function render() &#123; stats.update(); requestAnimationFrame(render); renderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms // Align top-left stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init; // 改变窗口大小后适配 function onResize() &#123; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); &#125; window.addEventListener(&#x27;resize&#x27;, onResize, false);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果： 3. THREE.LensFlare(镜头光晕)类似你直接朝着太阳拍照时就会出现镜头光晕效果。 光晕属性： 参数 描述 texture（纹理） 纹理就是一个图片，用来决定光晕的形状 size（尺寸） 指定光晕大小。如果指定为-1，那么将使用纹理本身的大小 distance（距离） 从光源(0)到摄像机(1)的距离。 blending（混合） 可以为光晕提供多种材质。混合模式决定了如何将它们混合在一起。 color（颜色） 光晕的颜色 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184&lt;!-- chapter-03-07.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Lensflarest&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); scene.fog = new THREE.Fog(0xaaaaaa, 0.010, 200); // 添加雾化效果 var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var renderer = new THREE.WebGLRenderer(&#123;antialias: true, alpha: true&#125;); renderer.setClearColor(new THREE.Color(0xaaaaff, 1.0)); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMapEnabled = true; // 创建草地地面 var textureGrass = THREE.ImageUtils.loadTexture(&quot;../assets/textures/ground/grasslight-big.jpg&quot;); textureGrass.wrapS = THREE.RepeatWrapping; textureGrass.wrapT = THREE.RepeatWrapping; textureGrass.repeat.set(4, 4); var planeGeometry = new THREE.PlaneGeometry(1000, 200, 20, 20); var planeMaterial = new THREE.MeshLambertMaterial(&#123;map: textureGrass&#125;); var plane = new THREE.Mesh(planeGeometry, planeMaterial); plane.receiveShadow = true; plane.rotation.x = -0.5 * Math.PI; plane.position.x = 15; plane.position.y = 0; plane.position.z = 0; scene.add(plane); // 创建立方体 var cubeGeometry = new THREE.BoxGeometry(4, 4, 4); var cubeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xff3333&#125;); var cube = new THREE.Mesh(cubeGeometry, cubeMaterial); cube.castShadow = true; cube.position.x = -4; cube.position.y = 3; cube.position.z = 0; scene.add(cube); // 创建球体 var sphereGeometry = new THREE.SphereGeometry(4, 25, 25); var sphereMaterial = new THREE.MeshLambertMaterial(&#123;color: 0x7777ff&#125;); var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial); sphere.position.x = 10; sphere.position.y = 5; sphere.position.z = 10; sphere.castShadow = true; scene.add(sphere); camera.position.x = -20; camera.position.y = 15; camera.position.z = 45; camera.lookAt(new THREE.Vector3(10, 0, 0)); // 添加环境光 var ambiColor = &quot;#1c1c1c&quot;; var ambientLight = new THREE.AmbientLight(ambiColor); scene.add(ambientLight); // 添加聚光灯 var spotLight0 = new THREE.SpotLight(0xcccccc); spotLight0.position.set(-40, 60, -10); spotLight0.lookAt(plane); scene.add(spotLight0); // 添加平行光 var pointColor = &quot;#ffffff&quot;; var spotLight = new THREE.DirectionalLight(pointColor); spotLight.position.set(30, 10, -50); spotLight.castShadow = true; spotLight.shadowCameraNear = 0.1; spotLight.shadowCameraFar = 100; spotLight.shadowCameraFov = 50; spotLight.target = plane; spotLight.distance = 0; spotLight.shadowCameraNear = 2; spotLight.shadowCameraFar = 200; spotLight.shadowCameraLeft = -100; spotLight.shadowCameraRight = 100; spotLight.shadowCameraTop = 100; spotLight.shadowCameraBottom = -100; spotLight.shadowMapWidth = 2048; spotLight.shadowMapHeight = 2048; scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(renderer.domElement); var controls = new function () &#123; this.ambientColor = ambiColor; this.pointColor = pointColor; this.intensity = 0.1; &#125;; var gui = new dat.GUI(); gui.addColor(controls, &#x27;ambientColor&#x27;).onChange(function (e) &#123; ambientLight.color = new THREE.Color(e); &#125;); gui.addColor(controls, &#x27;pointColor&#x27;).onChange(function (e) &#123; spotLight.color = new THREE.Color(e); &#125;); gui.add(controls, &#x27;intensity&#x27;, 0, 5).onChange(function (e) &#123; spotLight.intensity = e; &#125;); // 创建光晕纹理 var textureFlare0 = THREE.ImageUtils.loadTexture(&quot;../assets/textures/lensflare/lensflare0.png&quot;); // 创建镜头光晕，把它放在光源处(距离为0) var flareColor = new THREE.Color(0xffaacc); var lensFlare = new THREE.LensFlare(textureFlare0, 350, 0.0, THREE.AdditiveBlending, flareColor); // 光源到摄像机附近添加新的光晕(使用的很淡的纹理)，通过上面主光晕对象的add方法添加，增强表现效果，可以屏蔽对比。 var textureFlare3 = THREE.ImageUtils.loadTexture(&quot;../assets/textures/lensflare/lensflare3.png&quot;); lensFlare.add(textureFlare3, 60, 0.6, THREE.AdditiveBlending); lensFlare.add(textureFlare3, 70, 0.7, THREE.AdditiveBlending); lensFlare.add(textureFlare3, 120, 0.9, THREE.AdditiveBlending); lensFlare.add(textureFlare3, 70, 1.0, THREE.AdditiveBlending); lensFlare.position.copy(spotLight.position); scene.add(lensFlare); render(); var step = 0; function render() &#123; stats.update(); cube.rotation.x += 0.03; cube.rotation.y += 0.03; cube.rotation.z += 0.03; step += 0.03; sphere.position.x = 20 + ( 10 * (Math.cos(step))); sphere.position.y = 2 + ( 10 * Math.abs(Math.sin(step))); requestAnimationFrame(render); renderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms // Align top-left stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125;; window.onload = init; // 改变窗口大小后适配 function onResize() &#123; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); &#125; window.addEventListener(&#x27;resize&#x27;, onResize, false);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果：","categories":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/categories/threejs/"}],"tags":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/tags/threejs/"},{"name":"光源","slug":"光源","permalink":"https://cxx001.gitee.io/tags/%E5%85%89%E6%BA%90/"}],"keywords":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/categories/threejs/"}]},{"title":"threejs场景","slug":"threejs/threejs场景","date":"2023-01-10T08:44:30.000Z","updated":"2023-03-14T05:42:50.459Z","comments":true,"path":"2023/01/10/threejs/threejs场景/","link":"","permalink":"https://cxx001.gitee.io/2023/01/10/threejs/threejs%E5%9C%BA%E6%99%AF/","excerpt":"","text":"前言 对象添加到场景里才能被渲染，场景是整个画面的容器。场景要显示任何东西，一般要有摄像机、光源、渲染对象。本章主要介绍场景类里常用的方法和属性，以及构建场景的基本组件。 几何体和网格：网格可以添加到场景中渲染，网格由几何体和材质组成。几何体由顶点和面(一般是三角形，也有四边形)组成。几何体决定网格的形状，材质决定网格的样式。 场景中摄像机对象，分为透视投影摄像机和正交投影摄像机。 示例1. 场景中对象的增删、雾化、强制改变场景对象的材质123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179&lt;!-- chapter-02-01.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Basic Scene&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; // 初始化fps显示插件 var stats = initStats(); // 创建场景 var scene = new THREE.Scene(); // 创建雾化效果 // scene.fog = new THREE.Fog(0xffffff, 0.015, 100); // 添加0xffffff白色雾化效果，0.015~100是设定由近到远雾的加深程度，是线性变化的。 // scene.fog=new THREE.FogExp2( 0xffffff, 0.015 ); // 同上，添加雾的另一个接口，只需要指定雾颜色和浓度，浓度变化不再是线性的，而是随着距离呈指数增长。 // 覆盖场景中对象的材质 // scene.overrideMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xffffff&#125;); // 全部用这个黑色材质，即使场景中对象设置了材质也会被这个替换。 // 添加摄像机到场景 var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); scene.add(camera); // 创建渲染器 var renderer = new THREE.WebGLRenderer(); renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMapEnabled = true; // 开启阴影 // 创建平面 var planeGeometry = new THREE.PlaneGeometry(60, 40, 1, 1); var planeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xffffff&#125;); var plane = new THREE.Mesh(planeGeometry, planeMaterial); // 创建网格，由几何体和材质组成 plane.receiveShadow = true; // 让平面接受阴影 // 平面旋转和位置设置，并添加进场景 plane.rotation.x = -0.5 * Math.PI; plane.position.x = 0; plane.position.y = 0; plane.position.z = 0; scene.add(plane); // 设置摄像机位置 camera.position.x = -30; camera.position.y = 40; camera.position.z = 30; // 设置摄像机镜头朝哪里看 camera.lookAt(scene.position); // 在场景中添加环境光(关于光源后续再详细介绍) var ambientLight = new THREE.AmbientLight(0x0c0c0c); scene.add(ambientLight); // 在场景中添加聚光灯 var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(-40, 60, -10); spotLight.castShadow = true; // 让光源投射阴影 scene.add(spotLight); // 将渲染器DOM添加到页面 document.getElementById(&quot;WebGL-output&quot;).appendChild(renderer.domElement); // 设置dat.GUI插件属性 var step = 0; var controls = new function () &#123; this.rotationSpeed = 0.02; // 对象旋转速度 this.numberOfObjects = scene.children.length; // 当前场景中对象的数量 // 移除场景对象数组里最后一个对象，并更新场景对象数量 this.removeCube = function () &#123; var allChildren = scene.children; // scene.children 获取场景中对象数组 var lastObject = allChildren[allChildren.length - 1]; if (lastObject instanceof THREE.Mesh) &#123; scene.remove(lastObject); this.numberOfObjects = scene.children.length; &#125; &#125;; // 场景中添加立方体对象 this.addCube = function () &#123; var cubeSize = Math.ceil((Math.random() * 3)); var cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize); var cubeMaterial = new THREE.MeshLambertMaterial(&#123;color: Math.random() * 0xffffff&#125;); var cube = new THREE.Mesh(cubeGeometry, cubeMaterial); cube.castShadow = true; // 开启投射阴影 cube.name = &quot;cube-&quot; + scene.children.length; // 设置名字后，可以通过getObjectByName(name)方法获取这个对象 // 随机设置对象位置 cube.position.x = -30 + Math.round((Math.random() * planeGeometry.parameters.width)); cube.position.y = Math.round((Math.random() * 5)); cube.position.z = -20 + Math.round((Math.random() * planeGeometry.parameters.height)); // 添加进场景并刷新场景中对象数量属性 scene.add(cube); this.numberOfObjects = scene.children.length; &#125;; // 打印当前场景中对象信息 this.outputObjects = function () &#123; console.log(scene.children); &#125; &#125;; // 相关属性添加到dat.GUI插件界面显示 var gui = new dat.GUI(); gui.add(controls, &#x27;rotationSpeed&#x27;, 0, 0.5); // 拖动进度条改变rotationSpeed属性，取值范围0~0.5 gui.add(controls, &#x27;addCube&#x27;); // 点击执行addCube方法 gui.add(controls, &#x27;removeCube&#x27;); gui.add(controls, &#x27;outputObjects&#x27;); gui.add(controls, &#x27;numberOfObjects&#x27;).listen(); // 监听numberOfObjects字段的变化 // 开始渲染 render(); function render() &#123; // 更新fps显示 stats.update(); // 深度遍历场景中所有对象 scene.traverse(function (e) &#123; if (e instanceof THREE.Mesh &amp;&amp; e != plane) &#123; // 排除平面对象，其余所有对象做旋转 e.rotation.x += controls.rotationSpeed; e.rotation.y += controls.rotationSpeed; e.rotation.z += controls.rotationSpeed; &#125; &#125;); // 重新渲染场景 requestAnimationFrame(render); renderer.render(scene, camera); &#125; // 初始化显示fps插件 function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init; // 改变窗口大小后适配 function onResize() &#123; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); &#125; window.addEventListener(&#x27;resize&#x27;, onResize, false);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这个示例程序主要学习了对场景对象scene，如下几个方法&#x2F;属性的使用： 方法（属性） 描述 add(object) 向场景中添加对象。 children 返回场景中所有对象的列表，包括摄像机和光源。 getObjectByName(name, recursive) 在创建对象时可以指定唯一的标识name，使用该方法可以查找特定名字的对象。当参数recursive设置为false时，在调用者子元素上查找，当设置为true时，在调用者的所有后代对象上查找。 remove(object) 将对象从场景中移除。 traverse(function) 遍历场景中所有物体，回调函数function被场景中所有对象调用。 fog 使用该属性可以为场景添加雾化效果，可以产生隐藏远处物体的浓雾效果。 overrideMaterial 使用该属性可以强制场景中的所有物体使用相同的材质。 效果1-添加&#x2F;删除对象： 效果2-雾化 ：上面scene.fog = new THREE.Fog(0xffffff, 0.015, 100)注释代码放开 效果3-覆盖材质：上面scene.overrideMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xffffff&#125;)注释代码放开 2. 标准几何体123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193&lt;!-- chapter-02-02.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;标准几何体示例&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/ParametricGeometries.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/ConvexGeometry.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); // create a scene, that will hold all our elements such as objects, cameras and lights. var scene = new THREE.Scene(); // create a camera, which defines where we&#x27;re looking at. var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); // create a render and set the size var renderer = new THREE.WebGLRenderer(); renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMapEnabled = true; // create the ground plane var planeGeometry = new THREE.PlaneGeometry(60, 40, 1, 1); var planeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xffffff&#125;); var plane = new THREE.Mesh(planeGeometry, planeMaterial); plane.receiveShadow = true; // rotate and position the plane plane.rotation.x = -0.5 * Math.PI; plane.position.x = 0; plane.position.y = 0; plane.position.z = 0; // add the plane to the scene scene.add(plane); // position and point the camera to the center of the scene camera.position.x = -50; camera.position.y = 30; camera.position.z = 20; camera.lookAt(new THREE.Vector3(-10, 0, 0)); // add subtle ambient lighting var ambientLight = new THREE.AmbientLight(0x090909); scene.add(ambientLight); // add spotlight for the shadows var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(-40, 40, 50); spotLight.castShadow = true; scene.add(spotLight); // 添加threejs库可用的标准几何体 addGeometries(scene); // add the output of the renderer to the html element document.getElementById(&quot;WebGL-output&quot;).appendChild(renderer.domElement); render(); // call the render function var step = 0; function addGeometries(scene) &#123; var geoms = []; // 圆柱体/圆锥体 geoms.push(new THREE.CylinderGeometry(1, 4, 4)); // 立方体/长方体 geoms.push(new THREE.BoxGeometry(2, 2, 2)); // 球体 geoms.push(new THREE.SphereGeometry(2)); // 二十面体 geoms.push(new THREE.IcosahedronGeometry(4)); // 用点创建凸形状，如立方体 var points = [ new THREE.Vector3(2, 2, 2), new THREE.Vector3(2, 2, -2), new THREE.Vector3(-2, 2, -2), new THREE.Vector3(-2, 2, 2), new THREE.Vector3(2, -2, 2), new THREE.Vector3(2, -2, -2), new THREE.Vector3(-2, -2, -2), new THREE.Vector3(-2, -2, 2) ]; geoms.push(new THREE.ConvexGeometry(points)); // 车床图形，围绕某个轴旋转而来 //http://en.wikipedia.org/wiki/Lathe_(graphics) var pts = [];//points array - the path profile points will be stored here var detail = .1;//half-circle detail - how many angle increments will be used to generate points var radius = 3;//radius for half_sphere for (var angle = 0.0; angle &lt; Math.PI; angle += detail)//loop from 0.0 radians to PI (0 - 180 degrees) pts.push(new THREE.Vector3(Math.cos(angle) * radius, 0, Math.sin(angle) * radius));//angle/radius to x,z geoms.push(new THREE.LatheGeometry(pts, 12)); // 八面体 geoms.push(new THREE.OctahedronGeometry(3)); // 自定义几何体 geoms.push(new THREE.ParametricGeometry(THREE.ParametricGeometries.mobius3d, 20, 10)); // 四面体(4个顶点4个面，场景中如果只看到一个面，看起来就是一个三角形) geoms.push(new THREE.TetrahedronGeometry(3)); // 圆环 geoms.push(new THREE.TorusGeometry(3, 1, 10, 10)); // 圆环结 geoms.push(new THREE.TorusKnotGeometry(3, 0.5, 50, 20)); var j = 0; for (var i = 0; i &lt; geoms.length; i++) &#123; // 数组材质，和前面使用1个材质有点区别，创建网格时会为数组中每个材质都创建一个实例 var materials = [ new THREE.MeshLambertMaterial(&#123;color: Math.random() * 0xffffff, shading: THREE.FlatShading&#125;), new THREE.MeshBasicMaterial(&#123;color: 0x000000, wireframe: true&#125;) // 线框材质 ]; // 使用数组材质创建网格，返回的也是一个对应的数组网格对象 var mesh = THREE.SceneUtils.createMultiMaterialObject(geoms[i], materials); mesh.traverse(function (e) &#123; e.castShadow = true // 为数组网格对象开启投射阴影 &#125;); //var mesh = new THREE.Mesh(geoms[i],materials[i]); //mesh.castShadow=true; mesh.position.x = -24 + ((i % 4) * 12); mesh.position.y = 4; mesh.position.z = -8 + (j * 12); if ((i + 1) % 4 == 0) j++; scene.add(mesh); &#125; &#125; function render() &#123; stats.update(); // render using requestAnimationFrame requestAnimationFrame(render); renderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms // Align top-left stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init; // 改变窗口大小后适配 function onResize() &#123; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); &#125; window.addEventListener(&#x27;resize&#x27;, onResize, false);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这个示例展示了标准几何体的创建方法，只需要指定长、宽、高、半径等，不需要关心几何体的顶点和面，它内部会帮我们计算好。 一个新的创建网格方式: createMultiMaterialObject使用多种材质来创建，这个方法创建的并不是一个mesh对象实例，而是为materials数组中每个指定的材质创建一个实例，并把这些实例存放在一个组里(THREE.Object3D对象)。你可以像使用场景中的对象那样使用这个组，如添加到场景、按名称获取对象等。但如果要为这个组中所有子对象添加阴影，我们要像上面示例一样遍历所有子对象了。 返回的其实是一个网格组对象，其中每个网格的几何体一样，不同的只是使用的材质不一样。可以通过children[i]取到子对象平移开就可以清楚看到了。 效果： 3. 自定义几何体123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218&lt;!-- chapter-02-03.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Custom geometry&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); // create a scene, that will hold all our elements such as objects, cameras and lights. var scene = new THREE.Scene(); // create a camera, which defines where we&#x27;re looking at. var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); // create a render and set the size var renderer = new THREE.WebGLRenderer(); renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMapEnabled = true; // create the ground plane var planeGeometry = new THREE.PlaneGeometry(60, 40, 1, 1); var planeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xffffff&#125;); var plane = new THREE.Mesh(planeGeometry, planeMaterial); plane.receiveShadow = true; // rotate and position the plane plane.rotation.x = -0.5 * Math.PI; plane.position.x = 0; plane.position.y = 0; plane.position.z = 0; // add the plane to the scene scene.add(plane); // position and point the camera to the center of the scene camera.position.x = -20; camera.position.y = 25; camera.position.z = 20; camera.lookAt(new THREE.Vector3(5, 0, 0)); // add spotlight for the shadows var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(-40, 60, 10); spotLight.castShadow = true; scene.add(spotLight); // add the output of the renderer to the html element document.getElementById(&quot;WebGL-output&quot;).appendChild(renderer.domElement); // 立方体的8个顶点数据(初始数据，后面渲染使用dat.GUI绑定的数据更新顶点) var vertices = [ new THREE.Vector3(1, 3, 1), new THREE.Vector3(1, 3, -1), new THREE.Vector3(1, -1, 1), new THREE.Vector3(1, -1, -1), new THREE.Vector3(-1, 3, -1), new THREE.Vector3(-1, 3, 1), new THREE.Vector3(-1, -1, -1), new THREE.Vector3(-1, -1, 1) ]; // 组成立方体6个面的12个三角形面(要注意顶点顺序，顺时针顺序则是面向摄像机，反之则是背向摄像机) var faces = [ new THREE.Face3(0, 2, 1), new THREE.Face3(2, 3, 1), new THREE.Face3(4, 6, 5), new THREE.Face3(6, 7, 5), new THREE.Face3(4, 5, 1), new THREE.Face3(5, 0, 1), new THREE.Face3(7, 6, 2), new THREE.Face3(6, 3, 2), new THREE.Face3(5, 7, 0), new THREE.Face3(7, 2, 0), new THREE.Face3(1, 3, 4), new THREE.Face3(3, 6, 4), ]; // 创建自定义几何体对象 var geom = new THREE.Geometry(); geom.vertices = vertices; // 顶点数据 geom.faces = faces; // 三角形面数据 geom.computeFaceNormals(); // 确定每个面的法向量(决定不同光源下的颜色) // 材质数组，一个外观颜色，一个线框 var materials = [ new THREE.MeshLambertMaterial(&#123;opacity: 0.6, color: 0x44ff44, transparent: true&#125;), new THREE.MeshBasicMaterial(&#123;color: 0x000000, wireframe: true&#125;) ]; var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, materials); mesh.children.forEach(function (e) &#123; e.castShadow = true &#125;); // 展开这里可以看到由数组材质创建的mesh网格对应的两个子对象。 // mesh.children[0].translateX(0.5); // 平移 // mesh.children[0].translateZ(0.5); scene.add(mesh); var gui = new dat.GUI(); // gui添加clone属性, 点击clone按钮会复制一个新对象 gui.add(new function () &#123; this.clone = function () &#123; var clonedGeometry = mesh.children[0].geometry.clone(); var materials = [ new THREE.MeshLambertMaterial(&#123;opacity: 0.6, color: 0xff44ff, transparent: true&#125;), new THREE.MeshBasicMaterial(&#123;color: 0x000000, wireframe: true&#125;) ]; var mesh2 = THREE.SceneUtils.createMultiMaterialObject(clonedGeometry, materials); mesh2.children.forEach(function (e) &#123; e.castShadow = true &#125;); // X/Z轴平移 mesh2.translateX(5); mesh2.translateZ(5); mesh2.name = &quot;clone&quot;; scene.remove(scene.getChildByName(&quot;clone&quot;)); // 如果存在则先删除场景中旧的对象 scene.add(mesh2); &#125; &#125;, &#x27;clone&#x27;); function addControl(x, y, z) &#123; var controls = new function () &#123; this.x = x; this.y = y; this.z = z; &#125;; return controls; &#125; // gui插件关联8个顶点数据，并赋初值 var controlPoints = []; controlPoints.push(addControl(3, 5, 3)); controlPoints.push(addControl(3, 5, 0)); controlPoints.push(addControl(3, 0, 3)); controlPoints.push(addControl(3, 0, 0)); controlPoints.push(addControl(0, 5, 0)); controlPoints.push(addControl(0, 5, 3)); controlPoints.push(addControl(0, 0, 0)); controlPoints.push(addControl(0, 0, 3)); // gui添加8个顶点属性 for (var i = 0; i &lt; 8; i++) &#123; f1 = gui.addFolder(&#x27;Vertices &#x27; + (i + 1)); // addFolder添加组 f1.add(controlPoints[i], &#x27;x&#x27;, -10, 10); f1.add(controlPoints[i], &#x27;y&#x27;, -10, 10); f1.add(controlPoints[i], &#x27;z&#x27;, -10, 10); &#125; render(); function render() &#123; stats.update(); // 关联gui的顶点数据重新绘制 var vertices = []; for (var i = 0; i &lt; 8; i++) &#123; vertices.push(new THREE.Vector3(controlPoints[i].x, controlPoints[i].y, controlPoints[i].z)); &#125; // 网格顶点更新重新渲染，(children.forEach遍历子对象和前面使用traverse方法遍历子对象类似) mesh.children.forEach(function (e) &#123; e.geometry.vertices = vertices; e.geometry.verticesNeedUpdate = true; e.geometry.computeFaceNormals(); &#125;); // render using requestAnimationFrame requestAnimationFrame(render); renderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms // Align top-left stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init; // 改变窗口大小后适配 function onResize() &#123; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); &#125; window.addEventListener(&#x27;resize&#x27;, onResize, false);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通过传统指定几何体的顶点和面来创建几何体。通过改变顶点数据，观察几何体的变化。 同时学习了一个复制几何体的方法clone的使用。 扩展：本章示例我们为几何体添加线框是通过数组材质，使用createMultiMaterialObject方法来添加的。threejs其实还有另一个方法： var helper &#x3D; new THREE.WireframeHelper(mesh, 0x000000); scene.add(helper); 这样添加线框，helper其实是一个THREE.Line对象，你还可以设置线框如何显示，比如使用helper.material.linewidth &#x3D; 2来指定线框的宽度。 效果： 4. 网格对象常用属性和方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191&lt;!-- chapter-02-04.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Mesh Properties&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); var renderer = new THREE.WebGLRenderer(); renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMapEnabled = true; var planeGeometry = new THREE.PlaneGeometry(60, 40, 1, 1); var planeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xffffff&#125;); var plane = new THREE.Mesh(planeGeometry, planeMaterial); plane.receiveShadow = true; plane.rotation.x = -0.5 * Math.PI; plane.position.x = 0; plane.position.y = 0; plane.position.z = 0; scene.add(plane); camera.position.x = -30; camera.position.y = 40; camera.position.z = 30; camera.lookAt(scene.position); var ambientLight = new THREE.AmbientLight(0x0c0c0c); scene.add(ambientLight); var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(-40, 60, 020); spotLight.castShadow = true; scene.add(spotLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(renderer.domElement); // gui显示属性 var controls = new function () &#123; // 缩放 this.scaleX = 1; this.scaleY = 1; this.scaleZ = 1; // 坐标(绝对坐标) this.positionX = 0; this.positionY = 4; this.positionZ = 0; // 旋转 this.rotationX = 0; this.rotationY = 0; this.rotationZ = 0; this.scale = 1; // 平移(相对坐标) this.translateX = 0; this.translateY = 0; this.translateZ = 0; // 是否显示 this.visible = true; // 设置平移后，点击translate按钮生效 this.translate = function () &#123; // 平移 cube.translateX(controls.translateX); cube.translateY(controls.translateY); cube.translateZ(controls.translateZ); // 平移后更新gui坐标属性 controls.positionX = cube.position.x; controls.positionY = cube.position.y; controls.positionZ = cube.position.z; &#125; &#125;; var material = new THREE.MeshLambertMaterial(&#123;color: 0x44ff44&#125;); var geom = new THREE.BoxGeometry(5, 8, 3); var cube = new THREE.Mesh(geom, material); cube.position.y = 4; cube.castShadow = true; scene.add(cube); var gui = new dat.GUI(); guiScale = gui.addFolder(&#x27;scale&#x27;); // 添加组 guiScale.add(controls, &#x27;scaleX&#x27;, 0, 5); guiScale.add(controls, &#x27;scaleY&#x27;, 0, 5); guiScale.add(controls, &#x27;scaleZ&#x27;, 0, 5); guiPosition = gui.addFolder(&#x27;position&#x27;); var contX = guiPosition.add(controls, &#x27;positionX&#x27;, -10, 10); var contY = guiPosition.add(controls, &#x27;positionY&#x27;, -4, 20); var contZ = guiPosition.add(controls, &#x27;positionZ&#x27;, -10, 10); // 监听gui坐标属性变化 contX.listen(); contX.onChange(function (value) &#123; cube.position.x = controls.positionX; // 更新坐标信息 &#125;); contY.listen(); contY.onChange(function (value) &#123; cube.position.y = controls.positionY; &#125;); contZ.listen(); contZ.onChange(function (value) &#123; cube.position.z = controls.positionZ; &#125;); guiRotation = gui.addFolder(&#x27;rotation&#x27;); guiRotation.add(controls, &#x27;rotationX&#x27;, -4, 4); guiRotation.add(controls, &#x27;rotationY&#x27;, -4, 4); guiRotation.add(controls, &#x27;rotationZ&#x27;, -4, 4); guiTranslate = gui.addFolder(&#x27;translate&#x27;); guiTranslate.add(controls, &#x27;translateX&#x27;, -10, 10); guiTranslate.add(controls, &#x27;translateY&#x27;, -10, 10); guiTranslate.add(controls, &#x27;translateZ&#x27;, -10, 10); guiTranslate.add(controls, &#x27;translate&#x27;); gui.add(controls, &#x27;visible&#x27;); render(); function render() &#123; stats.update(); // 是否显示 cube.visible = controls.visible; // 旋转 cube.rotation.x = controls.rotationX; cube.rotation.y = controls.rotationY; cube.rotation.z = controls.rotationZ; // 缩放 cube.scale.set(controls.scaleX, controls.scaleY, controls.scaleZ); // 重新渲染 requestAnimationFrame(render); renderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms // Align top-left stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init; // 改变窗口大小后适配 function onResize() &#123; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); &#125; window.addEventListener(&#x27;resize&#x27;, onResize, false);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; dat.GUI插件使用流程： 定义gui显示属性，函数对象中定义。 使用gui.add方法将属性添加进gui。 将gui添加的属性和渲染对象对应属性关联。(1. render重新渲染时关联。2. listen监听属性变化时关联。3. gui属性绑定函数关联，即点击这个属性会回调这个函数。) 网格对象的属性和方法： 方法 描述 position 设置相对于父节点的坐标 rotation 设置绕x&#x2F;y&#x2F;z轴旋转 scale 设置沿x&#x2F;y&#x2F;z轴缩放 translate 设置沿x&#x2F;y&#x2F;z轴平移 visible 设置对象是否可见 效果： 5. 摄像机threejs库提供了两种摄像机：正交投影摄像机和透视投影摄像机。正交投影摄像机，没有近大远小效果，场景所有物体都是实际大小被渲染，这种摄像机一般用于二维场景中。而透视投影摄像机，场景中的物体表现为近大远小，更接近现实。 透视投影摄像机的创建方法：THREE.PerspectiveCamera(fov, aspect, near, far, zoom) fov属性决定了横向视场。基于aspect属性，纵向视场也就相应地确定了。near属性决定了近面距离，far属性决定了远面距离。近面和远面之间的区域将会被渲染。 正交投影摄像机的创建方法：OrthographicCamera(left, right, top, bottom, near, far, zoom) 就是一个盒子。 示例：能够切换两种摄像机，并且在屏幕中间从左向右移动(屏幕中央的红点位置)，看起来场景中物体在移动，其实它们没动，只是摄像机移动，在不同位置观察场景产生的效果。同时我们可以看到切换摄像机时，正交投影摄像机拍摄出来的所有立方体大小都一样，而透视投影摄像机拍摄出来的立方体表现为近大远小。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146&lt;!-- chapter-02-05.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Cameras&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function init() &#123; var stats = initStats(); var scene = new THREE.Scene(); // 默认创建透视投影摄像机 var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.x = 120; camera.position.y = 60; camera.position.z = 180; var renderer = new THREE.WebGLRenderer(); renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); renderer.setSize(window.innerWidth, window.innerHeight); var planeGeometry = new THREE.PlaneGeometry(180, 180); var planeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xffffff&#125;); var plane = new THREE.Mesh(planeGeometry, planeMaterial); plane.rotation.x = -0.5 * Math.PI; plane.position.x = 0; plane.position.y = 0; plane.position.z = 0; scene.add(plane); // 创建立方体块平面 var cubeGeometry = new THREE.BoxGeometry(4, 4, 4); var cubeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0x00ee22&#125;); for (var j = 0; j &lt; (planeGeometry.parameters.height / 5); j++) &#123; for (var i = 0; i &lt; planeGeometry.parameters.width / 5; i++) &#123; var cube = new THREE.Mesh(cubeGeometry, cubeMaterial); cube.position.z = -((planeGeometry.parameters.height) / 2) + 2 + (j * 5); cube.position.x = -((planeGeometry.parameters.width) / 2) + 2 + (i * 5); cube.position.y = 2; scene.add(cube); &#125; &#125; // 创建红点，和摄像机一起移动，标志摄像机当前移动的位置 var lookAtGeom = new THREE.SphereGeometry(2); var lookAtMesh = new THREE.Mesh(lookAtGeom, new THREE.MeshLambertMaterial(&#123;color: 0xff0000&#125;)); scene.add(lookAtMesh); // 光源下节再详细介绍 var directionalLight = new THREE.DirectionalLight(0xffffff, 0.7); directionalLight.position.set(-20, 40, 60); scene.add(directionalLight); var ambientLight = new THREE.AmbientLight(0x292929); scene.add(ambientLight); document.getElementById(&quot;WebGL-output&quot;).appendChild(renderer.domElement); // 切换摄像机 var step = 0; var controls = new function () &#123; this.perspective = &quot;Perspective&quot;; this.switchCamera = function () &#123; if (camera instanceof THREE.PerspectiveCamera) &#123; camera = new THREE.OrthographicCamera(window.innerWidth / -16, window.innerWidth / 16, window.innerHeight / 16, window.innerHeight / -16, -200, 500); camera.position.x = 120; camera.position.y = 60; camera.position.z = 180; // 设置摄像机位置 camera.lookAt(scene.position); this.perspective = &quot;Orthographic&quot;; &#125; else &#123; camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.x = 120; camera.position.y = 60; camera.position.z = 180; camera.lookAt(scene.position); this.perspective = &quot;Perspective&quot;; &#125; &#125;; &#125;; var gui = new dat.GUI(); gui.add(controls, &#x27;switchCamera&#x27;); // 点击切换摄像机 gui.add(controls, &#x27;perspective&#x27;).listen(); // 监听perspective字段变化，自动刷新text显示。不需要绑定回调方法。 render(); var step = 0; function render() &#123; stats.update(); // 移动摄像机和红点 step += 0.02; if (camera instanceof THREE.Camera) &#123; var x = 10 + ( 100 * (Math.sin(step))); camera.lookAt(new THREE.Vector3(x, 10, 0)); lookAtMesh.position.copy(new THREE.Vector3(x, 10, 0)); &#125; //.position.x = 20+( 10*(Math.cos(step))); requestAnimationFrame(render); renderer.render(scene, camera); &#125; function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: ms // Align top-left stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; window.onload = init; // 改变窗口大小后适配 function onResize() &#123; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); &#125; window.addEventListener(&#x27;resize&#x27;, onResize, false);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果：","categories":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/categories/threejs/"}],"tags":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/tags/threejs/"},{"name":"几何体和网格","slug":"几何体和网格","permalink":"https://cxx001.gitee.io/tags/%E5%87%A0%E4%BD%95%E4%BD%93%E5%92%8C%E7%BD%91%E6%A0%BC/"},{"name":"摄像机","slug":"摄像机","permalink":"https://cxx001.gitee.io/tags/%E6%91%84%E5%83%8F%E6%9C%BA/"}],"keywords":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/categories/threejs/"}]},{"title":"threejs入门","slug":"threejs/threejs入门","date":"2023-01-06T08:39:10.000Z","updated":"2023-03-14T05:40:58.937Z","comments":true,"path":"2023/01/06/threejs/threejs入门/","link":"","permalink":"https://cxx001.gitee.io/2023/01/06/threejs/threejs%E5%85%A5%E9%97%A8/","excerpt":"","text":"前言随着HTML5的发布，我们可以通过WebGL在浏览器上直接使用显卡资源来创建高性能的二维和三维图形，但是直接使用WebGL编程来创建三维场景十分复杂而且还容易出问题。而使用Three.js库可以简化这个过程，它对WebGL做了进一步封装，降低了使用门槛。WebGL整体原理其实和OpenGL差不多，只是运行平台不同而已，它是基于OpenGL-ES绑定javascript而来。 底层关系: OpenGL ES &#x3D;&gt; WebGL &#x3D;&gt; Threejs 注: 本系列教程并不是用的threejs最新版，threejs官方一直在持续优化更新，可能有些API使用有些许变化。本系列教程重在学习理论，只有掌握这些后，后续关注官网最新版使用才能如鱼得水。threejs官网: 点击这里 环境搭建three.js是一个javascript库，所以环境搭建和我们web开发环境搭建一样。 编码IDE，我用的vscode， 下载地址。 搭建web服务器。 方式有很多，我用的nodejs的http-server模块。 12345// 全局安装npm install -g http-server// 启动服务http-server 访问示例程序。 对应示例程序目录下启动http-server，默认端口是8080。浏览器访问url，如: localhost:8080/chapter-01.html 入门示例程序入门示例我们将使用three.js库创建如下主要内容： html页面如何引入three.js库。 使用three.js创建场景、摄像机、光源、渲染物体。 给场景添加阴影和动画效果。 添加辅助库dat.GUI和stats.js 创建用户控制界面(动态调渲染参数)和场景渲染时的帧数。 本系列所有示例程序引用的外部库和资源下载地址：示例程序资源下载 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164&lt;!-- chapter-01.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;入门示例&lt;/title&gt; &lt;!-- 引入three.js等相关库，three.js库引入有两个版本，这里为了学习引入的是没有压缩的版本，还一个three.min.js是压缩过的，只有three.js的四分之一大小，一般用于发布版本 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/three.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/stats.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;Stats-output&quot;&gt;&lt;/div&gt;&lt;div id=&quot;WebGL-output&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var camera; var scene; var renderer; function init() &#123; // 初始化fps显示 var stats = initStats(); // 创建场景 scene = new THREE.Scene(); // 创建摄像机 camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); // 创建渲染器 renderer = new THREE.WebGLRenderer(); renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)); // 设置背景颜色 renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMapEnabled = true; // 开启阴影(默认是关闭的，因为它比较耗计算资源) // 创建平面 var planeGeometry = new THREE.PlaneGeometry(60, 20, 1, 1); var planeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xffffff&#125;); // 物体受光源影响和使用的材质有关系，如果是MeshBasicMaterial基本材质，不会对光源有任何反应，只会使用指定的颜色来渲染物体。MeshLambertMaterial和MeshPhongMaterial材质在渲染时会对光源产生反应，没有光它就是漆黑的。 var plane = new THREE.Mesh(planeGeometry, planeMaterial); plane.receiveShadow = true; // 开启接受阴影 // 旋转和设置平面位置 plane.rotation.x = -0.5 * Math.PI; // 绕x轴旋转90度 plane.position.x = 15; plane.position.y = 0; plane.position.z = 0; // 将平面添加到场景容器中 scene.add(plane); // 创建立方体 var cubeGeometry = new THREE.BoxGeometry(4, 4, 4); var cubeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xff0000&#125;); var cube = new THREE.Mesh(cubeGeometry, cubeMaterial); cube.castShadow = true; // 开启投射阴影 // 同上 cube.position.x = -4; cube.position.y = 3; cube.position.z = 0; scene.add(cube); // 创建球体 var sphereGeometry = new THREE.SphereGeometry(4, 20, 20); var sphereMaterial = new THREE.MeshLambertMaterial(&#123;color: 0x7777ff&#125;); var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial); sphere.castShadow = true; // 同上 sphere.position.x = 20; sphere.position.y = 0; sphere.position.z = 2; scene.add(sphere); // 设置摄像机位置 camera.position.x = -30; camera.position.y = 40; camera.position.z = 30; camera.lookAt(scene.position); // 添加光源 var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(-40, 60, -10); spotLight.castShadow = true; // 开启投射阴影 scene.add(spotLight); // 把渲染器对象添加到div中显示 document.getElementById(&quot;WebGL-output&quot;).appendChild(renderer.domElement); // 设置需要动态调参的参数 var controls = new function () &#123; this.rotationSpeed = 0.02; this.bouncingSpeed = 0.03; &#125;; // dat.GUI是Google员工开发的动态调参数的插件，这样就大大方便了我们调整相关渲染参数的操作了 var gui = new dat.GUI(); gui.add(controls, &#x27;rotationSpeed&#x27;, 0, 0.5); // 参数对象、参数名、参数的取值范围 gui.add(controls, &#x27;bouncingSpeed&#x27;, 0, 0.5); render(); // 渲染场景 var step = 0; function render() &#123; // 更新fps stats.update(); // 旋转立方体的各个面 cube.rotation.x += controls.rotationSpeed; cube.rotation.y += controls.rotationSpeed; cube.rotation.z += controls.rotationSpeed; // 球体跳动 step += controls.bouncingSpeed; sphere.position.x = 20 + ( 10 * (Math.cos(step))); sphere.position.y = 2 + ( 10 * Math.abs(Math.sin(step))); // 重新渲染场景 requestAnimationFrame(render); renderer.render(scene, camera); &#125; // 初始化fps显示 function initStats() &#123; var stats = new Stats(); stats.setMode(0); // 0: fps, 1: 渲染时间ms stats.domElement.style.position = &#x27;absolute&#x27;; stats.domElement.style.left = &#x27;0px&#x27;; stats.domElement.style.top = &#x27;0px&#x27;; document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement); return stats; &#125; &#125; // 窗口大小发生变化后重新适配渲染场景 function onResize() &#123; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); &#125; // 监听窗口大小发生变化事件 window.addEventListener(&#x27;resize&#x27;, onResize, false); // 页面加载完成后调用init方法 window.onload = init;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 显示效果：","categories":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/categories/threejs/"}],"tags":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/tags/threejs/"},{"name":"webGL","slug":"webGL","permalink":"https://cxx001.gitee.io/tags/webGL/"}],"keywords":[{"name":"threejs","slug":"threejs","permalink":"https://cxx001.gitee.io/categories/threejs/"}]},{"title":"boost库使用","slug":"notes/boost库使用","date":"2022-12-21T03:36:55.000Z","updated":"2023-03-14T05:39:32.042Z","comments":true,"path":"2022/12/21/notes/boost库使用/","link":"","permalink":"https://cxx001.gitee.io/2022/12/21/notes/boost%E5%BA%93%E4%BD%BF%E7%94%A8/","excerpt":"","text":"windows下boost库使用下面介绍完整安装boost库的方法： 1. 去boost官网下载最新的boost库boost库官网 2. 解压boost压缩包，打开根目录双击运行bootstrap.bat，会生成b2.exe。然后执行以下命令： b2.exe --toolset=msvc --build-type=complete stage 或者直接双击运行b2.exe。 等待编译完成，会在boost根目录下生成bin.v2和stage两个文件夹，其中bin.v2是中间文件，可以删除。stage下才是生成的dll或lib文件。 3. 打开VS配置属性打开项目属性， VC++目录–&gt;包含目录，添加boost的根目录，如：C:\\Users\\KL179\\Desktop\\boost_1_81_0。 VC++目录–&gt;库目录，添加stage下的库目录，如：C:\\Users\\KL179\\Desktop\\boost_1_81_0\\stage\\lib。 链接器–&gt;常规–&gt;附加库目录，添加同2库目录。 至此环境就以及配置好了，下面测试一下： 12345678910111213141516#include &quot;boost/thread/thread.hpp&quot;#include &lt;iostream&gt;#include &lt;string&gt;void hello()&#123; std::cout &lt;&lt; &quot;Hello world, I&#x27;&#x27;m a thread!&quot; &lt;&lt; std::endl;&#125;int main()&#123; boost::thread thrd(&amp;hello); thrd.join(); return 0;&#125; 程序正常运行： 4. b2编译命令说明b2.exe --show-libraries 列出所有编译的库 b2.exe --help 查看所有参数使用 综合使用： 1234567b2.exe toolset=msvc-10.0 architecture=x86 address-model=32link=static variant=debug,release threading=multi runtime-link=shared--without-python --without-mpi --without-wave --without-graph--without-math --without-serialization stage toolset：表示编译器工具，我安装的是VS2010，所以是msvc-10(如果你是VS2005，可以使用msvc-8.0 VS2008是msvc-9.0) architecture：表示架构，也就是你的CPU架构，x86,x64，因为我安装的是win7 32位，所以使用了x86的架构。 address-model：表示地址长度为32位。 link：表示生成动态&#x2F;静态链接库，动态链接库是shared，静态链接库是static，一般都会编译成静态库，因为给出程序的时候打包boost的库会非常庞大。 variant：表示生成的Debug或者release版本，一般情况下会两种版本都会编译出来的。 threading：表示单&#x2F;多线程编译，一般我们的程序都会用到多线程，所以选择了multi。 runtime-link：表示动态&#x2F;静态链接C&#x2F;C++运行时库(C&#x2F;C++ Runtime)，我们选择了动态链接。 without&#x2F;with：表示不需要编译&#x2F;需要编译哪些库，一些自己不用的库可以无需编译。 stage&#x2F;install：stage表示只生成库文件(DLL和Lib)，install还会生成包含头文件的include目录，推荐使用stage，因为boost_1_49\\boost中就是boost库完整的头文件，所以无需再拷贝一份出来。编译出来的库会放在stage文件夹中。 Linux下boost库使用1. 去boost官网下载最新的boost库同上 2. 解压boost压缩包，进入根目录执行./bootstrap.sh --prefix=/usr/local/boost_lib。生成编译工具b2。 prefix是指定编译生成的include&#x2F;lib路径，默认是在&#x2F;usr&#x2F;local下。 注意： 执行.&#x2F;bootstrap.sh报下面错误： .&#x2F;bootstrap.sh Could not find a suitable toolset. You can specify the toolset as the argument, i.e.: .&#x2F;build.sh [options] gcc。。。 这是因为系统没有安装编译工具。 sudo apt updatesudo apt install build-essential &#x2F;&#x2F; 这个命令将会安装一系列软件包，包括gcc,g++,和make。 3. 编译boost库执行./b2 install --with=all 完全编译，并会把生成的include和lib目录放到&#x2F;usr&#x2F;local&#x2F;boost_lib下。 4. 测试测试程序同上。 编译命令： 1g++ main.cpp -I /usr/local/boost_lib/include -I /home/boost_1_81_0 -L /usr/local/boost_lib/lib -lboost_thread -lboost_system -lpthread -I 是指定头文件查找目录，多个用对应多个-I指定。 -L 是指定链接库目录。 -lxxx 是指定用到的库名称。 编译完成，会生成a.out执行文件，这时直接运行还会报错： 1./a.out: error while loading shared libraries: libboost_thread.so.1.81.0: cannot open shared object file: No such file or directory 解决方法： 1sudo ldconfig /usr/local/lib/boost_lib/lib ldconfig命令的作用：ldconfig是一个动态链接库管理命令。安装完成某个工程后生成许多动态库，为了让这些动态链接库为系统所共享，还需运行动态链接库的管理命令–ldconfig。 执行结果：","categories":[{"name":"notes","slug":"notes","permalink":"https://cxx001.gitee.io/categories/notes/"}],"tags":[{"name":"boost","slug":"boost","permalink":"https://cxx001.gitee.io/tags/boost/"}],"keywords":[{"name":"notes","slug":"notes","permalink":"https://cxx001.gitee.io/categories/notes/"}]},{"title":"《Effective C++》 全书内容提炼总结","slug":"notes/Effective C++","date":"2022-12-19T11:10:55.000Z","updated":"2022-12-21T03:33:45.529Z","comments":true,"path":"2022/12/19/notes/Effective C++/","link":"","permalink":"https://cxx001.gitee.io/2022/12/19/notes/Effective%20C++/","excerpt":"","text":"本文阅读说明孔子云：“取乎其上，得乎其中；取乎其中，得乎其下；取乎其下，则无所得矣”。 对于读书求知而言，这句古训教我们去读好书，最好是好书中的上品—-经典书。《Effective C++》就是这类经典书，值得反复去读，每次都能有不一样的收获。 有人说C++程序员可以分为两类，读过Effective C++的和没读过的。近段再次精读记录下全书纲领，每小节最后都有请记住精炼总结，便于日后据此回顾。 本书电子版 一、让自己习惯C++1. 视C++为一个语言联邦C++可以看成是相关语言组成的一个集合而非单一语言，在其某个次语言中，各种守则与示例都倾向于简单、直观易懂、并且容易记住。然而当你从一个次语言移往另一个次语言，守则可能改变。每个次语言都有自己的规约。 为了深刻理解C++，你必须认识其主要的次语言。幸运的是总共只有4个： C Object C++ 也就是带类的C Template C++ 这是C++的范型编程 STL 是个template程序库 请记住 C++ 高效编程守则视状况而变化，取决于你使用C++ 的哪一部分。 2. 尽量用 const, enum, inline 替换 #definedefine只是在预处理器中做简单的字符替换，编译器根本就不知道define定义的宏符号。 使用define存在一些问题： 没有作用域，只能全局的。 常量宏定义如果出错，编译器报错只知道常量值，根本就不知道宏名称，排错时容易让人迷惑。 带参数的宏使用时要特别小心运算优先级，受参数内容影响，特别容易错误。 没有类型检查。 所以对于定义常量一般我们用const替换，有两种特殊情况值得说说。 第一是定义常量指针，由于常量定义通常在头文件内(以便被不同的源码引入)，因此有必要将指针和指针所指的值都声明为const，也就是常量指针常量。 1const char * const authorName = &quot;Scott Meyers&quot;; 这种定义字符串常量，我们一般用string对象更合宜。 1const std::string authorName = &quot;Scott Meyers&quot;; 第二是类里的常量定义。为了确保此常量至多只有一份，你必须让它成为一个static成员: 12345678910111213class GamePlayer &#123;private: static const int NumTurns = 5; // 如果编译器认为这只是声明，那么要把这个定义写到cpp中 int scores[NumTurns]; // 这种编译器可能不允许用static常量，那么我们可以用enum替换&#125;// 使用enum来声明数组长度值(数组在编译时编译器必须知道它的长度)class GamePlayer &#123;private: enum &#123;NumTurns = 5&#125;; int scores[Numturns]; // 这就没问题了&#125; 下面我们再看define定义带参数的函数式宏容易错误的例子： 12345678// a和b的较大值调用f#define CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b));int a = 5, b = 0;CALL_WITH_MAX(++a, b); // a被累加两次CALL_WITH_MAX(++a, B+10); // a被累加一次// 在这里，调用f之前，a的累加次数竟然取决于它被拿来和谁比较~ 我们用inline来替换的话，效率上不会比define差，都是在调用处直接展开，没有函数调用的开销。也不需要考虑宏参数都加括号和参数被计算多次等问题。 12345template&lt;typename T&gt;inline void callWithMax(const T&amp; a, const T&amp; b)&#123; f(a &gt; b ? a : b);&#125; 请记住 对于单纯常量，最好以const 对象或 enum替换define 对于形似函数的宏，最好改用inline函数替换define 3. 尽可能使用const 常量指针、指针常量、常量指针常量 123const char* p = &quot;greeting&quot;; // 常量指针，数据不能修改char* const p = &quot;greating&quot;; // 指针常量，指针不能修改const char* const p = &quot;greating&quot; // 常量指针常量，指针和数据都不能修改 stl迭代器常量 迭代器的作用就像个 T* 指针。 const修饰迭代器，其实类似T* const，它是迭代器不能修改，但所指的值可以修改。如果要保证值也不能修改，那就只能用 const_iterator 迭代器了。 123456789std::vector&lt;int&gt; vec;...const std::vector&lt;int&gt;::iterator iter = vec.begin();*iter = 10; // 没问题，改变iter所指的值++iter; // 错误! iter指针是常量std::vector&lt;int&gt;::const_iterator citer = vec.begin();*citer = 10; // 错误! *citer是常量++citer; // citer指针可以改变，没问题 const成员函数 const成员函数：在其函数体内不能修改该对象的数据成员，这里本质const修饰的是函数隐式参数this。 const对象只能调用const成员函数，本质也一样，因为修饰的是this。(const成员函数可以被非const对象调用) 如果在const函数中确实想修改某些数据成员，那么可以把这些数据成员声明时用 mutable 修改，表示可变的。 补充: 函数重载： 函数的参数不同(个数、顺序)，与返回值无关 常量性不同，也可以重载 (常量成员函数与非常量成员函数也能重载) 类型转换： 12345678// 除const修饰的对象类型转换用 static_castdouble somevalue = 3.14;void* p = &amp;somevalue;double* pd = static_cast&lt;double*&gt;(p); // 将 void*类型指针转换为double*类型// 去除const对象的常量属性用 const_castconst char* pc;char* p = const_cast&lt;char*&gt;(pc); // 将常量指针pc转换为普通指针 请记住 将某些东西声明为 const 可帮助编译器识别错误用法。const 可被用于任何作用域内的对象、函数参数、函数返回值、成员函数体。 编译器强制实施 “const修饰对象不能被修改” ，但你编写程序时应该使用 ”概念上的常量性“。 当 const 和 non-const 成员函数有着一样的实现时，可以用non-const 版本调用const 版本可以避免代码重复。 4. 确定对象被使用前已先被初始化读取未初始化的值会导致不明确的行为。在某些平台上，仅仅只是读取未初始化的值，就可能让你的程序终止运行。更可能的情况是读入一些”半随机”值，污染了正在进行读取动作的那个对象，最终导致不可预测的程序行为，以及许多令人不愉快的调试过程。 所有我们定下一个规则，永远在使用对象之前将它初始化。这很简单，但是对于自定义类型，初始化责任就落在构造函数身上了，这里重要的是别混淆了赋值和初始化。 在构造函数里给成员数据赋值不是初始化，而是赋值操作。程序会先调用默认构造函数初始化，然后再调用自身构造函数赋值。这里要避开赋值操作就得用成员初始化列表的形式，这样在调用默认构造函数时直接使用成员初始化列表的值初始化，这样效率也更高。 自定义类型数据初始化顺序和它声明时一致，和构造函数里赋值顺序无关，所以为了不让阅读者歧义，我们约定构造函数里初始化数据时顺序和声明时保持一致。 当我们已经做到在对象创建时都初始化它，那么就只有一件事情需要操心了，那就是注意不同编译单元内定义的全局对象的初始化顺序（不同编译单元指不同的cpp源文件中）。 1234567class FileSystem &#123;public: ... std::size_t numDisks() const; ...&#125;;extern FileSystem tfs; // 给其它类使用的全局对象 1234567891011121314class Directory &#123;public: Directory(params); ...&#125;;Directory::Directory(params)&#123; ... std::size_t disks = tfs.numDisks(); // 使用其它编译单元的对象 ...&#125;// 创建一个Directory对象Directory tempDir(params); 这样上面两个编译单元的对象谁先初始化，这个编译器也不知道。 对于不同编译单元的全局对象初始化顺序问题，要避免我们得把全局对象包装到函数块里。 1234567891011121314151617181920212223class FileSystem &#123;...&#125;;FileSystem&amp; tfs()&#123; static FileSystem fs; return fs;&#125;///////////////////////////////////////class Directory &#123;...&#125;;Directory::Directory(params)&#123; ... std::size_t disks = tfs().numDisks(); ...&#125;Directory&amp; tempDir()&#123; static Directory td; return td;&#125; 将全局对象封装到函数里，把直接访问全局对象改为调用函数的形式，这样就不用关心跨编译单元对象的初始化顺序问题了。 请记住 为内置类型对象进行手工初始化，因为c++不保证初始化它们。 构造函数最好使用成员初始化列表，而不要在构造函数本体内使用赋值操作。初始化列表的成员变量，其顺序应该与它们声明顺序一致。 为避免”跨编译单元的初始化顺序”问题，请用函数包装替换全局对象。 二、构造&#x2F;析构&#x2F;赋值运算5. 了解C++默默编写并调用哪些函数当编写了一个空类，C++编译器会自动(如果它们被使用的话)给这个空类生成一个默认构造函数、一个拷贝构造函数、一个赋值操作符重载函数和一个析构函数。 1234567891011// 如果你写下这么个空类class Empty &#123;&#125;;// 这就好像你写下这样的代码class Empty &#123; Empty() &#123;...&#125; Empty(const Empty&amp; rhs) &#123;...&#125; ~Empty() &#123;...&#125; Empty&amp; operator=(const Empty&amp; rhs) &#123;...&#125;&#125; 注意上面4个函数： 只有它们被需要(被调用)，它们才会真正被编译器创建出来。 只要被我重定义了的，编译器就不会再自动生成它们。注意：如果我重定义了任何构造函数则默认构造函数就不会自动创建了，而如果只重定义了默认构造函数，则上面剩余函数编译器还是会自动生成。 上面自动生成的拷贝构造函数和赋值操作符函数其内部实现如出一辙，但是有下面3种特殊情况，编译器会拒绝生成赋值操作符函数。 带有&amp; 引用的成员。 带有const的成员。 某个基类将赋值操作符函数声明为private，那么其派生类编译器也会拒绝生成赋值操作符函数。 1、2情况示例： 12345678910111213141516template&lt;class T&gt;class NameObject &#123;public: NameObject(std::string&amp; name, const T&amp; value);private: std::string&amp; nameValue; const T objectValue;&#125;// 考虑下面会发生什么事：std::string newDog(&quot;Persephone&quot;);std::string oldDog(&quot;Satch&quot;);NameObject&lt;int&gt; p(newDog, 2);NameObject&lt;int&gt; s(oldDog, 36);p = s; // 这是不允许的，1. 引用只能指向引用的对象不能修改 2. const修饰成员不能被修改 请记住 编译器可以暗自为class创建default构造函数、copy构造函数、copy assignment操作符，析构函数。 6. 若不想使用编译器自动生成的函数，就该明确拒绝如果某个场景需要某个类对象是唯一独一份的，不想外部拷贝这个对象。 直接想到的是限制它的拷贝构造函数和赋值操作符函数，即不让外部调用它们。 那第一种方案就是重定义它们并声明为private属性（注意不要实现它们，目标是防止自己内部或friend函数调用）。 12345678class HomeForSale &#123;public: ...private: // 只声明不实现，目标是防止自己内部或friend函数调用 HomeForSale(const HomeForSale&amp;); HomeForSale&amp; operator=(const HomeForSale&amp;);&#125; 第二种方式是放基类里去声明它们为private属性，然后只需要继承它，那么派生类默认生成的拷贝构造函数和赋值操作符函数会去调用基类里对应的函数。从而达到同样效果(注意多重继承问题)。 12345678910class Uncopyable&#123;protected: Uncopyable() &#123;&#125;; ~Uncopyable() &#123;&#125;;private: Uncopyable(const Uncopyable&amp;); Uncopyable&amp; operator=(const Uncopyable&amp;);&#125;; 1234#include &quot;Uncopyable.h&quot;class HomeForSale : private Uncopyable&#123;&#125;; 请记住 为阻止编译器自动生成函数机制，可将相应的成员函数声明为private并且不予实现。或者继承像上面Uncopyable这样的基类也是一种做法。 7. 为多态基类声明virtual析构函数在多态场景中，基类指针指向派生类对象，delete基类指针，基类的析构函数要加virtual，不然只会销毁派生类中基类部分而自身内的成员没被销毁，于是造成一个诡异的局部销毁对象，导致内存泄漏、败坏数据结构。 如果一个类不含virtual函数，通常表示它并不意图被用做一个基类使用。当类不企图被当作基类，令其析构函数为virtual往往是个馊主意（平白多一个虚表指针空间）。记住虚函数一般用于多态场景的基类中。 许多人的心得是：只有当类内至少含有一个virtual函数，才为它声明virtual析构函数。 请记住 带多态性质的基类应该声明一个virtual析构函数。如何类带有任何virtual函数，它就应该拥有一个virtual析构函数。 类的设计目的如果不是作为基类使用，或不是为了具备多态性，就不该声明virtual析构函数。 8. 别让异常逃离析构函数析构函数抛出异常可能会带来不明确的行为。因此我们如果一定要在析构函数内执行可能失败的操作，就必须要用try...catch截取异常，不让异常从析构函数抛出去导致不明确行为发生。 截取异常正确做法一般有2种情况： 直接吞下异常或者结束程序。 12345678DBConn::~DBConn()&#123; try &#123; db.close(); &#125; catch (...) &#123; // std::abort(); //自己选择要么记录错误什么也不做，要么让程序终止 &#125;&#125; 可能失败的操作提供对外接口，使外部有机会对可能失败的情况做出反应。 123456789101112131415161718192021222324DBConn::~DBConn()&#123;public: void close() // 给外部一个处理有可能错误的机会 &#123; db.close(); closed = true; &#125; ~DBConn() &#123; if (!closed) &#123; try &#123; db.close(); &#125; catch (...) &#123; // std::abort(); //自己选择要么记录错误什么也不做，要么让程序终止 &#125; &#125; &#125; private: DBConnection db; bool closed;&#125; 请记住 析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吐下它们或者结束程序。 如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么类应该提供一个普通函数(而非在析构函数中)执行该操作。 9. 绝不在构造和析构过程中调用virtual函数这条规则是这么一个场景：在多态的基类构造或析构函数中调用重写的virtual函数，那么在派生类对象构造或析构时，调用的函数是基类的，并不是派生类重写后的。 因为在派生类构造时，先调基类的构造，此时派生类对象还不存在，并没有多态属性。析构也是同理，先把派生类释放了，再析构基类时，派生类对象也不存在了。 所以基类构造&#x2F;析构永远不要调用virtual函数，可行的方案是把virtual去掉，派生类通过传参调用。 请记住 在构造和析构期间不要调用virtual函数，因为这类调用从不下降至派生类。 10. 令operator&#x3D; 返回一个 reference to *this赋值操作符必须返回一个reference指向操作符的左侧实参。这是一个约定协议，并无强制性。如果不遵循代码也不会报错。然而所有内置类型和标志程序库提供的类型如string``vector``trl::shared_ptr等都遵循这个约定。因此除非你有一个标新立异的好理由，不然还是随众吧。 12345678910111213141516class Widget &#123;public: ... Widget&amp; operator+=(const Widget&amp; rhs) // 赋值相关的运行也适用这个约定+=，-=，*=等 &#123; ... return *this; &#125; Widget&amp; operator=(int rhs) &#123; ... return *this; &#125; ...&#125; 请记住 令赋值操作符返回一个reference to *this。 11. 在operator&#x3D; 中处理”自我赋值”重载赋值操作符时，要注意自我赋值的处理。像下面这样自我赋值时就会导致返回的指针指向一个已被删除的对象： 1234567891011121314// Widget w; w = w;class Widget &#123; ...private: BitMap* pb;&#125;Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; delete pb; pb = new Bitmap(*rhs.pb); return *this;&#125; 正确的写法有3种方式： 在开始处验证自我赋值 12345678Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; if(this == rhs) return *this; delete pb; pb = new Bitmap(*rhs.pb); return *this;&#125; 记录旧对象，改变调用顺序 1234567Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; Bitmap* pOrig = pb; pb = new Bitmap(*rhs.pb); delete pOrig; return *this;&#125; 创建副本做数据交换 123456Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; Widget temp(rhs); // 为rhs数据创建副本 swap(temp); // 将*this数据和副本的数据做交换 return *this;&#125; 请记住 确保当对象自我赋值时operator=有良好行为。其中技术包括比较来源对象和目标对象的地址、精心周到的语句顺序、以及copy-and-swap。 确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。 12. 复制对象时勿忘其每一个成分这里主要注意复制派生类对象时(拷贝构造函数和赋值操作符函数)，要主动调用其基类对应的复制函数。 先看下面不规范示例： 1234567891011121314151617181920class PriorityCustomer: public Customer &#123;public: ... PriorityCustomer(cosnt PriorityCustomer&amp; rhs); PriorityCustomer&amp; operator=(const PriorityCustomer&amp; rhs); ...private: int priority;&#125;PriorityCustomer::PriorityCustomer(const PriorityCustomer&amp; rhs): priority(rhs.priority)&#123;&#125;PriorityCustomer&amp; PriorityCustomer::operator=(const PriorityCustomer&amp; rhs)&#123; priority = rhs.priority; return *this;&#125; 上面这种只复制了派生类中的成员，由于没有指定实参给基类的拷贝构造函数，则会调用默认不带参的构造函数来构造基类成员。 正确写法： 123456789101112PriorityCustomer::PriorityCustomer(const PriorityCustomer&amp; rhs): Customer(rhs), // 调用基类构造函数 priority(rhs.priority)&#123;&#125;PriorityCustomer&amp; PriorityCustomer::operator=(const PriorityCustomer&amp; rhs)&#123; Customer::operator=(rhs); // 调用基类赋值操作 priority = rhs.priority; return *this;&#125; 如果上面两个复制函数重复代码很多，也可以考虑把重复部分封装到一个如：init的私有函数中，给两者调用。 请记住 复制函数(拷贝构造函数和赋值操作符函数)应该确保复制对象内的所有成员变量及所有基类成分。 不要尝试以某个复制函数实现另一个复制函数。应该将共同部分放进第三个函数中，并由两个复制函数共同调用。 三、资源管理13. 以对象管理资源为了防止资源泄漏，我们管理资源的释放一般不人为维护，而是通过对象构造时引用资源，析构时释放资源来管理。这样管理资源的对象我们称之为RAII(Resource Acquisition Is Initialization)对象。如：智能指针就是这样的思路。 请记住 为防止资源泄漏，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。 两个常被使用的RAII对象分别是shared_ptr和auto_ptr。前者通常是较佳选择，因为其copy行为比较直观。若选auto_prt，复制动作会使被复制对象变为null。 14. 在资源管理类中小心coping行为请记住 复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。(参考不同类型智能指针行为) 普遍而常见的RAII对象的复制行为是：转移资源、抑制copying、施行引用计数法。（同样可参考不同类型智能指针实现） 15. 在资源管理类中提供对原始资源的访问对于RAII类我们一般要提供对原始资源的访问。有两种方式：显示转换和隐式转换。 显示转换(提供一个接口get获取)： 12345678910111213141516171819// RAII类Fontclass Font &#123;public: explicit Font(FontHandle fh) : f(fh) &#123;&#125; ~Font() &#123;releaseFont(f);&#125; FontHander get() const &#123;return f;&#125; // 显示转换函数 private: FontHandle f; // 原始资源&#125;// 使用...void changeFontSize(FontHnadle f, int newSize);Font f(getFont());int newFontSize;...changeFontSize(f.get(), newFontSize); // 显示获取f的原始资源 隐式转换： 12345678910111213class Font &#123;public: ... operator FontHandler() const // 隐式转换函数 &#123;return f;&#125; ...&#125;// 使用Font f(getFont());int newFontSize;...changeFontSize(f, newFontSize); // 将Font隐式转换为FontHandler 请记住 RAII往往要求访问原始资源，所以每一个RAII类应该提供一个“取得其所管理之资源”的办法。 对原始资源的访问可能经由显示转换或隐式转换。一般而言显示转换比较安全，但隐式转换对客户比较方便。 16. 成对使用new和delete时要采取相同形式如果new对象，对应delelte对象，如果new数组，对应delete数组(加[])。这点很容易，不过注意一种情况，对数组使用了typedef重命名后，就比较隐蔽了。所以约定尽量不要对数组形式做typedef动作。这很容易达成，因为C++标准库含有string,vector等template，可将数组的需求降至几乎为零。 请记住 如果你在new表达式中使用[]，必须在相应的delete表达式中也使用[]。如果你在new表达式中不使用[]，一定不要在相应的delete表达式中使用[]。 17. 以独立语句将new对象置入智能指针1processWidget(std::tr1::shared_ptr&lt;Widget&gt;(new Widget), priority()); 编译器在调用processWidget之前，必须首先核算即将被传递的各个实参。上面第二实参只是一个单纯的对priority函数的调用，但第一实参std::tr1::shared_ptr&lt;Widget&gt;(new Widget)由两部分组成： 执行new Widget表达式 调用shared_ptr构造函数 于是在调用processWidget之前，编译器必须创建代码，做以下三件事： 调用priority 执行new Widget表达式 调用shared_ptr构造函数 c++编译器以什么样的次序完成这些事情呢？弹性很大。不过可以确定的是new Widget一定执行在share_ptr构造函数之前，因为这个表达式的结果还要被传递作为shard_ptr构造函数的一个实参，但对priority函数的调用则可以排在第一或第二或第三执行。如果编译器选择第二顺位执行它，最终获得这样的操作序列： 执行new Widget表达式 调用priority 调用shared_ptr构造函数 问题来了，如果2执行失败，抛异常了，那么1 new的内存还没来得及置入智能指针中，就导致内存泄漏了。 解决上面问题办法很简单，就是分离语句： 12std::tr1::shared_ptr&lt;Widget&gt; pw(new Widget);processWidget(pw, priority()); 以上之所以行得通，因为编译器对于跨语句的各项操作没有重新排序的自由(只有在语句内它拥有那个自由度)。 请记住 以独立语句将new对象置入智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄漏。 四、 设计与声明18. 让接口容易被正确使用，不易被误用理想上，如果客户企图使用某个接口而却没有获得他所预期的行为，这个代码就不该通过编译；如果代码通过了编译，它的行为就该是客户所想要的。尽量不要在运行期才发现问题。 示例一 日期的class设计构造函数 12345class Date &#123;public: Date(int month, int day, int year); ...&#125; 上面接口设计很容易让客户至少犯下两个错误。 他们也许会以错误的次序传递参数。 他们可能传递一个无效的月份或者天数。 正确的设计是： 12345678910111213141516171819202122232425262728293031323334353637383940// 限制类型struct Day &#123; explicit Day(int d) : val(d) &#123;&#125; int val;&#125;struct Month &#123; explicit Month(int m) : val(m) &#123;&#125; int val;&#125;struct Year &#123; explicit Year(int y) : val(y) &#123;&#125; int val;&#125;class Date &#123;public: Date(const Month&amp; m, const Day&amp; d, const Year&amp; y); ...&#125;;// 使用Date d(Month(12), Day(1), Year(2022));// 进一步限制参数的值有效性设计，如：class Month &#123;public: static Month Jan() &#123;return Month(1);&#125; static Month Feb() &#123;return Month(2);&#125; ... static Month Dec() &#123;return Month(12);&#125; ...private: explicit Month(int m); ... &#125;// 使用, 这样月份的值就由类里边约定好了Date d(Month::Dec(), Day(1), year(2022)); 示例二：通用行为接口一致性，与标准、内置类型尽量保持一致。STL容器的接口就十分一致，这使得它们非常容易被使用。例如每个STL容器都有一个名为size的成员函数，它会告诉调用者目前容器内有多少对象。 示例三：接口返回指针应该返回智能指针，不应该对外返回原始指针，客户还要关系指针释放操作。 1std::tr1::shared_ptr&lt;Investment&gt; createInvestment(); shared_ptr智能指针还一个特性，就是在创建时还可以指定自定义析构行为。 12// 参数1 是原始指针 参数2 引用计数为0时执行函数deleteFuncstd::tr1::shared_ptr&lt;Investment&gt; retVal(static_cast&lt;Investment*&gt;(0), deleteFunc); 接口返回智能指针还消除另一个潜在的客户错误，就是跨dll传递问题。这个问题发生于对象在动态库中被new创建，却在另一个动态库内被delete销毁。在许多平台上，这类问题会导致运行期错误。而使用shared_ptr就没有这个问题，因为当引用计数为0时会追踪调用原始那个动态库上的销毁。 请记住 好的接口很容易被正确使用，不容易被误用。你应该在你的所在接口中努力达成这些性质。 ”促进正确使用“ 的办法包括接口的一致性，以及与内置类型的行为兼容。 ”阻止误用“ 的办法包括建立新类型、限制类型上的操作(private)、束缚对象值，以及消除客户的资源管理责任。 tr1::share_ptr支持定制型删除器。这可防范dll问题，可被用来自动解除互斥锁(RAII类设计管理锁)等等。 19. 设计class犹如设计type类本质是自定义的类型，要像设计内置类型一样设计类。重载函数和操作符、控制内存的分配和归还、定义对象的初始化和终结……全都在你手上。 设计优秀的类是一项艰巨的工作，甚至类的成员函数效率都有可能受到它们“如何被声明”的影响。那么如何设计高效的类呢？下面提出了一些问题，你的回答往往导致你的设计规范： 新type的对象应该如何被创建和销毁？这会影响到你的构造函数和析构函数以及内存分配函数和释放函数(operator new, operator [], operator delete和operator delete[]) 的设计。(见第8章) 对象的初始化和对象的赋值该有什么样的差别？这个答案决定你的构造函数和赋值操作符的行为。(见条款4) 新type的对象如果以值传递，意味着什么？记住copy构造函数决定了你以值传递的行为。 什么是新type的合法值？对class外部传入的参数一定要做错误检测工作。 你的新type要考虑继承或被继承影响么？如果你继承已有的classes，你就受到那些classes的设计的束缚，特别是受到它们的函数是virtual或non-virtual的影响。如果你允许其它classes继承你的class,那会影响你所声明的函数，尤其是析构函数是否加virtual。(见条款7、34、36) 你的新type需要什么样的转换？你是否希望你的type和其它types之间可以转换，是隐式转换或显示转换。或者不允许隐式转换，只允许explicit的构造函数存在，就得写出专门负责执行转换的函数。(条款15有显示&#x2F;隐式转换函数范例) 什么样的操作符和函数对新type是合理的？这个问题答案决定你将为你的class声明哪些函数。其中哪些该是成员函数，哪些不该。(见条款23，24，46) 什么样的标准函数应该驳回？这些正是你必须声明为private的，而且不去实现。(见条款6) 谁该取用新type的成员？这个提问可以帮助你决定哪些成员为public，哪些为protected，哪些为private。它也帮助你决定哪些classes或functions应该是friends，以及将它们嵌套于另一个之内是否合理。 新type的内部约束？它对效率、异常安全性(见条款29)以及资源使用(如多任务锁和动态内存)提供何种保证？你在这些方面提供的保证将为你的class实现代码加上相应的约束条件。 你的新type有多么一般化？或许你其实并非定义一个新type，而是定义一整个types家族。果真如此你就不该定义一个新class，而是应该定义一个新的class template。 你真的需要一个新type吗？如果只是定义新的派生类以便为既有的class添加机能，那么说不定单纯定义一个或多个非成员函数或templates，更能够达到目标。 这些问题不容易回答，所以定义出高效的classes是一种挑战。然而如果能够设计出至少像C++内置类型一样好的用户自定义classes，一切汗水便都值得。 请记住 Class的设计就是type的设计。在定义一个新type之前，请确定你已经考虑过上面所有讨论主题。 20. 传引用替代传值(函数参数)函数参数都是以实际实参的副本为初值，而调用端所获得的亦是函数返回值的一个副本。这些副本是由对象的copy构造函数产出。 值传递会调用对象的copy构造函数，使用完又调用析构函数。如果比较复杂对象，还有嵌套子对象，这样值传参是昂贵费时的。通过引用传递，底层实际是传递的对象指针，这样对象的copy构造函数和析构函数都不会调用。 请记住 尽量以引用传递替换值传递。前者通常比较高效，并可避免切割问题(派生对象给基类)。 以上规则并不适用与内置类型，以及STL的迭代器和函数对象。对它们而言，值传递往往比较适当。 21. 必须返回对象时，别返回引用(函数返回值)请记住 绝不要返回指针或引用指向一个栈区对象(函数返回后销毁了)，或返回引用指向一个堆区对象(增加内存泄漏风险)，或返回指针或引用指向一个static对象而由可能同时需要多个这样的对象(条款4已经为“在单线程环境中合理返回引用指向一个static对象”提供了一份设计示例)。 22. 将成员变量声明为private请记住 切记将成员变量声明为private。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供class作者以充分的实现弹性。 protected并不比public更具封装性。从封装角度讲，其实只有两种访问权限：private(提供封装)和其它(不提供封装)。 23. 宁以non-member、non-friend替换member函数首先要知道，class里member函数越多，意味着能访问private成员变量的函数越多，封装性越低。如果要你在一个member函数和一个non-member,non-friend函数之间做抉择，而且两者都能实现相同的机能，那么，导致较大封装性的是后者，因为它并不增加能够访问class内的private成分的函数数量。 这个条款多见应用场景是工具函数的封装，头文件还可以根据功能分类出多个并加上namespace保护。头文件按功能分类成多个，使用时才可以按需只导入自己需要的。 请记住 宁可拿non-member、non-friend函数替换member函数。这样做可以增加封装性、包裹弹性和机能扩展性。 24. 若所有参数皆需类型转换，请为此采用non-member函数这点书中示例感觉有点牵强，就举例了一个operator*函数为了满足交换律，所以把operator*封装到了class之外。就得出此条款感觉前后并没有必然联系~ 相关条款46。 todo: 待后续再读解惑~ 请记住 如果你需要为某个函数的所有参数进行类型转换，那么这个函数必须是个non-member。 25. 考虑写出一个不抛异常的swap函数怎么写一个高效且不抛异常的swap？一般而言这两点是一起的，因为高效率的swap几乎总是基于对内置类型的操作，而内置类型上的操作绝不会抛出异常。 首先看看std标准库提供的swap算法，大概下面这样： 123456789namespace std &#123; template&lt;typename T&gt; void swap(T&amp; a, T&amp;b) &#123; T temp(a); a = b; b = temp; &#125;&#125; 只要类型T支持copy构造函数和copy操作符就行。它并不高效，涉及了3个对象的复制。所以针对自定义类我们常常要定制swap，看看下面示例： 12345678910111213141516171819202122class WidgetImpl &#123;public: ...private: int a, b, c; std::vector&lt;double&gt; v; ...&#125;class Widget &#123;public: Widget(const Widget&amp; rhs); Widget&amp; operator=(const Widget&amp; rhs); &#123; ... *pImpl = *(rhs.pImpl); ... &#125; ...private: WidgetImpl* pImpl; &#125; 观察Widget对象置换，其实只要置换pImpl指针就行了。 1234567891011121314151617181920// Widget内部增加swap定制接口class Widget &#123;public: ... void swap(Widget&amp; other) &#123; using std::swap; swap(pImpl, other.pImpl); &#125; ...&#125;// 同时为std::swap添加这个定制版本。STL容器也是这么干的，同时提供了public swap成员函数和std::swap定制版本。namespace std &#123; template&lt;&gt; // 声明下面Widget是定制版本 void swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b) &#123; a.swap(b); &#125;&#125; 还一种情况，如果上面Widget和WidgetImpl都是模板类而非类的话。那就不能std里添加定制swap了(编译不通过)，需要用non-member函数替代。 12345678910111213141516namespace WidgetStuff &#123; // 加命名空间是个好习惯 ... template&lt;typename T&gt; class WidgetImpl &#123;...&#125; // 模板类，内含swap成员函数 template&lt;typename T&gt; class Widget &#123;...&#125;; ... // non-member函数的swap template&lt;typename T&gt; void swap(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b) &#123; a.swap(b); &#125;&#125; 请记住 当std::swap对你的类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常。 如果你提供一个member swap，也该提供一个non-member swap用来调用前者。对于classes(而非templates),也请提供定制std::swap。 调用swap时应针对std::swap使用using声明，然后调用swap并且不带任何”命名空间修饰”。 为自定义类型进行std::swap定制是好的，但是往std中新增templates是不允许的。 五、实现26. 变量尽可能在使用时定义提前定义变量，有可能导致变量并没有使用(如中间抛异常了)，而平白多了一个构造和析构成本。 但是循环怎么办？ 123456789101112// 方式AWidget w;for (int i = 0; i &lt; n; ++i) &#123; w = xxx; ...&#125;// 方式Bfor (int i = 0; i &lt; n; ++i) &#123; Widget w = xxx; ...&#125; 做法A：1个构造 + 1个析构 + n个赋值操作 做法B：n个构造函数 + n个析构函数 打破本条款选择A的依据： （1）你知道赋值成本比“构造+析构”成本低。 （2）你正在处理代码中效率高度敏感的部分。 否则你应该使用做法B，维持变量尽可能在使用时定义的原则。 请记住 尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。 27. 尽量少做转型动作C语言风格类型转换(老式) 123(T)expression // 显示强转 T(expression) // 构造隐式转换 C++新式转换，提倡统一都用新式风格，职能分类，更安全，更清晰。 const_cast(expression) 用于将对象的常量性移除。也是唯一有此能力的C++-style转型操作符。 dynamic_cast(expression) 一般用于安全向下转型，如基类到派生类。要谨慎，可能效率低下。 static_cast(expression) 用来强制隐式转换，一般用于相关联类型转换，没有类型检测。如将int转double，派生类转基类(安全)，基类转派生类(不安全)等。 reinterpret_cast(expression) 一般用于不相干类型转换，没有限制。如int* 转int，int转函数指针等。常用于转换函数指针，即可以将一种类型的函数指针转换为另一种类型的函数指针。 转型破环了类型系统。那可能导致任何种类的麻烦，有些容易识别，有些非常隐晦。所以尽量少做转型操作。 请记住 如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_cast。如果有个设计需要转型动作，试着发展无需转型的替代设计。 如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需要将转型操作放进客户代码中。 宁可使用C++-style转型，不要使用旧式转型。前者很容易识别出来，而且也比较有着分门别类的职掌。 28. 尽量避免返回handles指向对象内部成分handers是指：对象内的子对象的引用、指针或迭代器。返回子对象的引用、指针、迭代器会降低封装性，外部能越级访问深层级的对象并修改属性。 这并不意味着你绝对不可以让成员函数返回handle。有时候你必须那么做。例如operator[]就允许你获取strings和vectors的元素。尽管如此，这样的函数毕竟是例外，不是常态。 请记住 避免返回handles(包括引用、指针、迭代器)指向对象内部。遵守这条条款可增加封装性，帮助const成员函数的行为像个const，并将发生”虚吊号码牌“的可能性降至最低。 29. 为”异常安全”而努力是值得的我们要时刻要求自己写的函数都是异常安全函数。 异常安全函数有两个条件： 不泄漏任何资源。 不允许数据败坏。 同时，异常安全函数业内分了3个级别保证，你至少满足其中之一。 基本承诺：如果抛出异常，程序内的任何事物仍然保持在有效状态下。 强烈保证：如果抛出异常，程序状态不改变。如果函数成功，就是完全成功，如果函数失败，程序会回到调用函数之前的状态。 不抛异常保证：承诺绝不抛出异常，所有操作都是作用于内置类型身上。 一般而言，我们都应该尽量做到强烈保证这个级别。而最高级别很多时候很难做到，任何使用动态内存的东西如果内存不足都有可能抛出异常。 下面是为编写异常安全函数而努力的示例： 1234567891011121314151617181920class PrettyMenu &#123;public: ... void changeBackground(std::istream&amp; imgSrc); // 改变背景图片 ...private: Mutex mutex; // 多线程环境，互斥锁 Image* bgImage; // 当前背景图片 int imageChanges; // 背景图片改变次数&#125;// 这是我们最常规思路的实现void PrettyMenu::changeBackground(std::istream&amp; imgSrc)&#123; lock(&amp;mutex); delete bgImage; ++imageChanges; bgImage = new Image(imgSrc); unlock(&amp;mutex);&#125; 上面这个常规思路的实现，如果new Image抛异常，lock资源泄漏，bgImage，imageChanges数据也招到破坏。不满足异常安全函数条件任何一个。下面我们来看怎么解决这两个问题： 123456789101112class PrettyMenu &#123; ... std::tr1::shared_ptr&lt;Image&gt; bgImage; // 智能指针 ...&#125;void PrettyMenu::changeBackground(std::istream&amp; imgSrc)&#123; Lock ml(&amp;mutex); // 封装锁，见条款14 bgImage.reset(new Image(imgSrc)); ++imageChanges;&#125; 做到这里还只能说满足基本承诺，如果Image构造函数抛异常(这里抛异常由编译器内部实现)，有可能破环外部引用的imgSrc数据源(todo:这里有点牵强~感觉做到这一步已经是强烈保证了！)。 还记得我们前面写过一个不抛异常的swap么？就可以用在这里，我们让改变背景图片的操作先在副本对象中操作，都正确操作完后，在用swap交换数据，这样就保证了即使失败了也不会影响原有数据状态。 123456789101112131415161718192021struct PMImpl &#123; std::tr1::shared_ptr&lt;Image&gt; bgImage; int imageChanges;&#125;class PrettyMenu &#123; ...private: Mutex mutex; std::tr1::shared_ptr&lt;PMImpl&gt; pImpl;&#125;void PrettyMenu::changeBackground(std::istream&amp; imgSrc)&#123; using std::swap; Lock ml(&amp;mutex); std::tr1::shared_ptr&lt;PMImpl&gt; pNew(new PMImpl(*pImpl)); // 副本对象 pNew-&gt;bgImage.reset(new Image(imgSrc)); ++pNew-&gt;imageChanges; swap(pImpl, pNew); // 交互数据&#125; 强烈保证并非时刻都显得实际，也要衡量空间、效率成本。当强烈保证不切实际时，你就必须保证提供基本保证。 请记住 异常安全函数即使发生异常也不会泄漏资源或允许任何数据结构破坏。这样的函数有3中可能的保证：基本型、强烈型、不抛异常型。 强烈保证往往能够以swap来实现出来，但强烈保证并非对所有函数都可实现或具备现实意义。 函数提供的“异常安全保证”通常最高只等于其所调用的各个函数的异常安全保证中的最低者。 30. 透彻了解inline的里里外外inline行为发生在编译期间，编译器是否要进行inline，不是取决于函数带不带inline，有时带了inline也不一定会inline(virtual函数，运行时才知道调用哪个)，没带也可能inline(实现在头文件中)。 请记住 将大多数inline限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。 不要只因为函数模板出现在头文件中定义，就将它们声明为inline。 31. 将文件间的编译依赖关系降至最低直接看示例代码： 1234567891011121314151617// 相关头文件引入#include &lt;string&gt;#include &quot;date.h&quot;#include &quot;address.h&quot;class Person &#123;public: Person(const std::string&amp; name, const Date&amp; birthday, const Address&amp; addr); std::string name() const; std::string birthDate() const; std::string address() const; ...private: std::string theName; Date theBirthDate; Address theAddress;&#125; 上面Person定义文件和其包含的文件之间形成了一种编译依赖关系。如果这些头文件中任何一个被改变，或这些头文件所依赖的其他头文件有任何改变，那么每一个包含Person class的文件就得重新编译。这样的连串编译依赖关系会对许多项目造成难以形容的灾难。 解决这个问题的本质是让类的接口与实现分离(加快编译速度)。通常有两种做法： 第一种拆分两个类，一个用于声明，一个用于实现。 12345678910111213141516171819#include &lt;string&gt;#include &lt;memory&gt;// class 只是声明这个类，没有定义信息，可以使用类的引用和指针(大小固定)，不能有定义。减少编译依赖手段。// include 则是把整个类导入，包含了定义信息，也注入了依赖相关，增加了编译时间。 class PersonImpl;class Date;class Address;class Person &#123;public: Person(const std::string&amp; name, const Date&amp; birthday, const Address&amp; addr); std::string name() const; std::string birthDate() const; std::string address() const; ...private: std::tr1::shared_ptr&lt;PersonImpl&gt; pImpl; // 指向实现类&#125; 1234567891011#include &quot;Person.h&quot;#include &quot;PersonImpl.h&quot;Person::Person(const std::string&amp; name, const Date&amp; birthday, const Address&amp; addr) : pImpl(new PersonImpl(name, birthday, addr))&#123;&#125;std::string Person::name() const&#123; return pImpl-&gt;name(); // simunps的fileManger封装就是类似这种做法&#125; 将实现分开后，即使修改了实现部分逻辑，对包含了Person接口类的其它类也没有影响，不需要重新编译。 第二种是用接口类。 这种类的目的是详细一一描述派生类的接口，因此它通常没有成员变量，也没有构造函数，只有一个virtual析构函数以及一组纯虚函数声明。 123456789101112131415161718192021// 接口定义，外部使用通过基类的create接口即可class Person &#123;public: virtual ~Person(); static std::tr1::shared_ptr&lt;Person&gt; create( const std::string&amp; name, const Date&amp; birthday, const Address&amp; addr); virtual std::string name() const = 0; virtual std::string birthDate() const = 0; virtual std::string address() const = 0; ...&#125;std::tr1::shared_ptr&lt;Person&gt; Person::create( const std::string&amp; name, const Date&amp; birthday, const Address&amp; addr)&#123; return std::tr1::shared_ptr&lt;Person&gt;(new RealPerson(name, birthday, addr));&#125; 12345678910111213141516// 实现定义class RealPerson : Person &#123;public: RealPerson(const std::string&amp; name, const Date&amp; birthday, const Address&amp; addr) : theName(name), theBirthDate(birthday), theAddress(addr) &#123;&#125; virtual ~RealPerson() &#123;&#125; std::string name() const; std::string birthDate() const; std::string address() const; ...private: std::string theName; Date theBirthDate; Address theAddress;&#125; 请记住 支持编译依赖最小化的一般构想是：依赖声明式的头文件，不要依赖定义式的头文件。(声明与定义拆两个类，外部只include声明的类头文件) 基于此构想有两种手段：接口与实现拆分两个类和接口类。 程序库头文件应该以“完全且仅有声明式的形式存在。就是include的类都是声明式的类，其真实实现在另一个类中。 六、继承与面向对象设计32. 公有继承公有继承：继承过来的基类成员访问属性不变。 保护继承：继承过来的基类中的私有成员访问属性不变，公有成员和保护成员变为保护成员。 私有继承：继承过来的基类中的私有成员属性不变，公有成员和保护成员变为私有成员。 不管是哪种继承方式，派生类中成员可以访问基类的公有成员和保护成员，无法访问私有成员。而继承方式影响的是派生类继承成员的访问属性。 请记住 public继承：适用于base classes身上的每一件事情一定也适用与derived classes身上，因为每一个derived class对象也都是一个base class对象。 33. 避免遮掩继承而来的名称派生类中函数会遮掩基类中的同名函数。从名称查找来看，像是基类中对应的同名函数没被继承过来一样。简单来说就是作用域问题，派生类覆盖基类。 12345678910111213141516171819class Base &#123;private: int x;public: virtual void mf1() = 0; virtual void mf1(int); virtual void mf2(); void mf3(); void mf3(double); ...&#125;class Derived: public Base &#123;public: virtual void mf1(); void mf3(); void mf4(); ...&#125; 12345678Derived d;int x;...d.mf1(); // 没问题，调用Derived::mf1d.mf1(x); // 报错！Derived::mf1遮掩了同名的Base::mf1d.mf2(); // 没问题，调用Base::mf2d.mf3(); // 没问题，调用Derived::mf3d.mf3(x); // 报错，Derived::mf3遮掩了Base::mf3 如果不想被派生类同名函数把基类中所有其它重载函数都遮掩了，可以使用using声明。 12345678910111213141516171819// 使用using后，上面两处报错的都可以找到Base::mf1/Base::mf3了。class Derived: public Base &#123;public: using Base::mf1; //Base class中名为mf1和mf3的所有东西， using Base::mf3; //在Derived中都可见 virtual void mf1(); void mf3(); void mf4(); ...&#125;// 转交函数，一般用于私有继承中class Derived: private Base &#123;public: virtual void mf1() // 转交函数 &#123; Base::mf1(); // 派生类函数调用基类对应函数 &#125;&#125; 如果不想要外边访问基类中任何成员，可以用私有继承实现(private)。 请记住 derived class 内的名称会遮掩base class 内的名称。在public继承下从来没有人希望如此。所以这点要特别注意(使用using)。 为了让被遮掩的名称再见天日，可使用using声明式或转交函数。 34. 区分接口继承和实现继承业内默认约定基类中的成员函数用途： 纯虚函数：derived class只想继承其声明，实现由derived class自己实现。 虚函数：derived class希望同时继承函数的接口和实现，但又希望能够覆写它们所继承的实现。 普通函数：derived class只想继承函数的接口和实现，并且不允许我自己再覆写。 依据上面约定你应该就知道成员函数属性应该怎么声明了。 请记住 接口继承和实现继承不同。在public继承之下，derived class总是继承base class的接口。 纯虚函数只具体指定接口继承。 虚函数具体指定接口继承及默认的实现继承。 普通函数具体指定接口继承以及强制性实现继承。 35. 考虑virtual函数以外的其他选择条款34刚说了，在我们希望同时继承函数的接口和实现，但又希望能够覆写它们所继承的实现时用virtual函数。 而这里是这种场景的一些其它流派主张思想。 第一种，Non-Virtual Interface(NVI)，主张virtual函数应该几乎总是private。这个较好的设计是用一个non-vitual函数去调用一个private virtual函数。这样我们就提供了在调用private virtual函数前后做一些额外操作空间。 1234567891011121314151617class GameCharacter &#123;public: // 这里inline只是为了演示示例 int healthValue() const // 普通成员函数派生类不要重新定义它，见条款36 &#123; ... // 做一些事前工作 int retVal = doHealthValue(); ... // 做一些事后工作 return retVal; &#125; ...private: virtual int doHealthValue() const // 虚函数，派生类可重写 &#123; ... &#125;&#125; 第二种，把这个虚函数提到类外边以一个普通函数存在，然后类的构造函数接收一个函数指针指向这个函数。把实现从类成员中剥离出去。— Strategy设计模式 123456789101112131415161718192021class GameCharacter;int defaultHealthCalc(const GameCharacter&amp; gc);class GameCharacter &#123;public: typedef int (*HealthCalcFunc)(const GameCharacter&amp;); // 函数指针形式 // 另一种使用tr1::function更灵活，它是一个类模板，其成员变量是一个函数指针。 // 函数指针只支持指向外部普通函数，而function对象还支持类成员函数可以(结合bind，绑定this)。 // typedef std::tr1::function&lt;int (const GameCharacter&amp;)&gt; HealthCalcFunc; explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc) : healthFunc(hcf) &#123;&#125; int healthValue() const &#123; return healthFunc(*this); &#125; ...private: HealthCalcFunc healthFunc;&#125; 这样的好处是： 同一个类之下不同的对象可以有不同的defaultHealthCalc实现。 某个类对象的defaultHealthCalc可在运行期变更。 todo: 本条款具体使用场景还是没有深刻理解其好处，待后续遇到再回顾~ 请记住 virtual 函数的替代方案包括NVI手法和Strategy设计模式的多种形式。NVI手法自身是一个特殊形式的Template Method设计模式。 将机能从成员函数移到class外部函数，带来的一个缺点是，这个非成员函数无法访问class的非公有成员。 tr1::function对象的行为就像一般函数指针。比函数指针能多接纳一些特别的函数。 36. 绝不重新定义继承而来的非虚函数好习惯约定！ 请记住 绝对不要重新定义继承而来的non-virtual函数。 37. 绝不重新定义继承而来的缺省参数值12345678910111213class Shape &#123;public: enum ShapeColor &#123;Red, Green, Blue&#125;; virtual void draw(ShapeColor color = Red) const;&#125;class Rectangle:public Shape &#123;public: virtual void draw(ShapeColor color = Green) const;&#125;Shape* pr = new Rectangle;pr-&gt;draw(); 上面代码我们都知道最后的pr-&gt;draw调用的是Rectangle里覆写后的draw，这很正常没什么问题。 诡异的是缺省的参数却是用的Red，而不是自己的Green。 导致这个结果的原因是编译器优化的手段，缺省参数是静态绑定的(运行之前确定)，而virtual函数是动态绑定的(运行时确定)。所有上面pr-&gt;draw的调用就出现接口是用的派生类的，而缺省参数用的基类的。 这种表现会给阅读代码的人带来歧义，所以： 请记住 绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定的，而virtual函数是你唯一应该覆写的东西，却是动态绑定。 38. 类的子对象区分类的继承，B继承A，我们可以说B是A，而B中包含A子对象，我们一般说B中有A，而不能说B是A了。 请记住 子对象的意义和public继承完全不同。 39. 明智而审慎地使用private继承这条目前认为没什么记录的，就是前面讲的私有继承。 40. 明智而审慎地使用多重继承多重继承，两个常见问题： C继承A和B，如果A、B里有相同的成员，那么C直接调用这些成员就会有歧义，不知道调用A的还是B的。所以正确调用要明确指明，C.A::xxxFunc(); 多层继承中，B、C继承A，D继承B和C，那么常规D中有两份A，如果不想要两份就得用virtual(虚基类里会增加一个指针大小)，虚继承。 多重继承我的建议是能避免就尽量避免。不能避免你就要清楚它带来的问题和内部实现成本消耗细节。 请记住 多重继承比单一继承复杂。它可能导致新的歧义性，以及对virtual继承的需要。 virtual继承会增加大小、速度、初始化及赋值复杂度等成本。如果virtual base classe不带任何数据，将是最具实用价值的情况。 多重继承的确有正当用途。其中一个场景涉及public继承某个Interface class和private继承某个协助实现的class的两相组合。 七、模板与泛型编程41. 了解隐式接口和编译期多态隐式接口：函数模板，类型不清楚，对我们来说接口是隐藏的。 显示接口：我们常规的头文件接口声明就是显示接口，明确了返回值，参数。 编译期多态：编译时实例化模板确定哪个重载函数被调用。 运行期多态：运行时哪一个virtual函数该被绑定。 请记住 class和template都支持接口和多态。 对class而言接口是显示的。多态则是通过virtual函数发生于运行期。 对template而言，接口是隐式的。多态则通过template实例化和函数重载解析，发生于编译器。 42. 了解typename的双重意义模版声明有两种形式： template template 这里声明模版参数时，它们的意义完全相同。 不过对于typename在模版中除了声明模版参数外还有几处特别的用处要注意！ 123456template&lt;typename C&gt;void print2nd(const C&amp; container)&#123; C::const_iterator* x; ...&#125; 这里有个新名词要了解，嵌套从属类型：即属于模版类型C下的类型，形式：C::xxx。 上面对应的就是C::const_iterator，这里是有歧义的，C::const_iterator是一个类型了还是一个变量了，如果作为类型上面就是定义一个指针x，如果作为变量就是乘x。对于这种嵌套从属类型，编译器一般默认当变量处理。如果要当类型处理就必须在其前面加关键字typename。 1typename C::const_iterator* x; // 这样就显示告诉编译器，C::const_iterator是一个自定义类型 另外对于嵌套从属类型前面加typename，有两处特例不能加。即不能出现在基类和成员初始化列表的嵌套从属类型里(除此之外都要加)。 123456789template&lt;typename T&gt;class Derived : public Base&lt;T&gt;::Nested // 不能加typename&#123; public: explicit Derived(int x) : Base&lt;T&gt;::Nested(x) // 不能加typename &#123; typename Base&lt;T&gt;::Nested temp; // 这里要加 &#125;&#125; 请记住 声明template参数时，前缀关键字class和typename可互换，意义一样。 请使用关键字typename标识嵌套从属类型，但不得在基类或成员初始化列表内使用。 43. 注意处理模版化基类内的名称123456789101112template&lt;typename T&gt;class LoggingMsgSender : public MsgSender&lt;T&gt; // 模版化基类&#123; public: ... void sendClearMsg(const MsgInfo&amp; info) &#123; ... sendClear(info); // 如果这个接口属于基类的，这里也不认识，因为基类是什么这时编译器不知道 ... &#125;&#125; 像上面的sendClear接口模版化基类里是否存在，编译器是不确定的，所以这种编译会报错。有下面3种方式解决这种问题，就是明确告诉编译器假设它存在。 通过this-&gt;sendClear(info);调用，假设sendClear在this中。 调用前加using声明using MsgSender&lt;T&gt;::sendClear;，明确告诉编译器sendClear在模版基类中。 调用时明白指明，MsgSender&lt;T&gt;::sendClear(info); 请记住 可在派生类模版内通过this-&gt;指明基类模版的成员名称(1)，或者由一个明白写出的属于基类的修饰符完成(2, 3)。 44. 将与参数无关的代码抽离templatetemplate是一个节省时间和避免代码重复的一个奇方妙法。不再需要键入20个类似的class而每一个带有15个成员函数，你只需键入一个class template，留给编译器去实例化那20个你需要的相关class和300个函数。(它们只有在被使用时才会实例化) template虽然给我们提供了方便，但是注意如果使用不当，很容易导致代码膨胀(执行文件变大)。其结果有可能源码看起来合身而整齐，但目标码却不是那么回事。在template代码中，重复是隐藏的，所以你必须训练自己去感受当template被实例化多次时可能发生的重复。 12345678910111213template&lt;typename T, std::size_t n&gt; // 这里T称为模版的类型参数，n是非类型参数class SquareMatrix &#123;public: ... void invert();&#125;// 实例化SquareMatrix&lt;double, 5&gt; sm1;sml.invert();SquareMatrix&lt;double, 10&gt; sm2;sm2.invert(); 上面这段模版封装，多次实例化，其中invert也会实例多份，虽然它们二进制实现一样。这就是隐晦的重复代码。 12345678910111213141516171819template&lt;typename T&gt;class SquareMatrixbase &#123;protected: ... void invert(std::size_t matrixSize); ...&#125;template&lt;typename T, std::size_t n&gt;class SqureMatrix : public SquareMatrixbase&lt;T&gt; &#123;private: using SquareMatrixBase&lt;T&gt;::invert; ...public: ... void invert() &#123; this-&gt;invert(n); &#125;&#125; 把重复逻辑移到基类中，所有模版类共有，这样就减少了代码膨胀了。 本条款想表达的是使用template时要注意多次实例化后可能带来的代码重复，要尽量避免这种重复代码。这就是我的理解。 TODO: 翻译的请记住条款描述得有点抽象，没深刻理解～待日后回顾重新理解！ 请记住 template生成多个class和多个函数，所以任何template代码都不该与某个造成膨胀的template参数产生相依关系。 因非类型模版参数而造成的代码膨胀，往往可消除，做法是以函数参数或class成员变量替换template参数。 因类型参数而造成的代码膨胀，往往可以降低，做法是让带有完全相同二进制实现的代码共享，如放基类中。 45. 使用成员函数模版接受所有兼容类型本条款想要表达的是我们封装的模版所有操作行为要和普通类保持一致。即隐式行为要一致。如不同类型可隐式相互转换。 123456789101112131415template&lt;typename T&gt;class SmartPrt &#123; public: SmartPrt(const SmartPrt&amp; other); //正常的copy构造函数，取消编译器自动生成 template&lt;typename U&gt; // 泛化的copy构造函数(成员函数模版)，接受不同类型对象转换 SmartPrt(const SmartPrt&lt;U&gt;&amp; other) : heldPtr(other.get()) &#123; ... &#125; T* get() const &#123;return heldPtr;&#125;; ... private: T* heldPtr;&#125; 不过注意泛化的成员函数(即成员函数模版)并不会影响编译器自动生成类默认函数规则。所以如果你要完全自定义类行为，默认产生的函数除了泛化版本，对应的正常化版本也要声明。 请记住 请使用成员函数模版生成可接受所有兼容类型的函数。 如果你声明成员函数模版用于泛化copy构造函数或赋值操作符，你还是需要声明对应正常的copy构造函数和赋值操作符函数。 46. 需要类型转换时请为模版定义非成员函数对应条款24，这里只是模版实现。规则一致，但它们写法上有所区别了。 12345678910111213141516171819template&lt;typename T&gt;class Rational &#123;public: Rational(const T&amp; numerator = 0, const T&amp; denominator = 1); const T numerator() const; const T denominator() const; ...&#125;// 需要隐式转换的接口定义为非成员函数template&lt;typename T&gt;const Rational&lt;T&gt; operator* (const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs)&#123;...&#125;;// 使用Rational&lt;int&gt; oneHalf(1, 2);Rational&lt;int&gt; result = oneHalf * 2; // 这里会编译错误，2不能隐式转换 上面只是把24条款示例改为模版实现，然而模版版本是编译不过的，因为编译器并不知道2要转换为什么。编译器推断不了模版的隐式转换。 对于模版我们只能通过friend和inline特性来实现非成员函数的定义。 123456789101112template&lt;typename T&gt;class Rational &#123;public: ... // 这里Rational是Rational&lt;T&gt;的简写形式，在类模版内部可以简写。 friend const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs) &#123; return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator()); &#125;&#125; 这样就可以编译，连接通过了。 请记住 当我们编写一个class template，而它所提供的函数要支持隐式转换时，请将这些函数定义为class template内部的friend函数。 47. 请使用traits class表现类型信息TODO: 本条款主要是标准库中大量使用(如stl迭代器)，目前还不太理解其深层含义，待日后再一次回顾理解～ 请记住 Traits class 使得类型相关信息在编译器可用。它们以template和template特化完成实现。 整合重载技术后，traits class有可能在编译期对类型执行if…else测试。(重载是编译期确定，if是运行期确定) 48. 认识template元编程47条款的示例就是使用的模版元编程技术，它是一种把运行期的代码转移到编译期完成的技术。这种技术可能永远不会成为主流，但是如果你是一个程序库开发员，那这种技术就是家常便饭了。 通过模版或重载技术，把如if这种运行期的判断转换为编译期重载函数自动匹配。 它有两个特点： 它让某些事情更容易。如果没有它，那些事情将是困难的，甚至不可能的。 由于它将工作从运行期转移到编译期。这可更早发现错误，而且更高效、较小的可执行文件、较短的运行期、较少的内存需求。不过它会使编译时间变长。 请记住 模版元编程可将工作由运行期转移到编译期，因而得以实现早期错误发现和更高的执行效率。 模版元编程可被用来生成客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码。 八、定制new和delete49. 了解new-handler的行为new-handler就是当new抛异常之前，它会先调用一个客户指定的错误处理函数。通过set_new_handler标准库函数指定。 12345678910111213// 当new无法分配足够内存时，被调用void outOfMem()&#123; std::cerr &lt;&lt; &quot;Unable to satisfy request for memory\\n&quot;; std::abort();&#125;int main()&#123; std::set_new_handler(outOfMem); int* pBigDataArray = new int[100000000L]; ...&#125; 上面异常处理是全局的，但有时候你可能需要为不同类处理不同异常。 1234567891011121314class X &#123; public: static void outOfMem(); ...&#125;class Y &#123; public: static void outOfMem(); ...&#125;X* p1 = new X; // 如果X错误，你希望调用X的错误函数Y* p2 = new Y; // 如果Y错误，你希望调用Y的错误函数 C++并不支持class的专属new-hander，但也可以通过其它形式自己实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// RAII对象，保证new_handler还原class NewHandlerHolder &#123;public: explicit NewHandlerHolder(std::new_handler nh) : handler(nh) &#123;&#125; ~NewHnadlerHolder() &#123; std::set_new_handler(handler); &#125;private: std::new_handler handler; // 阻止copiying NewHandlerHolder(const NewHandlerHolder&amp;); NewHandlerHolder&amp; operator=(const NewHandlerHolder&amp;);&#125;// 声明template&lt;typename T&gt;class NewHandlerSupport &#123;public: static std::new_handler set_new_handler(std::new_handler p) throw(); static void* operator new(std::size_t size) throw(std::bad_alloc); ...private: static std::new_handler currentHandler;&#125;// 实现template&lt;typename T&gt;std::new_handlerNewHandlerSupport&lt;T&gt;::set_new_hnadler(std::new_handler p) throw()&#123; std::new_handler oldHandler = currentHandler; currentHandler = p; return oldHandler;&#125;template&lt;typename T&gt;void* NewHandlerSupport&lt;T&gt;::operator new(std::size_t size)throw(std::bad_alloc)&#123; // new如果失败，则先会调用currentHandler，然后set_new_handler会返回上一次的handler。 // NewHandlerHolder这个RAII对象则在析构时会把上面返回的上一次new_handler设置回去。 NewHandlerHolder h(std::set_new_handler(currentHandler)); return ::operator new(size); &#125;template&lt;typename T&gt;std::new_handler NewHandlerSupport&lt;T&gt;::currentHandler = 0; 123456// 使用，只要继承封装的NewHandlerSupport&lt;T&gt;，就能够实现针对类自己的new_handler了。class Widget : public NewHandlerSupport&lt;Widget&gt; &#123; ...&#125;Widget::set_new_handler(xxxx); // xxxx是new失败执行的回调函数Widget* w = new Widget; // 如果失败，先会调用xxxx，然后会还原new_handler回调函数。 请记住 set_new_handler允许客户指定一个函数，在内存分配无法获得满足时被调用。 让new不抛异常是一个颇为局限的工具，因为它只是保证了内存分配时不抛异常，后续调用构造函数还是可能抛出异常。&#x3D;&gt; new做了两件事：1. 分配内存 2. 调用类的构造函数。 50. 了解new和delete的合理替换时机什么时候我们需要替换编译器提供的new或delete呢？下面是三个最常见的理由： 用来检测运用上的错误。如new的一段内存，delete时失败了导致内存泄漏。又或多次delete导致不确定行为。 为了提升性能。编译器默认提供的new&#x2F;delete是大众的，均衡的，不针对特定场景特定优化。如需要大量申请&#x2F;释放内存场景(碎片)，我们习知的有内存池技术。 为了收集使用上的统计数据。统计任何时刻内存分配情况等。 但是要自定义一个合适的new&#x2F;delete并非易事，如内存对齐(对齐指令执行效率最高)，可移植性、线程安全….等等细节。所以我的建议是在你确定要自定义new&#x2F;delete之前，请先确定你程序瓶颈是否真的由默认new&#x2F;delete引起，而且现在也有商业产品可以替代编译器自带的内存管理器。或者也有一些开源的产品可以使用，如Boost的Pool就是对于常见的分配大量小型对象很有帮助。 请记住 有许多理由需要写个自定义的new和delete，包括改善性能、对堆区运用错误进行调试、收集堆区使用信息。 51. 编写new和delete时需固守常规上面条款说了什么时候需要自定义new&#x2F;delete，本节则告诉你写自定义new&#x2F;delete需要遵守的一般规范。 请记住 operator new 1. 应该内含一个无限循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用new-handler。2. 它也应该有能力处理0字节申请。3. Class的专属版本则还应该处理“比正确大小更大的申请”(被继承后, new 派生对象，这时可以走编译器默认new操作)。 operator delete应该在收到null指针时不做任何事情。Class专属版本还应该处理“比正确大小更大的申请”(同上)。 52. new与delete成对出现请记住 当你写一个operator new, 请确定也写出了对应的operator delete。如果没有这样做，你的程序可能会发生隐晦而时断时续的内存泄漏。 当你声明new和delete，请确定不要无意识地(非故意)遮掩了它们的正常版本。 九、杂项讨论53. 不要轻忽编译器的警告记住后期很多无休止调试就是由于你前期没有重视编译警告引起的。尽管一般认为，写出一个在最高警告级别下也无任何警告信息的程序是理想的，然而如果你对某些警告信息有深刻理解，你倒是可以选择忽略它。不管怎样说，在你打发某个警告信息之前，请确定你了解它意图说出的精确意义。这很重要！ 请记住 严肃对待编译器发出的警告信息。努力在你的编译器的最高警告级别下争取无任何警告的荣誉。 不要过度依赖编译器的报警能力，因为不同的编译器对待事情的态度并不相同。一旦移植到另一个编译器上，你原本依赖的警告信息有可能消失。 54. 熟悉TR1在内的标准程序库TR1是C++标准程序库第一次扩充，包含14个新组件，统统都放在std::tr1命名空间下。 智能指针tr1::shared_ptr和tr1::weak_ptr。 tr1::function，可表示任何函数，是一个模板。在条款35中有使用。 tr1::bind，同样35示范中有它用法。 hash table，用来实现set, multiset, map和multi-map容器的hash版本。 正则表达式。 tr1::tuple，标准库中的pair template的新一代制品，可持有任意个数的对象(pair只能持有两个对象)。 tr1::array，是一个STL化的数组。 tr1::mem_fn，生成指向成员的指针的包装对象。 tr1::reference_wrapper, 一个让引用的行为更像对象的设施。 随机数生成工具。 数学特殊函数。 C99兼容扩充。 Type traits，见条款47。 tr1::result_of，这是一个模板，用来推导函数调用的返回类型。 这些实现一般很多实现在boost库中都有！ 请记住 C++标准程序库的主要功能由STL、iostreams、locales组成。并包含C99标准程序库。 TR1添加了智能指针、一般化函数指针、hash-based容器、正则表达式以及另外10个组件的支持。 TR1自身只是一份规范。为获得TR1提供的好处，你需要一份实现。一个好的实现来源是Boost。 55. 让自己熟悉Boost你正在寻找一个高质量、源码开放、平台独立、编译器独立的程序库吗？看看Boost吧。有兴趣加入一个由雄心勃勃充满才干的C++开发人员组成的社群，致力发展当前最高技术水平的程序库吗？看看Boost吧！想要一瞥未来的C++可能长相吗？看看Boost吧！官网地址 请记住 Boost是一个社群，也是一个网站。致力于免费、源码开放、同僚复审的C++程序库开发。Boost在C++标准化过程中扮演深具影响力的角色。 Boost提供了许多TR1组件的实现，以及其他许多程序库。 十、本书之外《Effective C++》一书覆盖我认为对于以编程为业的C++程序员最重要的一般性准则。如果你有兴趣更强化各种高效做法，我推荐你再试试另外两本书：《More Effective C++》和《Effective STL》。 《More Effective C++》覆盖了另一些编程准则，以及对于性能和异常的广泛讨论。它也描述了重要的C++编程技术如智能指针、引用计数和代理对象等等。 《Effective STL》是一本和《Effective C++》一样的准则导向书籍，专注于对STL的高效运用。","categories":[{"name":"notes","slug":"notes","permalink":"https://cxx001.gitee.io/categories/notes/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://cxx001.gitee.io/tags/c/"},{"name":"effective c++","slug":"effective-c","permalink":"https://cxx001.gitee.io/tags/effective-c/"}],"keywords":[{"name":"notes","slug":"notes","permalink":"https://cxx001.gitee.io/categories/notes/"}]},{"title":"资源列表","slug":"resources","date":"2022-12-06T08:33:14.000Z","updated":"2023-03-10T09:53:39.214Z","comments":true,"path":"2022/12/06/resources/","link":"","permalink":"https://cxx001.gitee.io/2022/12/06/resources/","excerpt":"","text":"资源列表1. 使用cmake&#x2F;makefile在win32&#x2F;linux平台编译c++工程demo模板 2. 使用vscode通过cmake&#x2F;ninja&#x2F;msvc管理、编译c++大型工程demo模板 3. Clash for Windows 使用教程 和 订阅链接购买 4. threejs第二版示例程序资源 5. threejs第三版示例程序资源 说明本blog建站在gitee，gitee个人用户不能上传超过100M文件，所以把资源列表中资源提交到github&#x2F;resources这个仓库下。点击这里! 提交大文件步骤: (安装好lfs后可一次性提交bigfile和对应的.gitattributes文件) 安装git lfs https://github.com/git-lfs/git-lfs 添加待提交大文件路径到.gitattributes文件中并提交 1234git lfs track &quot;big file path&quot;git add .gitattributesgit commit -m &quot;xxxxxx&quot;git push 提交大文件 123git add big_filegit commit -m &quot;xxxxx&quot;git push 注意通过git lfs 提交到github，免费也只有1G。","categories":[],"tags":[],"keywords":[]},{"title":"c++崩溃调试大全","slug":"c++/c++崩溃调试大全","date":"2022-11-09T17:21:30.000Z","updated":"2023-03-14T05:39:07.558Z","comments":true,"path":"2022/11/10/c++/c++崩溃调试大全/","link":"","permalink":"https://cxx001.gitee.io/2022/11/10/c++/c++%E5%B4%A9%E6%BA%83%E8%B0%83%E8%AF%95%E5%A4%A7%E5%85%A8/","excerpt":"","text":"windows上程序崩溃调试场景1 调用第三方dll崩溃调试需求 需要第三方提供对应的pdb和源码。 调试步骤 把dll 、pdb和exe程序放同级目录。 在调用dll崩溃的地方打上断点，F5运行，第一次调试需要选择dll对应源码路径。F11即可进入dll内部调试。 场景2 程序运行时崩溃调试需求 .exe文件（或.dll） 对应的.pdb文件 崩溃后的.dmp文件 对应的结点源代码（当时编译出这个exe/dll的代码，提前留个备份，比如 SVN / git 上打个tag、代码打包rar/zip的备份、代码文件夹备份……） 调试步骤1. 生成dump文件dump文件的生成常用有两种方式，一种是在程序main中封装崩溃时写dmp文件接口，一种是windbg工具。 方式一：在main入口封装写dmp文件入口，运行exe程序崩溃时会在当前目录自动产生dmp文件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 注意这里的Windows.h导入要放在DbgHelp.h前面#include &quot;Windows.h&quot; #include &quot;DbgHelp.h&quot;#include &lt;tchar.h&gt;int GenerateMiniDump(PEXCEPTION_POINTERS pExceptionPointers)&#123; // 定义函数指针 typedef BOOL(WINAPI * MiniDumpWriteDumpT)( HANDLE, DWORD, HANDLE, MINIDUMP_TYPE, PMINIDUMP_EXCEPTION_INFORMATION, PMINIDUMP_USER_STREAM_INFORMATION, PMINIDUMP_CALLBACK_INFORMATION); // 从 &quot;DbgHelp.dll&quot; 库中获取 &quot;MiniDumpWriteDump&quot; 函数 MiniDumpWriteDumpT pfnMiniDumpWriteDump = NULL; HMODULE hDbgHelp = LoadLibrary(_T(&quot;DbgHelp.dll&quot;)); if (NULL == hDbgHelp) &#123; return EXCEPTION_CONTINUE_EXECUTION; &#125; pfnMiniDumpWriteDump = (MiniDumpWriteDumpT)GetProcAddress(hDbgHelp, &quot;MiniDumpWriteDump&quot;); if (NULL == pfnMiniDumpWriteDump) &#123; FreeLibrary(hDbgHelp); return EXCEPTION_CONTINUE_EXECUTION; &#125; // 创建 dmp 文件件 TCHAR szFileName[MAX_PATH] = &#123; 0 &#125;; TCHAR* szVersion = const_cast&lt;TCHAR*&gt;(_T(&quot;DumpDemo_v1.0&quot;)); SYSTEMTIME stLocalTime; GetLocalTime(&amp;stLocalTime); wsprintf(szFileName, L&quot;%s-%04d%02d%02d-%02d%02d%02d.dmp&quot;, szVersion, stLocalTime.wYear, stLocalTime.wMonth, stLocalTime.wDay, stLocalTime.wHour, stLocalTime.wMinute, stLocalTime.wSecond); HANDLE hDumpFile = CreateFile(szFileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE | FILE_SHARE_READ, 0, CREATE_ALWAYS, 0, 0); if (INVALID_HANDLE_VALUE == hDumpFile) &#123; FreeLibrary(hDbgHelp); return EXCEPTION_CONTINUE_EXECUTION; &#125; // 写入 dmp 文件 MINIDUMP_EXCEPTION_INFORMATION expParam; expParam.ThreadId = GetCurrentThreadId(); expParam.ExceptionPointers = pExceptionPointers; expParam.ClientPointers = FALSE; pfnMiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), hDumpFile, MiniDumpWithDataSegs, (pExceptionPointers ? &amp;expParam : NULL), NULL, NULL); // 释放文件 CloseHandle(hDumpFile); FreeLibrary(hDbgHelp); return EXCEPTION_EXECUTE_HANDLER;&#125;LONG WINAPI ExceptionFilter(LPEXCEPTION_POINTERS lpExceptionInfo)&#123; // 这里做一些异常的过滤或提示 if (IsDebuggerPresent()) &#123; return EXCEPTION_CONTINUE_SEARCH; &#125; return GenerateMiniDump(lpExceptionInfo);&#125;int main()&#123; // 加入崩溃dump文件功能 SetUnhandledExceptionFilter(ExceptionFilter); // 使程序崩溃产生 Dump 文件 int* p = NULL; *p = 1;&#125; 方式二：windbg产生dmp文件 首先商店直接下载，安装windbg工具 ​ 然后通过.dump命令生成dmp文件。如果程序启动就崩溃，使用Launch executable选择exe，如果是运行期间崩溃，使用Attach to process选择对应进程。然后点击GO开始，等待崩溃后，在Command下面命令窗口输入.dump命令即可。 12345678.dump /ma C:\\Users\\Administrator\\Desktop\\ConsoleApplication1\\x64\\Debug\\test.dmp/m 生成标准的minidump, 默认/ma 带有尽量多选项的minidump，文件大/mFhutwd 带有数据段、非共享的读/写内存页和其他有用的信息的minidump，折中/f 生成全信息dump还有很多高级调试命令自行查询~~ 2. 打开dump文件调试同样常用有两种方式，一种是通过visual studio直接打开dmp文件调试，一种是使用windbg工具打开调试。 方式一：使用visual studio直接打开dmp文件。 需要dmp文件和exe、pdb在同级目录，打开dmp文件运行调试时第一次会提示指定源代码路径，然后就可以断到崩溃的地方了。 方式二：使用windbg工具打开dmp文件 打开windbg,设置源码路径和pdb文件路径 ​ 然后打开dmp文件(exe, pdb, dmp文件在同级目录) 场景3 没有源码dump调试调试需求 只需要pdb和dmp。 注意release版本，项目属性-C&#x2F;C++-常规-调试信息格式，不能选择为空，一般选择”程序数据库 (&#x2F;Zi)”。不然的话，调试的堆栈信息看不到函数的代码行数。 调试步骤 把 dmp pdb exe 3个文件放同级目录(不放同级目录就得设置符号路径，即pdb所在路径)。 选择dmp文件用vs打开，点击”使用仅限本机进行调试”运行，第一次可能会弹框选择源码路径，直接取消不用管它。 这时你能看到下边调用堆栈窗口的堆栈信息，可以看到哪个函数多少行崩溃的。 Linux上程序崩溃调试场景一 程序运行时崩溃调试步骤 ulimit -c命令查看是否开启core dump文件生成，为0则未开启。 ulimit -c unlimited 开启core dump。 1234567如果要永久生效，编辑.bashrc文件：vi ~/.bashrc添加：ulimit -c unlimited保存，退出。source ~/.bashrcsource命令使修改立即生效。 编写测试程序，gcc编译，运行崩溃后会在当前目录产生core.xxxx文件。 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int crash()&#123; char *xxx = &quot;crash!!&quot;; xxx[1] = &#x27;D&#x27;; // 写只读存储区 return 2;&#125;int foo()&#123; return crash();&#125;int main()&#123; return foo();&#125; 12#-g调试版本gcc -o test -g test.c 执行gdb test ./core.xxx调试。 设置core dump文件目录和名称 临时修改 1echo &quot;/home/corefile/core-%e-%p-%t&quot; &gt; /proc/sys/kernel/core_pattern 永久修改 1sysctl -w kernel.core_pattern=/home/corefile/%e.core.%p","categories":[{"name":"c++","slug":"c","permalink":"https://cxx001.gitee.io/categories/c/"}],"tags":[{"name":"core dump","slug":"core-dump","permalink":"https://cxx001.gitee.io/tags/core-dump/"}],"keywords":[{"name":"c++","slug":"c","permalink":"https://cxx001.gitee.io/categories/c/"}]},{"title":"c++11智能指针","slug":"c++/c++智能指针","date":"2022-11-01T09:27:50.000Z","updated":"2022-11-01T09:29:56.428Z","comments":true,"path":"2022/11/01/c++/c++智能指针/","link":"","permalink":"https://cxx001.gitee.io/2022/11/01/c++/c++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/","excerpt":"","text":"出处：C++智能指针 内存管理是C++中的一个常见的错误和bug来源。在大部分情形中，这些bug来自动态分配内存和指针的使用：当多次释放动态分配的内存时，可能会导致内存损坏或者致命的运行时错误；当忘记释放动态分配的内存时，会导致内存泄露。所以，我们需要智能指针来帮助我们管理动态分配的内存。 其来源于一个事实：栈比堆要安全的多，因为栈上的变量离开作用域后，会自动销毁并清理。智能指针结合了栈上变量的安全性和堆上变量的灵活性。 引言考虑下面一个函数： 1234567void someFunction()&#123; Resource* ptr = new Resource; // Resource是一个类或者结构 // 使用ptr处理 // ... delete ptr;&#125; 代码很简单：申请了一份动态内存，使用之后释放了它。但是我们很容易会在函数结束前释放它。也许我们记得及时释放动态申请的内存，但是仍然有一些不可抗力导致内存无法得到释放，比如函数提前终止了。考虑下面的代码： 12345678910111213141516void someFunction()&#123; Resource* ptr = new Resource; // Resource是一个类或者结构 int x; std::cout &lt;&lt; &quot;Enter an integer: &quot;; std::cin &gt;&gt; x; if (x == 0) return; // 函数终止，无法释放ptr if (x &lt; 0) throw; // 出现异常，函数终止，无法释放ptr // 使用ptr处理 // ... delete ptr;&#125; 此时，由于过早的return语句以及异常的抛出，ptr将得不到正确释放，从而出现内存泄露。归根到底，指针并没有一个内在机制来自动管理与释放。然后，你可能想到了类：类内部存储指针，然后在析构函数中销毁该指针。类可以实现资源的自动管理。其好处是，只要类局部变量（分配在栈上）超出其作用域（不论其是如何离开的），其析构函数一定会被执行，那么管理的内存也将一定得到销毁。基于这样的想法，我们实现了一个简单的智能指针类： 12345678910111213141516171819202122232425262728293031323334template&lt;typename T&gt;class Auto_ptr1&#123;public: Auto_ptr1(T* ptr = nullptr): m_ptr&#123;ptr&#125; &#123;&#125; virtual ~Auto_ptr1() &#123; delete m_ptr; &#125; T&amp; operator*() &#123; return *m_ptr; &#125; T* operator-&gt;() &#123; return m_ptr; &#125;private: T* m_ptr;&#125;;class Resource&#123;public: Resource() &#123; cout &lt;&lt; &quot;Resource acquired!&quot; &lt;&lt; endl; &#125; virtual ~Resource() &#123; cout &lt;&lt; &quot;Resource destoryed!&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; &#123; Auto_ptr1&lt;Resource&gt; res(new Resource); &#125; cin.ignore(10); return 0;&#125; 执行上面的程序，我们可以得到下面的输出： 12Resource acquired!Resource destoryed! 看来这样的想法完全可以，我们将动态申请的资源交给一个类变量来保存，由于类变量在局部作用域，其离开后将会自动调用析构函数，然后释放内存。同时，不论其是如何离开作用域的，即使出现异常，析构函数一定会被执行，内存也一定得到释放，因为该类变量是保存在栈上的。 但是上面的实现却有致命的隐患，考虑下面的代码： 12345678910int main()&#123; &#123; Auto_ptr1&lt;Resource&gt; res1(new Resource); Auto_ptr1&lt;Resource&gt; res2(res1); &#125; cin.ignore(10); return 0;&#125; 看起来没有问题，但是执行起来，程序会崩溃。因为用res1初始化res2，调用的是默认复制构造函数，执行的是浅复制。所以，res2与res1内部保存是同一块内存，当销毁变量时，同一块内存将会被多次释放，程序当然会奔溃。 所以我们需要修改这个类，最好自己实现复制构造函数，同样地要自己实现赋值运算符重载。假如我们在这两个函数中，将指针所有权从一个对象转移到另外一个对象，那么上面的问题将迎刃而解。修改的智能指针类如下： 123456789101112131415161718192021222324252627282930313233343536template&lt;typename T&gt;class Auto_ptr2&#123;public: Auto_ptr2(T* ptr = nullptr) : m_ptr&#123; ptr &#125; &#123;&#125; virtual ~Auto_ptr2() &#123; delete m_ptr; &#125; Auto_ptr2(Auto_ptr2&amp; rhs) &#123; m_ptr = rhs.m_ptr; rhs.m_ptr = nullptr; &#125; Auto_ptr2&amp; operator=(Auto_ptr2&amp; rhs) &#123; if (&amp;rhs == this) return *this; delete m_ptr; m_ptr = rhs.m_ptr; rhs.m_ptr = nullptr; return *this; &#125; T&amp; operator*() &#123; return *m_ptr; &#125; T* operator-&gt;() &#123; return m_ptr; &#125; bool isNull() const &#123; return m_ptr == nullptr; &#125;private: T* m_ptr;&#125;; 我们使用这个新类测试一下下面的代码： 123456789101112131415161718int main()&#123; Auto_ptr2&lt;Resource&gt; res1(new Resource); Auto_ptr2&lt;Resource&gt; res2; // 初始化为nullptr cout &lt;&lt; &quot;res1 is &quot; &lt;&lt; (res1.isNull() ? &quot;null\\n&quot; : &quot;not null\\n&quot;); cout &lt;&lt; &quot;res2 is &quot; &lt;&lt; (res2.isNull() ? &quot;null\\n&quot; : &quot;not null\\n&quot;); res2 = res1; // 转移指针所有权 cout &lt;&lt; &quot;Ownership transferred\\n&quot;; cout &lt;&lt; &quot;res1 is &quot; &lt;&lt; (res1.isNull() ? &quot;null\\n&quot; : &quot;not null\\n&quot;); cout &lt;&lt; &quot;res2 is &quot; &lt;&lt; (res2.isNull() ? &quot;null\\n&quot; : &quot;not null\\n&quot;); cin.ignore(10); return 0;&#125; 程序输出如下： 1234567Resource acquiredres1 is not nullres2 is nullOwnership transferredres1 is nullres2 is not nullResource destroyed 这里Auto_ptr2的实现其实类似std::auto_ptr智能指针的实现。 这种实现存在很多问题。首先如果函数中存在std::auto_ptr类型的参数，你使用一个变量进行传值时，资源所有权将会被转移，那么函数结束后资源将被销毁，然后你可能解引用这个变量，但实际上它已经是空指针了，因此程序可能崩溃。其次，std::auto_ptr内部调用的是非数组delete，那么对于动态分配的数组，std::auto_ptr无法正常工作，可能会出现内存泄露。最后，std::auto_ptr对STL不兼容，因为STL的对象在进行复制时，就是进行复制，而不是移动语义。所以实际上，在std::auto_ptr在C++11中已经被弃用了，并且在C++17中被移除标准库。 基于C++11中的右值引用与移动语义，我们可以解决上面出现的大部分问题： 12345678910111213141516171819202122232425262728293031323334353637383940template&lt;typename T&gt;class Auto_ptr3&#123;public: Auto_ptr3(T* ptr = nullptr): m_ptr&#123;ptr&#125; &#123;&#125; Auto_ptr3(const Auto_ptr3&amp; rhs) = delete; // 复制构造函数不能被外部调用,类似private Auto_ptr3(Auto_ptr3&amp;&amp; rhs) : // &amp;&amp; c++11新增的右值引用 m_ptr&#123; rhs.m_ptr &#125; &#123; rhs.m_ptr = nullptr; &#125; Auto_ptr3&amp; operator=(const Auto_ptr3&amp; rhs) = delete; // 同上声明operator=函数不能调用 Auto_ptr3&amp; operator=(Auto_ptr3&amp;&amp; rhs) &#123; if (this == &amp;rhs) &#123; return *this; &#125; std::swap(m_ptr, rhs.m_ptr); return *this; &#125; virtual ~Auto_ptr3() &#123; delete m_ptr; &#125; T&amp; operator*() &#123; return *m_ptr; &#125; T* operator-&gt;() &#123; return m_ptr; &#125; bool isNull() const &#123; return m_ptr == nullptr; &#125;private: T* m_ptr;&#125;; 可以看到Auto_ptr3实现了移动构造函数与移动赋值操作符的重载，进而实现了移动语义，但是同时禁用了复制构造函数与复制赋值运算符，因此这个类的变量仅可以通过仅可以传递右值，但是不能传递左值。但是你可以将右值传递给函数的const左值引用参数。当你传递右值时，那么明显地你已经知道要转移指针所有权了，那么当前变量将不再有效。在C++11中有类似的实现，那就是std::unique_ptr，当然更智能了。 相比std::auto_ptr，就是限制了复制函数外部访问。 C++11标准库中含有四种智能指针：std::auto_ptr（不要使用）, std::unique_ptr, std::shared_ptr和 std::weak_ptr。下面我们逐个介绍后面三个智能指针。 std::atuo_ptr不要使用，已经被弃用。 std::unique_ptrstd::unique_ptr是std::auto_ptr的替代品，其用于不能被多个实例共享的内存管理。这就是说，仅有一个实例拥有内存所有权。它的使用很简单： 12345678910111213141516171819202122232425262728293031323334353637383940class Fraction&#123;private: int m_numerator = 0; int m_denominator = 1;public: Fraction(int numerator = 0, int denominator = 1) : m_numerator(numerator), m_denominator(denominator) &#123; &#125; friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction &amp;f1) &#123; out &lt;&lt; f1.m_numerator &lt;&lt; &quot;/&quot; &lt;&lt; f1.m_denominator; return out; &#125;&#125;;int main()&#123; std::unique_ptr&lt;Fraction&gt; f1&#123; new Fraction&#123; 3, 5 &#125; &#125;; cout &lt;&lt; *f1 &lt;&lt; endl; // output: 3/5 std::unique_ptr&lt;Fraction&gt; f2; // 初始化为nullptr // f2 = f1 // 非法，不允许左值赋值 f2 = std::move(f1); // 此时f1转移到f2，f1变为nullptr // C++14 可以使用 make_unique函数 auto f3 = std::make_unique&lt;Fraction&gt;(2, 7); cout &lt;&lt; *f3 &lt;&lt; endl; // output: 2/7 // 处理数组，但是尽量不用这样做，因为你可以用std::array或者std::vector auto f4 = std::make_unique&lt;Fraction[]&gt;(4); std::cout &lt;&lt; f4[0] &lt;&lt; endl; // output: 0/1 cin.ignore(10); return 0;&#125; 可以看到，std::unique_ptr对象可以方便地管理动态内存。但是前提是该对象是建立在栈上的，千万不要使用动态分配的类对象，那么将在堆上，其行为与普通指针变得一样。 使用std::unique_ptr可能犯的两个错误是： 123456789// 千万不要用同一个资源来初始化多个std::unique_ptr对象Resource *res = new Resource;std::unique_ptr&lt;Resource&gt; res1(res);std::unique_ptr&lt;Resource&gt; res2(res);// 不要混用普通指针与智能指针Resource *res = new Resource;std::unique_ptr&lt;Resource&gt; res1(res);delete res; std::unique_ptr还有几个常用的方法： 1. release()：返回该对象所管理的指针，同时释放其所有权； 2. reset()：析构其管理的内存，同时也可以传递进来一个新的指针对象； 3. swap()：交换所管理的对象； 4. get()：返回对象所管理的指针； 5. get_deleter()：返回析构其管理指针的调用函数。 使用上面的方法还是要小心，如不要将其它对象所管理的指针传给另外一个对象的reset()方法，这会造成一块内存释放多次。更多详情可以参考这里。 std::shared_ptr要创建std::shared_ptr对象，可以使用make_shared()函数（C++11是支持的，貌似制定这个标准的人忘了make_unique()，所以在C++14追加了）。std::shared_ptr与std::unique_ptr的主要区别在于前者是使用引用计数的智能指针。引用计数的智能指针可以跟踪引用同一个真实指针对象的智能指针实例的数目。这意味着，可以有多个std::shared_ptr实例可以指向同一块动态分配的内存，当最后一个引用对象离开其作用域时，才会释放这块内存。还有一个区别是std::shared_ptr不能用于管理C语言风格的动态数组，这点要注意。下面看例子： 123456789101112131415161718int main()&#123; auto ptr1 = std::make_shared&lt;Resource&gt;(); cout &lt;&lt; ptr1.use_count() &lt;&lt; endl; // output: 1 &#123; auto ptr2 = ptr1; // 通过复制构造函数使两个对象管理同一块内存 std::shared_ptr&lt;Resource&gt; ptr3; // 初始化为空 ptr3 = ptr1; // 通过赋值，共享内存 cout &lt;&lt; ptr1.use_count() &lt;&lt; endl; // output: 3 cout &lt;&lt; ptr2.use_count() &lt;&lt; endl; // output: 3 cout &lt;&lt; ptr3.use_count() &lt;&lt; endl; // output: 3 &#125; // 此时ptr2与ptr3对象析构了 cout &lt;&lt; ptr1.use_count() &lt;&lt; endl; // output: 1 cin.ignore(10); return 0;&#125; 可以看到，通过拷贝构造函数或者赋值来共享内存，每次引用计数加1，析构时引用计数减1。 std::shared_ptr还有其他方法，更多的信息在这里。 std::weak_ptrstd::shared_ptr可以实现多个对象共享同一块内存，当最后一个对象离开其作用域时，这块内存被释放。但是仍然有可能出现内存无法被释放的情况，联想一下“死锁”现象，对于std::shared_ptr会出现类似的“循环引用”现象： 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Person&#123;public: Person(const string&amp; name): m_name&#123;name&#125; &#123; cout &lt;&lt; m_name &lt;&lt; &quot; created&quot; &lt;&lt; endl; &#125; virtual ~Person() &#123; cout &lt;&lt; m_name &lt;&lt; &quot; destoryed&quot; &lt;&lt; endl; &#125; friend bool partnerUp(std::shared_ptr&lt;Person&gt;&amp; p1, std::shared_ptr&lt;Person&gt;&amp; p2) &#123; if (!p1 || !p2) &#123; return false; &#125; p1-&gt;m_partner = p2; p2-&gt;m_partner = p1; cout &lt;&lt; p1-&gt;m_name &lt;&lt; &quot; is now partenered with &quot; &lt;&lt; p2-&gt;m_name &lt;&lt; endl; return true; &#125;private: string m_name; std::shared_ptr&lt;Person&gt; m_partner;&#125;;int main()&#123; &#123; auto p1 = std::make_shared&lt;Person&gt;(&quot;Lucy&quot;); auto p2 = std::make_shared&lt;Person&gt;(&quot;Ricky&quot;); partnerUp(p1, p2); // 互相设为伙伴 &#125; cin.ignore(10); return 0;&#125; 整个程序很简单，创建两个Person动态对象，交由智能指针管理，并且通过partnerUp()函数互相引用为自己的伙伴。 执行的结果却有问题，没有调用析构释放，内存泄漏： 123Lucy createdRicky createdLucy is now partnered with Ricky 对象没有被析构！出现内存泄露！仔细想想std::shared_ptr对象是什么时候才能被析构，就是引用计数变为0时，但是当你想析构p1时，p2内部却引用了p1，无法析构；反过来也无法析构。互相引用造成了“死锁”，最终内存泄露！这样的情形也会出现在“自锁”中(自己引用自己)： 12345678910int main()&#123; &#123; auto p1 = std::make_shared&lt;Person&gt;(&quot;Lucy&quot;); partnerUp(p1, p1); // 自己作为自己的伙伴 &#125; cin.ignore(10); return 0;&#125; 这时候std::weak_ptr应运而生。std::weak_ptr可以包含由std::shared_ptr所管理的内存的引用。但是它仅仅是旁观者，并不是所有者。那就是std::weak_ptr不拥有这块内存，当然不会计数，也不会阻止std::shared_ptr释放其内存。但是它可以通过lock()方法返回一个std::shared_ptr对象，从而访问这块内存。这样我们可以用std::weak_ptr来解决上面的“循环引用”问题： 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Person&#123;public: Person(const string&amp; name): m_name&#123;name&#125; &#123; cout &lt;&lt; m_name &lt;&lt; &quot; created&quot; &lt;&lt; endl; &#125; virtual ~Person() &#123; cout &lt;&lt; m_name &lt;&lt; &quot; destoryed&quot; &lt;&lt; endl; &#125; friend bool partnerUp(std::shared_ptr&lt;Person&gt;&amp; p1, std::shared_ptr&lt;Person&gt;&amp; p2) &#123; if (!p1 || !p2) &#123; return false; &#125; p1-&gt;m_partner = p2; // weak_ptr重载的赋值运算符中可以接收shared_ptr对象 p2-&gt;m_partner = p1; cout &lt;&lt; p1-&gt;m_name &lt;&lt; &quot; is now partenered with &quot; &lt;&lt; p2-&gt;m_name &lt;&lt; endl; return true; &#125;private: string m_name; std::weak_ptr&lt;Person&gt; m_partner;&#125;;int main()&#123; &#123; auto p1 = std::make_shared&lt;Person&gt;(&quot;Lucy&quot;); auto p2 = std::make_shared&lt;Person&gt;(&quot;Ricky&quot;); partnerUp(p1, p2); // 互相设为伙伴 &#125; cin.ignore(10); return 0;&#125; 程序正常输出: 12345Lucy createdRicky createdLucy is now partnered with RickyRicky destroyedLucy destroyed 有关std::weak_ptr更多的信息在这里。 最后说点感想：还是要深刻理解智能指针的内部机理，才能用好它，否则你可能会遇到与普通指针一样的问题。","categories":[{"name":"c++","slug":"c","permalink":"https://cxx001.gitee.io/categories/c/"}],"tags":[{"name":"智能指针","slug":"智能指针","permalink":"https://cxx001.gitee.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"}],"keywords":[{"name":"c++","slug":"c","permalink":"https://cxx001.gitee.io/categories/c/"}]},{"title":"上位机服务端离线部署步骤","slug":"project/上位机服务端离线部署文档","date":"2022-10-26T09:42:55.000Z","updated":"2022-10-26T09:49:09.353Z","comments":true,"path":"2022/10/26/project/上位机服务端离线部署文档/","link":"","permalink":"https://cxx001.gitee.io/2022/10/26/project/%E4%B8%8A%E4%BD%8D%E6%9C%BA%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3/","excerpt":"","text":"上位机服务端离线部署步骤一、环境部署1. 安装nodejs和npm 建议8.11.x以上，当前14.16.0 下载官方安装包并拷贝到离线机器上。官方下载地址：https://nodejs.org/en/download/ 解压文件：tar zvxf node-v8.9.4-linux-x64.tar.xz 放到相应目录例如: mv node-v8.9.4-linux-x64 /opt/ 建立软链接使npm和node命令到系统命令 sudo In -s /opt/node-v8.9.4-linux-x64/bin/node /usr/local/bin/node sudo In -s /opt/node-v8.9.4-linux-x64/bin/npm /usr/local/bin/npm 检查是否安装成功 node-v npm-v 2. 安装python 版本 2.5 &lt; version &lt; 3.0，当前2.7.18 3. 安装pomelo 解压文件：tar zvxf pomelo.tar.gz 放到相应目录例如: mv pomelo /usr/local/lib/node_modules/ 建立软链接: ln -s usr/local/lib/node_modules/pomelo/bin/pomelo /usr/local/bin/pomelo 3. 安装mongodb 在mongodb官网下载所需安装包，比如 mongodb-linux-x86_64-rhel70-3.6.23.tgz, 官方下载地址: https://www.mongodb.com/try/download/community 执行 tar zxvf mongodb-linux-x86_64-rhel70-3.6.23.tgz 命令解压软件包 执行 mv mongodb-linux-x86_64-rhel70-3.6.23 /usr/local/mongodb 命令把解压的目录移动到local目录下并改名为mongodb 进入mongodb目录依次执行 mkdir data、mkdir data/db、mkdir conf、mkdir logs 命令创建数据目录、配置目录、日志目录 进入conf配置目录，执行vi mongodb.conf命令编写配置，在文件中写入： 123456789101112131415161718192021222324# 日志文件位置 logpath=/usr/local/mongodb/logs/mongodb.log# 以追加方式写入日志logappend=true# 是否以守护进程方式运行fork = true# 默认27017#port = 27017# 数据库文件位置dbpath=/usr/local/mongodb/data/db# 启用定期记录CPU利用率和 I/O 等待#cpu = true# 是否以安全认证方式运行，默认是不认证的非安全方式# noauth = trueauth = true # 默认127.0.0.1为只允许本地连接；0.0.0.0为不限制；多个指定服务器用，连接 bind_ip=0.0.0.0 进入bin目录启动 12345#进入bin目录cd /usr/local/mongodb/bin/#启动./mongod -f /usr/local/mongodb/conf/mongodb.conf 输入以下内容表示成功 123about to fork child process, waiting until server is ready for connections.forked process: 29755child process started successfully, parent exiting 创建用户密码和添加登录用户123456789# 创建用户密码1. ./mongo ,连接mongodb2. use admin3. db.createUser(&#123;&quot;user&quot;:&quot;root&quot;,&quot;pwd&quot;:&quot;123456&quot;,&quot;roles&quot;:[&#123;role:&quot;root&quot;,db:&quot;admin&quot;&#125;]&#125;)4. db.auth(&#x27;root&#x27;,&#x27;123456&#x27;)# 添加登录用户1. use mongo_fly2. db.avatars.insert(&#123;&quot;openid&quot;: &quot;admin&quot;, &quot;account&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;123456&quot;&#125;) 二、启动上位机服务 解压源码：unzip simufly_server.zip 放到相应目录例如: mv simufly_server /home/ 启动, cd /home/simufly_server/ 执行 pomelo start [-e &lt;development, production&gt;] [-D -d -t -i] 支持的所有命令帮助查看 pomelo --help","categories":[{"name":"project","slug":"project","permalink":"https://cxx001.gitee.io/categories/project/"}],"tags":[{"name":"pomelo环境部署","slug":"pomelo环境部署","permalink":"https://cxx001.gitee.io/tags/pomelo%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"}],"keywords":[{"name":"project","slug":"project","permalink":"https://cxx001.gitee.io/categories/project/"}]},{"title":"windows11安装Linux子系统","slug":"tools/windows11安装Linux子系统","date":"2022-10-24T08:02:33.000Z","updated":"2023-03-14T05:38:09.921Z","comments":true,"path":"2022/10/24/tools/windows11安装Linux子系统/","link":"","permalink":"https://cxx001.gitee.io/2022/10/24/tools/windows11%E5%AE%89%E8%A3%85Linux%E5%AD%90%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"Windows在10之后自带了虚拟机子系统功能，可以和本地磁盘共享，默认挂载到&#x2F;mnt&#x2F;目录下面。比起传统的VM方便多了。下面是搭建流程： 一 开启子系统服务控制面板 -&gt; 程序 -&gt; 程序与功能 -&gt; 启动或关闭Windows功能，勾选下面截图3个选项，确定后重启。 二 Microsoft Store下载Linux系统 安装完，用自带连接就可以直接访问了。 如果启动提示WSL2错误:根据报错说明提示需要安装： 适用于 x64 计算机的 WSL2 Linux 内核更新包 点此下载 三 其它辅助设置 自带连接工具默认登录的是非root用户，第一次切换root要设置root密码。 sudo passwd root 自带连接工具默认登录的是非root用户，改默认root用户。 查找ubuntu*.exe在哪里，一般是c盘下(find /mnt/c/ -name ubuntu*.exe)。 /mnt/c/Users/KL179/AppData/Local/Microsoft/WindowsApps/ubuntu2004.exe 进入ubuntu2004.exe目录，执行下面命令修改默认登录用户 ./ubuntu2004.exe config --default-user root 第三方ssh连接工具访问Linux子系统 安装ssh服务、设置sshkey、启动服务 123456789# 安装sshsudo apt-get install openssh-server openssh-client# 第一次可能需要设置sshkey这样启动ssh-keygen -A/etc/init.d/ssh start# 启动ssh服务service ssh start 允许root用户登录和允许密码访问 打开ssh配置文件: vi /etc/ssh/sshd_config 添加: PermitRootLogin yes 允许root用户登录 PasswordAuthentication yes 设置为yes允许密码验证","categories":[{"name":"tools","slug":"tools","permalink":"https://cxx001.gitee.io/categories/tools/"}],"tags":[{"name":"windows安装linux子系统","slug":"windows安装linux子系统","permalink":"https://cxx001.gitee.io/tags/windows%E5%AE%89%E8%A3%85linux%E5%AD%90%E7%B3%BB%E7%BB%9F/"}],"keywords":[{"name":"tools","slug":"tools","permalink":"https://cxx001.gitee.io/categories/tools/"}]},{"title":"Docker基础使用","slug":"tools/docker使用","date":"2022-10-21T08:45:10.000Z","updated":"2022-10-26T09:42:27.827Z","comments":true,"path":"2022/10/21/tools/docker使用/","link":"","permalink":"https://cxx001.gitee.io/2022/10/21/tools/docker%E4%BD%BF%E7%94%A8/","excerpt":"","text":"概要Docker由下面3个东西组成: 镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。 容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。 安装参考：CentOS Docker 安装 | 菜鸟教程 (runoob.com) 我的测试环境是CentOS7，使用的官方安装脚本自动安装。 1curl -sSL https://get.daocloud.io/docker | sh 安装完成后，重启docker服务。 123456docker version # 查看版本systemctl status docker # 查看docker状态systemctl start docker # 启动dockersystemctl restart docker # 重启docker# 或者使用service docker start 常用命令123456789101112131415161718192021222324252627282930313233docker # 查看docker所有命令docker xxx --help # 查看xxx命令详情docker search 镜像名 # 从远程仓库搜索镜像docker pull 镜像名 # 从远程仓库拉镜像到本地docker image list/docker images # 查看已有镜像列表docker tag 镜像ID 新镜像名[:新tag名] # 镜像改名/改tag名docker rmi [-f] 镜像ID # 删除镜像(要先删除镜像引起的容器)# 创建容器 docker run [-it -d -p -name -v] 常用可选参数docker run -it 镜像名 [shell命令] # 前台运行创建新容器exit # 退出容器docker run -d 镜像名 [shell命令] # 后台运行创建新容器docker run -d -p 5000:5000 镜像名 命令 # 将容器内5000端口映射到宿主机的5000端口，多个就依次加-p xx:xx就行了。默认是绑定tcp端口，如果udp直接加后面就行了:-p 5000:5000/udp。这个设置是直接改容器的本地配置(inspect)，永久生效,后面直接docker start就行了。docker run -v 宿主机目录:容器目录 镜像名 命令 # -v将宿主机目录挂载到容器某个目录下，这样宿主机就可以与容器共享目录了。docker ps # 查看正在运行的容器docker ps -a #查看所有的容器docker losgs [-f] 容器ID # 查看运行的容器内标准输出日志, -f类似tail -f一样docker stop 容器ID # 停止容器docker start 容器ID # 启动一个已经停止的容器docker restart 容器ID # 重启容器docker rm [-f] 容器ID # 删除容器docker container prune # 删除所有处于终止状态的容器docker attach 容器ID #进入一个启动的后台容器，这种方式进入exit退出会导致容器也会退出docker exec -it 容器ID /bin/bash #同上，这种方式进入exit退出，容器不会退出，推荐这种docker export 容器ID &gt; xxx.tar # 导出容器docker import xxx.tar 镜像名 # 把xxx.tar(也可以是URL)以镜像形式导入docker cp 宿主机文件路径 容器ID:容器目标路径 # 宿主机文件传到容器docker cp 容器ID:容器文件路径 宿主机目标路径 # 容器文件传到宿主机 通过容器提交镜像以及推送镜像流程我们本地一个容器如果想要提交到docker仓库供别人pull下载使用。操作流程如下(和git使用类似)： 注册docker仓库账号 地址: Docker Hub 本地提交容器为镜像 1docker commit -m &quot;描述日志&quot; -a &quot;作者&quot; 容器ID 新镜像名 登录docker hub 1docker login 推送到远程仓库 1docker push 镜像名[:tag名] 别人使用 1docker pull 镜像名[:tag名]","categories":[{"name":"tools","slug":"tools","permalink":"https://cxx001.gitee.io/categories/tools/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://cxx001.gitee.io/tags/docker/"}],"keywords":[{"name":"tools","slug":"tools","permalink":"https://cxx001.gitee.io/categories/tools/"}]},{"title":"C++动态库使用","slug":"c++/C++动态库使用","date":"2022-09-14T08:54:33.000Z","updated":"2023-03-14T05:37:19.098Z","comments":true,"path":"2022/09/14/c++/C++动态库使用/","link":"","permalink":"https://cxx001.gitee.io/2022/09/14/c++/C++%E5%8A%A8%E6%80%81%E5%BA%93%E4%BD%BF%E7%94%A8/","excerpt":"","text":"前言Windows与Linux下面的动态链接库区别1. 文件后缀不同Linux动态库的后缀是 .so 文件，而window则是 .dll 文件。 2. 文件格式不同（a）Linux下是ELF格式，即Executable and Linkable Format 在ELF之下，共享库中所有的全局函数和变量在默认情况下都可以被其它模块使用，即ELF默认导出所有的全局符号。 （b）Windows下面是PE格式的文件，即Portable Executable Format DLL文件和EXE文件实际上是一个概念，都是PE格式的二进制文件。DLL需要显示地“告诉”编译器需要导出某个符号，否则编译器默认所有的符号都不导出。 3. 动态链接库的文件个数不一样Linux的动态链接库就只有一个 .so 文件，还有与之对应的头文件，而在Windows下面的动态库有两个文件， 一个是引入库（.LIB）文件， 一个是动态库（.DLL）文件， 需要的头文件（.h）文件 （1）LIB引入库文件包含被DLL导出的函数名称和位置，对于导入库而言，其实际的执行代码位于动态库中，导入库只包含了地址符号表等，确保程序找到对应函数的一些基本地址信息。 （2）DLL文件包含实际的函数和数据，应用程序使用LIB文件链接到所需要使用的DLL文件，库中的函数和数据并不复制到可执行文件中，因此在应用程序的可执行文件中，存放的不是被调用的函数代码，而是DLL中所要调用的函数的内存地址，这样当一个或多个应用程序运行是再把程序代码和被调用的函数代码链接起来，从而节省了内存资源。 Windows上动态库使用1. 创建动态库windows上创建动态库一般有两种方式： 使用_declspec 显示声明要导出的对象 。 和平时写程序一样，源码中不需要显示声明导出，导出放在def文件中声明。 首先介绍下使用_declspec 来创建动态库的过程： （1）新建一个空项目或者是使用DLL模板都可以。(个人习惯用干净的空项目) （2）修改项目属性输出类型改为dll。 （3）正常添加.h与.cpp文件，.h中要导出的函数前添加_declspec(dllexport)声明即可。 （4）重新生成，在工程目录即可生成对应的dllapi.lib与dllapi.dll文件。 再来看看使用def文件声明导出的方式： （1）添加def文件 （2）def文件中声明要导出的函数 123LIBRARYEXPORTS add （3）重新生成，和第一种显示声明方式一样生成了.lib和.dll2个文件。 2. 使用动态库windows上使用动态库一般有2种方式： 隐式调用(IDE上设置) 显示调用 下面分别介绍下详细的使用流程 隐式调用使用流程 （1）创建控制台测试工程，并建立一个依赖目录，将动态库的.h和.lib放在这个目录下，同时将.dll放在exe可执行程序同级目录。 （2）配置 项目-&gt;属性-&gt;配置属性-&gt;VC++ 目录-&gt; 在“包含目录”里添加头文件DllAPI.h所在的目录 。 项目-&gt;属性-&gt;配置属性-&gt;VC++ 目录-&gt; 在“库目录”里添加依赖文件dllapi.lib所在的目录。 项目-&gt;属性-&gt;配置属性-&gt;链接器-&gt;输入-&gt; 在“附加依赖项”里添加dllapi.lib 。 你也可以在代码中添加一行设置库的链接，#pragma comment(lib, &quot;dllapi.lib&quot;)，这样就不需要2、3配置了。 （3）测试运行 显示调用使用流程 只需要将.dll放在exe可执行程序同级目录就行了，IDE不需要额外设置。注意要使用这个dll中的方法其创建时必须要_declspec 显示导出，使用时只要这个dll文件就行了，.h和.lib不需要。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &quot;Windows.h&quot; // 动态库加载、释放等接口头文件#include &quot;tchar.h&quot; // _T头文件，设置支持Unicode编码typedef int(*Dllfun)(int, int); // 待使用接口的函数指针int main()&#123; // 加载动态库 HINSTANCE hdll = LoadLibrary(_T(&quot;dllapi.dll&quot;)); if (hdll == NULL) &#123; return -1; &#125; // 获取动态库中导出的函数指针 Dllfun funName = (Dllfun)GetProcAddress(hdll, &quot;add&quot;); if (funName == NULL) &#123; FreeLibrary(hdll); return -1; &#125; // 调用、释放 int ret = funName(1, 2); FreeLibrary(hdll); std::cout &lt;&lt; &quot;result = &quot; &lt;&lt; ret &lt;&lt; &quot;\\n&quot;;&#125; Linux上动态库使用Linux上创建动态库很简单，不需要显示声明导出的函数，它会默认导出。在Linux上使用动态库也有2种方式： 编译器链接 库文件加载 1. 编译器链接使用流程 编写源文件。 将一个或几个源文件编译链接，生成libxxx.so。 通过 -L&lt;path&gt; -lxxx 的gcc选项链接生成的libxxx.so。 把libxxx.so放入链接库的标准路径，或指定 LD_LIBRARY_PATH，才能运行链接了libxxx.so的程序。 (1) 编写源文件，生成so共享库 建立一个源文件：add.c，代码如下： 1234int add(int x, int y)&#123; return x + y;&#125; 编译生成libadd.so： 1gcc -fPIC -shared -o libadd.so add.c 我们会得到libadd.so。 实际上上述过程分为编译和链接两步， -fPIC是编译选项，PIC是 Position Independent Code 的缩写，表示要生成位置无关的代码，这是动态库需要的特性； -shared是链接选项，告诉gcc生成动态库而不是可执行文件。 上述的一行命令等同于： 12gcc -c -fPIC add.cgcc -shared -o libadd.so add.o （2）为动态库编写接口文件 12#pragma onceint add(int x, int y); （3）测试，链接动态库生成可执行文件 建立一个使用add函数的test.c，代码如下： 123456789#include &lt;stdio.h&gt;#include &quot;add.h&quot;int main(int argc, char *argv[])&#123; int ret = add(1, 2); printf(&quot;ret= %d.\\n&quot;, ret); return 0;&#125; gcc test.c -L. -ladd 生成a.out，其中-ladd表示要链接libadd.so。-L.表示搜索要链接的库文件时包含当前路径。 注意，如果同一目录下同时存在同名的动态库和静态库，比如 libadd.so 和 libadd.a 都在当前路径下，则gcc会优先链接动态库。 （4） 运行 运行 ./a.out 会得到以下的错误提示。 1./a.out: error while loading shared libraries: libadd.so: cannot open shared object file: No such file or directory 找不到libadd.so，原来Linux是通过 /etc/ld.so.cache 文件搜寻要链接的动态库的。而 /etc/ld.so.cache 是 ldconfig 程序读取 /etc/ld.so.conf 文件生成的。（注意， /etc/ld.so.conf 中并不必包含 /lib 和 /usr/lib，ldconfig程序会自动搜索这两个目录） 如果我们把 libadd.so 所在的路径添加到 /etc/ld.so.conf 中，再以root权限运行 ldconfig 程序，更新 /etc/ld.so.cache ，a.out运行时，就可以找到 libadd.so。 因此我们可以为a.out指定 LD_LIBRARY_PATH运行，如下： 1LD_LIBRARY_PATH=. ./a.out 程序就能正常运行了。LD_LIBRARY_PATH=. 是告诉 a.out，先在当前路径寻找链接的动态库。 或者修改LD_LIBRARY_PATH环境变量，指定为当前目录也可以，如下： 1export LD_LIBRARY_PATH=$&#123;pwd&#125;:$&#123;LD_LIBRARY_PATH&#125; 然后直接执行./a.out也可以运行了。 2. 库文件加载使用流程像window调用库文件一样，在linux下，也有相应的API因为加载库文件而存在。它们主要是以下几个函数： 使用源码如下： 1234567891011121314151617181920212223242526272829303132333435363738// test2.c#include &lt;stdio.h&gt;#include &lt;dlfcn.h&gt; int main(int argc, char *argv[])&#123; void * libm_handle = NULL; int (*add_method)(int, int); char *errorInfo; int result; // dlopen 函数还会自动解析共享库中的依赖项。这样，如果您打开了一个依赖于其他共享库的对象，它就会自动加载它们。 // 函数返回一个句柄，该句柄用于后续的 API 调用 libm_handle = dlopen(&quot;libadd.so&quot;, RTLD_LAZY ); // 如果返回 NULL 句柄，表示无法找到对象文件，过程结束。否则的话，将会得到对象的一个句柄，可以进一步询问对象 if (!libm_handle)&#123; // 如果返回 NULL 句柄,通过dlerror方法可以取得无法访问对象的原因 printf(&quot;Open Error:%s.\\n&quot;,dlerror()); return 0; &#125; // 使用 dlsym 函数，尝试解析新打开的对象文件中的符号。您将会得到一个有效的指向该符号的指针，或者是得到一个 NULL 并返回一个错误 add_method = dlsym(libm_handle,&quot;add&quot;); errorInfo = dlerror();// 它会在发生前面的错误时返回一个字符串，同时将其从内存中清空； 在没有错误发生时返回 NULL if (errorInfo != NULL)&#123; printf(&quot;Dlsym Error:%s.\\n&quot;,errorInfo); return 0; &#125; // 执行“cosf”方法 result = (*add_method)(1, 2); printf(&quot;result = %d.\\n&quot;,result); // 调用 ELF 对象中的目标函数后，通过调用 dlclose 来关闭对它的访问 dlclose(libm_handle); return 0;&#125; 编译，运行./test2可以看到结果为3。 1gcc test2.c -o test2 -ldl","categories":[{"name":"c++","slug":"c","permalink":"https://cxx001.gitee.io/categories/c/"}],"tags":[{"name":"动态库使用","slug":"动态库使用","permalink":"https://cxx001.gitee.io/tags/%E5%8A%A8%E6%80%81%E5%BA%93%E4%BD%BF%E7%94%A8/"}],"keywords":[{"name":"c++","slug":"c","permalink":"https://cxx001.gitee.io/categories/c/"}]},{"title":"CMake入门","slug":"notes/cmake入门","date":"2022-09-08T09:35:55.000Z","updated":"2023-03-14T05:36:00.599Z","comments":true,"path":"2022/09/08/notes/cmake入门/","link":"","permalink":"https://cxx001.gitee.io/2022/09/08/notes/cmake%E5%85%A5%E9%97%A8/","excerpt":"","text":"概叙你或许听过好几种 Make 工具，例如 GNU Make ，QT 的 qmake ，微软的 MS nmake，BSD Make（pmake），Makepp，等等。这些 Make 工具遵循着不同的规范和标准，所执行的 Makefile 格式也千差万别。这样就带来了一个严峻的问题：如果软件想跨平台，必须要保证能够在不同平台编译。而如果使用上面的 Make 工具，就得为每一种标准写一次 Makefile ，这将是一件让人抓狂的工作。 CMake就是针对上面问题所设计的工具：它首先允许开发者编写一种平台无关的 CMakeLists.txt 文件来定制整个编译流程，然后再根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件，如 Unix 的 Makefile 或 Windows 的 Visual Studio 工程。 入门示例这是一个对输入的数求平方根的示例，用编译配置开关控制是调用系统数学函数(sqrt)还是自定义函数(mysqrt)。主要包含设置版本号、配置头文件(可选项开关)、添加静态库的使用。 1. 目录结构 build目录自己创建，内容执行cmake命令自动生成 MathFunctions目录是自定义的数学函数库(会编译成静态库) tuorial.cpp主入口文件 2. cmake命令使用 配置环境 测试环境：windows11 需要安装CMake 和 MinGW，MinGW 就是 GCC 的 Windows 移植版本。 构建命令，只需要第一次执行一次 cmake -G”MinGW Makefiles” .. 构建系统是需要指定 CMakeLists.txt 所在路径，此时在 build 目录下，所以用 .. 表示 CMakeLists.txt 在上一级目录。 Windows 下，CMake 默认使用微软的 MSVC 作为编译器，我想使用 MinGW 编译器，可以通过 -G 参数来进行指定，只有第一次构建项目时需要指定。 执行完会在 build 目录下会生成 Makefile 文件。 编译、链接可执行程序 cmake –build . –build 指定编译生成的文件存放目录，其中就包括可执行文件，. 表示存放到当前目录 执行完会在 build 目录下生成一个 Tutorial.exe 可执行文件 设置配置的可选项开关 cmake -DUSE_MYMATH&#x3D;OFF .. 把USE_MYMATH设置为OFF，此设置将存储在缓存中，以便用户不需要在每次构建项目时设置该值。 3. 源码所有细节看详细注释 123456789101112131415161718192021222324252627282930313233343536373839404142// tutorial.cpp#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &quot;TutorialConfig.h&quot;// USE_MYMATH 编译开关#ifdef USE_MYMATH #include &quot;MathFunctions.h&quot;#endif/* argv[0] Tutorial.exe argv[1] 外部输入第一个参数*/int main(int argc, char* argv[])&#123; if (argc &lt; 2) &#123; // 版本号使用示例 // Tutorial_VERSION_MAJOR 主版本号 Tutorial_VERSION_MINOR 次版本号 std::cout &lt;&lt; argv[0] &lt;&lt; &quot; Version &quot; &lt;&lt; Tutorial_VERSION_MAJOR &lt;&lt; &quot;.&quot; &lt;&lt; Tutorial_VERSION_MINOR &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; number&quot; &lt;&lt; std::endl; return 2; &#125; // 将输入字符串转换为double const double inputValue = std::stod(argv[1]); // 编译开关控制调用系统sqrt还是自己的mysqrt #ifdef USE_MYMATH const double outputValue = mysqrt(inputValue); #else const double outputValue = sqrt(inputValue); #endif std::cout &lt;&lt; &quot;The square root of &quot; &lt;&lt; inputValue &lt;&lt; &quot; is &quot; &lt;&lt; outputValue &lt;&lt; std::endl; return 0;&#125; 123// MathFunctions.hdouble mysqrt(double value); 12345678// mysqrt.cpp#include &quot;MathFunctions.h&quot;double mysqrt(double value)&#123; return 1.0;&#125; 12345678// TutorialConfig.h.in// 编译配置文件, 执行cmake --build . 会自定生成对应.h头文件#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@ // 主版本号#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@ // 次版本号#cmakedefine USE_MYMATH // 使用使用自定义库的编译开关 12345678910111213141516171819202122232425262728293031323334353637383940# 外层主CMakeLists.txt# 指定cmake最低版本cmake_minimum_required(VERSION 3.15)# 设置项目名称和版本号# 这里项目名称会自定映射到 PROJECT_NAME 宏上# 这里的版本号会自定映射到 Tutorial_VERSION_MAJOR=1 Tutorial_VERSION_MINOR=0 这两个宏上(TutorialConfig.h.in中配置)project(Tutorial VERSION 1.0)# 配置头文件将版本号传递给源代码, TutorialConfig.h.in编译时自定生成TutorialConfig.h需要这么配置下生效configure_file(TutorialConfig.h.in TutorialConfig.h)# 指定c++标准(现在新版本的cmake默认是c++14标准, 如果没有使用更高特性这里可以不用指定)set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# 可选项配置, USE_MYMATH定义在TutorialConfig.h.in配置中, 默认缺省值是 ON# 修改：build目录下 cmake -DUSE_MYMATH=OFF ..option(USE_MYMATH &quot;Use tutorial provided math implementation&quot; ON)# 如果开了则使用自定义库，否则用系统的if(USE_MYMATH) add_subdirectory(MathFunctions) # 指定库所在目录, 此目录应包含库的CMakeLists.txt和代码文件 list(APPEND EXTRA_LIBS MathFunctions) # APPEND表示将元素MathFunctions追加到列表EXTRA_LIBS中endif()# 设置变量SRC_LIST的值tutorial.cpp(值可以多个空格隔开)SET(SRC_LIST tutorial.cpp)# 用来生成可执行文件，需要指定生成可执行文件的名称和相关源文件add_executable($&#123;PROJECT_NAME&#125; $&#123;SRC_LIST&#125;) # 将库文件(静态库)添加到可执行文件中target_link_libraries($&#123;PROJECT_NAME&#125; PUBLIC $&#123;EXTRA_LIBS&#125;) # 指定目标头文件目录target_include_directories($&#123;PROJECT_NAME&#125; PUBLIC $&#123;PROJECT_BINARY_DIR&#125; ) 123456789# 自定义库CMakeLists.txt# 用来生成库文件(静态库)，需要指定生成库文件的名称和相关源文件add_library(MathFunctions mysqrt.cpp)# 指定目标头文件目录target_include_directories(MathFunctions INTERFACE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125; ) 4. 执行结果 进阶1. 安装程序 程序写完，我们可以通过命令把可执行文件和头文件安装到指定目录。 接着上面工程，在两个CMakeLists.txt文件最后添加安装设置。 123# 指定安装路径install (TARGETS Tutorial DESTINATION bin)install (FILES &quot;$&#123;PROJECT_BINARY_DIR&#125;/TutorialConfig.h&quot; DESTINATION include) 123# 指定 MathFunctions 库的安装路径install (TARGETS MathFunctions DESTINATION bin) # 目标文件install (FILES MathFunctions.h DESTINATION include) # 头文件 执行命令： cmake --install . --prefix &quot;C:\\Users\\KL179\\Desktop\\cmake_test\\install&quot; 2. 测试程序 在根目录的CMakeLists.txt(主)最后添加测试用例。 测试用例主要就是两个接口： add_test 添加用例 set_tests_properties 验证结果 1234567891011121314151617181920212223# 启用测试enable_testing()# 测试程序是否成功运行add_test (test_run Tutorial 8)# 测试帮助信息是否可以正常提示add_test (test_usage Tutorial)# PASS_REGULAR_EXPRESSION 用来测试上面输出是否包含后面跟着的字符串（即测试结果验证）set_tests_properties (test_usage PROPERTIES PASS_REGULAR_EXPRESSION &quot;Usage: .* base exponent&quot;)# 定义一个宏，用来简化测试工作macro (do_test arg1 result)add_test (test_$&#123;arg1&#125; Tutorial $&#123;arg1&#125;)set_tests_properties (test_$&#123;arg1&#125; PROPERTIES PASS_REGULAR_EXPRESSION $&#123;result&#125;)endmacro (do_test)# 使用该宏进行一系列的数据测试do_test (1 &quot;is 1&quot;)do_test (4 &quot;is 2&quot;)do_test (16 &quot;is 4&quot;) 运行ctest执行(或者make test) 3. 支持gdb配置让 CMake 支持 gdb 的设置也很容易，只需要指定 Debug 模式下开启 -g 选项： 12345set(CMAKE_BUILD_TYPE &quot;Debug&quot;)set(CMAKE_CXX_FLAGS_DEBUG &quot;$ENV&#123;CXXFLAGS&#125; -O0 -Wall -g -ggdb&quot;)set(CMAKE_CXX_FLAGS_RELEASE &quot;$ENV&#123;CXXFLAGS&#125; -O3 -Wall&quot;) 4. 检测接口是否存在一般是使用平台相关特性时，下面我们以检测系统是否有sqrt函数为例。 首先在主CMakeLists.txt文件里configure_file之前添加下面设置： 123# 检查系统是否支持 sqrt 函数include ($&#123;CMAKE_ROOT&#125;/Modules/CheckFunctionExists.cmake)check_function_exists (sqrt HAVE_SQRT) 接下来修改 TutorialConfig.h.in 文件，预定义HAVE_SQRT宏变量。 1#cmakedefine HAVE_SQRT 最后就可以使用HAVE_SQRT来判断了。 1234567// tutorial.cpp里添加测试示例#ifdef HAVE_SQRT std::cout &lt;&lt; &quot;check_function_exists sqrt is exist&quot; &lt;&lt; std::endl;#else std::cout &lt;&lt; &quot;check_function_exists sqrt is noexist&quot; &lt;&lt; std::endl;#endif 5. 生成安装包生成各种平台上的安装包，包括二进制安装包和源码安装包。为了完成这个任务，我们需要用到 CPack ，它同样也是由 CMake 提供的一个工具，专门用于打包。 注意：CPack打包依赖 NSIS 需要安装。 只需要在顶层的 CMakeLists.txt 文件尾部添加下面几行： 12345678910# 导入 InstallRequiredSystemLibraries 模块，以便之后导入 CPack 模块include (InstallRequiredSystemLibraries)# 设置一些 CPack 相关变量，包括版权信息和版本信息set (CPACK_RESOURCE_FILE_LICENSE &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/License.txt&quot;)set (CPACK_PACKAGE_VERSION_MAJOR &quot;$&#123;Tutorial_VERSION_MAJOR&#125;&quot;)set (CPACK_PACKAGE_VERSION_MINOR &quot;$&#123;Tutorial_VERSION_MINOR&#125;&quot;)# 导入 CPack 模块include (CPack) 然后命令行执行cmake打包命令就可以打包了。 生成二进制安装包： 1cpack -C CPackConfig.cmake 生成源码安装包 1cpack -C CPackSourceConfig.cmake 生成的安装包，双击安装执行截图如下：","categories":[{"name":"notes","slug":"notes","permalink":"https://cxx001.gitee.io/categories/notes/"}],"tags":[{"name":"cmake","slug":"cmake","permalink":"https://cxx001.gitee.io/tags/cmake/"},{"name":"CMakeLists.txt","slug":"CMakeLists-txt","permalink":"https://cxx001.gitee.io/tags/CMakeLists-txt/"}],"keywords":[{"name":"notes","slug":"notes","permalink":"https://cxx001.gitee.io/categories/notes/"}]},{"title":"提炼《跟我一起写 Makefile》教程","slug":"notes/makefile","date":"2022-09-06T02:13:30.000Z","updated":"2022-09-07T00:27:39.153Z","comments":true,"path":"2022/09/06/notes/makefile/","link":"","permalink":"https://cxx001.gitee.io/2022/09/06/notes/makefile/","excerpt":"","text":"提炼《跟我一起写 Makefile》教程 支持原创，请移步原作者博客： http://blog.csdn.net/haoel/article/details/2886 一、makefile总序1. makefile文件格式1234target...:prerequisites... command ... ... target: 是一个目标文件，也可以是执行文件。还可以是一个标签。（Label） prerequisites: 依赖项，就是要生成那个target所需要的文件或是目标。 command: make需要执行的命令。（任意的Shell命令，必须以Tab开头） 2. makefile执行原理 prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。 3. 定义、使用变量12345objects = main.o kbd.o command.o display.o \\ # 定义变量(类似c/c++中的宏) insert.o search.o files.o utils.oedit : $(objects) # 变量使用 4. make自动推导只要make看到一个[.o]文件(目标文件是.o文件)，它就会自动的把[.c]文件加在依赖关系中，所以依赖中可以省略。 123456789101112131415161718objects = main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.o edit : $(objects) cc -o edit $(objects) main.o : defs.h kbd.o : defs.h command.h command.o : defs.h command.h display.o : defs.h buffer.h insert.o : defs.h buffer.h search.o : defs.h buffer.h files.o : defs.h buffer.h command.h utils.o : defs.h .PHONY : clean clean : rm edit $(objects) 不用自动推导前写法： 12345678910111213141516171819202122objects = main.o kbd.o command.o display.o \\ insert.osearch.o files.o utils.o edit : $(objects) cc -o edit $(objects) main.o : main.c defs.h cc -c main.c kbd.o : kbd.c defs.h command.h cc -c kbd.c command.o : command.c defs.h command.h cc -c command.c display.o : display.c defs.h buffer.h cc -c display.c insert.o : insert.c defs.h buffer.h cc -c insert.c search.o : search.c defs.h buffer.h cc -c search.c files.o : files.c defs.h buffer.h command.h cc -c files.c utils.o : utils.c defs.h cc -c utils.c clean : rm edit $(objects) 注意在Makefile中的命令，必须要以[Tab]键开始。 5. 引用其它的makefile文件在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。 在include前面可以有一些空字符，但是绝不能是[Tab]键开始。include和可以用一个或多个空格隔开。举个例子，你有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了e.mk和f.mk，那么，下面的语句： include foo.make *.mk $(bar) 等价于： include foo.make a.mk b.mk c.mk e.mk f.mk make命令开始时，会查找include所指出的其它Makefile，并把其内容安置在当前的位置。就好像C&#x2F;C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找： 121.如果make执行时，有“-I”或“--include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。2.如果目录/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。 如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如： 1-include&lt;filename&gt; 其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。 6. make的工作方式GNU的make工作时的执行步骤入下：（想来其它的make也是类似） 读入所有的Makefile。(全局环境变量MAKEFILES的值做include操作) 读入被include的其它Makefile。 初始化文件中的变量。 推导隐晦规则，并分析所有规则。 为所有的目标文件创建依赖关系链。 根据依赖关系，决定哪些目标要重新生成。 执行生成命令。 1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。 二、makefile常用规则1. 指定依赖文件搜索目录首先在当前目录查找，找不到会去VPATH变量中找。例如： 1VPATH = src:../headers 上面的的定义指定两个目录，“src”和“..&#x2F;headers”，make会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方） 另外还一个小写vpath，这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。 它的使用方法有三种： vpath &lt; pattern&gt; &lt; directories&gt; 为符合模式&lt; pattern&gt;的文件指定搜索目录。 vpath &lt; pattern&gt; 清除符合模式&lt; pattern&gt;的文件的搜索目录。 vpath 清除所有已被设置好了的文件搜索目录。 vapth使用方法中的&lt; pattern&gt;需要包含“%”字符。“%”的意思是匹配零或若干字符，例如，“%.h”表示所有以“.h”结尾的文件。&lt; pattern&gt;指定了要搜索的文件集，而&lt; directories&gt;则指定了的文件集的搜索的目录。例如： vpath %.h ../headers 该语句表示，要求make在“..&#x2F;headers”目录下搜索所有以“.h”结尾的文件。（如果某文件在当前目录没有找到的话） 2. 伪目标前面示例中最后的clean就是一个伪目标，“伪目标”并不是一个文件，只是一个标签，不会像其它目标一样生成“clean”这个文件。所以伪目标下的命令执行，我们只有通过显示地指明这个“目标”才能让其生效(make clean)。 当然，“伪目标”的取名不能和其它目标文件重名，不然其就失去了“伪目标”的意义了。为了避免这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。 伪目标常规使用 123.PHONY: clean clean: rm *.o temp 如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中 12345678910111213all : prog1 prog2 prog3 .PHONY : all prog1 : prog1.o utils.o cc -o prog1 prog1.o utils.o prog2 : prog2.o cc -o prog2 prog2.o prog3 : prog3.o sort.o utils.o cc -o prog3 prog3.o sort.o utils.o 我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于伪目标的特性是，总是被执行的，所以其依赖的那三个目标就总是不如“all”这个目标新。所以，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。“.PHONY : all”声明了“all”这个目标为“伪目标”。 从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖 123456789.PHONY: cleanall cleanobj cleandiff cleanall : cleanobj cleandiff rm program cleanobj : rm *.o cleandiff : rm *.diff 3. 静态模式静态模式可以更加容易地定义多目标的规则(如果我们的“%.o”有几百个)，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法： 12345&lt;targets...&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt; &lt;commands&gt;... targets 定义了一系列的目标文件，可以有通配符。是目标的一个集合。 target-parrtern 是指明了targets的模式，也就是的目标集模式。 prereq-parrterns 是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。 示例一: 123456789101112objects = foo.o bar.o all: $(objects) $(objects): %.o: %.c $(CC) -c $(CFLAGS) $&lt; -o $@ 我们的目标从$object中获取，“%.o”表明要所有以“.o”结尾的目标，也就是“foo.o bar.o”，也就是变量$object集合的模式，而依赖模式“%.c”则取模式“%.o”的“%”，也就是“foo bar”，并为其加下“.c”的后缀，于是，我们的依赖目标就是“foo.c bar.c”。而命令中的“$&lt;”和“$@”则是自动化变量，“$&lt;”表示所有的依赖目标集（也就是“foo.c bar.c”），“$@”表示目标集（也就是foo.o bar.o”）。上面的规则展开后等价于下面的规则：foo.o : foo.c $(CC) -c $(CFLAGS) foo.c -o foo.obar.o : bar.c $(CC) -c $(CFLAGS) bar.c -o bar.o 4. 自动生成依赖性在 Makefile 中， 我们的依赖关系可能会需要包含一系列的头文件，如果是一个比较大型的工程，你必需清楚哪些 C 文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改 Makefile，这是一个很没有维护性的工作。 为了避免这种繁重而又容易出错的事情，我们可以使用C&#x2F;C++编译的一个功能。大多数的C&#x2F;C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。 注意如果你使用GNU的C/C++编译器，你得用“-MM”参数，不然，“-M”参数会把一些标准库的头文件也包含进来。 自动生成源文件(xxx.c)对应的依赖关系文件(xxx.d)的makefile 12345%.d: %.c @set -e; rm -f $@; #删除.d文件 $(CC) -MM $(CPPFLAGS) $&lt; &gt; $@.; #生成.d随机编号的临时文件 sed &#x27;s,\\.o[ :]*,\\1.o $@ : ,g&#x27; &lt; $@.&gt; $@; #替换随机编号 rm -f $@. ##删除临时文件 在主makefile中引入上面自动生成的依赖关系makefile（也就是.d文件） 1234sources = foo.c bar.cinclude $(sources:.c=.d)# $(sources:.c=.d)中的“.c=.d”的意思是做一个替换，把变量$(sources)所有[.c]的字串都替换成[.d] 5. 定义命令包把多条命令定义成一个变量，后续可以使用这个变量来替代一组命令。语法以define开始，以endef结束，如： 12345678define run-yacc #命令包的名字yacc $(firstword $^) #运行Yacc程序mv y.tab.c $@ #文件改名endef#命令包使用foo.c : foo.y $(run-yacc) #和使用变量一样 三、使用变量1. 定义变量几种形式123456789101112131415161718# 1. 简单的使用“=”号，在“=”左侧是变量，右侧是变量的值，不关心变量定义顺序。foo = $(bar)bar = $(ugh)ugh = Huh?all:echo $(foo)# 2. 必须从上到下定义，关心变量定义顺序使用&quot;:=&quot;y := $(x) bar #y的值是“bar”，而不是“foo bar”了x := foo# 3. “?=” 表示如果变量被定义过则什么也不做，没有定义过则定义FOO ?= bar# 4. “+=” 给变量追加值objects = main.o foo.o bar.o utils.oobjects += another.o 四、条件判断下面的例子，判断$(CC)变量是否“gcc”，如果是的话，则使用GNU函数编译目标。 123456789libs_for_gcc = -lgnunormal_libs =foo: $(objects)ifeq ($(CC),gcc)$(CC) -o foo $(objects) $(libs_for_gcc)else$(CC) -o foo $(objects) $(normal_libs)endif 条件表达式的语法为： 1234567891011&lt;conditional-directive&gt;&lt;text-if-true&gt;endif或者&lt;conditional-directive&gt;&lt;text-if-true&gt;else&lt;text-if-false&gt;endif 五、使用函数1. 函数使用$(&lt;function&gt; &lt;arguments&gt; ) 这里，就是函数名，make支持的函数不多。是函数的参数，参数间以逗号“,”分隔，而函数名和参数之间以“空格”分隔。函数调用以“$”开头，以圆括号或花括号把函数名和参数括起。这和使用变量很类似。 示例：把空格替换为逗号 12345comma:= ,empty:=space:= $(empty) $(empty)foo:= a b cbar:= $(subst $(space),$(comma),$(foo)) #bar的值变为a,b,c 2. 字符串处理函数12345$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt; )名称：字符串替换函数——subst。功能：把字串&lt;text&gt;中的&lt;from&gt;字符串替换成&lt;to&gt;。返回：函数返回被替换过后的字符串。 12345$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt; )名称：模式字符串替换函数——patsubst。功能：查找&lt;text&gt;中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式&lt;pattern&gt;，如果匹配的话，则以&lt;replacement&gt;替换。这里，&lt;pattern&gt;可以包括通配符“%”，表示任意长度的字串。如果&lt;replacement&gt;中也包含“%”，那么，&lt;replacement&gt;中的这个“%”将是&lt;pattern&gt;中的那个“%”所代表的字串。（可以用“\\”来转义，以“\\%”来表示真实含义的“%”字符）返回：函数返回被替换过后的字符串。 12345$(strip &lt;string&gt; )名称：去空格函数——strip。功能：去掉&lt;string&gt;字串中开头和结尾的空字符。返回：返回被去掉空格的字符串值。 12345$(findstring &lt;find&gt;,&lt;in&gt; )名称：查找字符串函数——findstring。功能：在字串&lt;in&gt;中查找&lt;find&gt;字串。返回：如果找到，那么返回&lt;find&gt;，否则返回空字符串。 123456$(filter &lt;pattern...&gt;,&lt;text&gt; )名称：过滤函数——filter。功能：以&lt;pattern&gt;模式过滤&lt;text&gt;字符串中的单词，保留符合模式&lt;pattern&gt;的单词。可以有多个模式。返回：返回符合模式&lt;pattern&gt;的字串。 123456$(filter-out &lt;pattern...&gt;,&lt;text&gt; )名称：反过滤函数——filter-out。功能：以&lt;pattern&gt;模式过滤&lt;text&gt;字符串中的单词，去除符合模式&lt;pattern&gt;的单词。可以有多个模式。返回：返回不符合模式&lt;pattern&gt;的字串。 12345$(sort &lt;list&gt; )名称：排序函数——sort。功能：给字符串&lt;list&gt;中的单词排序（升序）。返回：返回排序后的字符串。 1234567$(word &lt;n&gt;,&lt;text&gt; )名称：取单词函数——word。功能：取字符串&lt;text&gt;中第&lt;n&gt;个单词。（从一开始）返回：返回字符串&lt;text&gt;中第&lt;n&gt;个单词。如果&lt;n&gt;比&lt;text&gt;中的单词数要大，那么返回空字符串。示例：$(word 2, foo bar baz)返回值是“bar”。 12345678$(wordlist &lt;s&gt;,&lt;e&gt;,&lt;text&gt; )名称：取单词串函数——wordlist。功能：从字符串&lt;text&gt;中取从&lt;s&gt;开始到&lt;e&gt;的单词串。&lt;s&gt;和&lt;e&gt;是一个数字。返回：返回字符串&lt;text&gt;中从&lt;s&gt;到&lt;e&gt;的单词字串。如果&lt;s&gt;比&lt;text&gt;中的单词数要大，那么返回空字符串。如果&lt;e&gt;大于&lt;text&gt;的单词数，那么返回从&lt;s&gt;开始，到&lt;text&gt;结束的单词串。示例： $(wordlist 2, 3, foo bar baz)返回值是“bar baz”。 12345678$(words &lt;text&gt; )名称：单词个数统计函数——words。功能：统计&lt;text&gt;中字符串中的单词个数。返回：返回&lt;text&gt;中的单词数。示例：$(words, foo bar baz)返回值是“3”。备注：如果我们要取&lt;text&gt;中最后的一个单词，我们可以这样：$(word $(words &lt;text&gt; ),&lt;text&gt; )。 1234567$(firstword &lt;text&gt; )名称：首单词函数——firstword。功能：取字符串&lt;text&gt;中的第一个单词。返回：返回字符串&lt;text&gt;的第一个单词。示例：$(firstword foo bar)返回值是“foo”。备注：这个函数可以用word函数来实现：$(word 1,&lt;text&gt; )。 3. 文件名操作函数1234567$(dir &lt;names...&gt; )名称：取目录函数——dir。功能：从文件名序列&lt;names&gt;中取出目录部分。目录部分是指最后一个反斜杠（“/”）之前的部分。如果没有反斜杠，那么返回“./”。返回：返回文件名序列&lt;names&gt;的目录部分。示例： $(dir src/foo.c hacks)返回值是“src/ ./”。 1234567$(notdir &lt;names...&gt; )名称：取文件函数——notdir。功能：从文件名序列&lt;names&gt;中取出非目录部分。非目录部分是指最后一个反斜杠（“/”）之后的部分。返回：返回文件名序列&lt;names&gt;的非目录部分。示例： $(notdir src/foo.c hacks)返回值是“foo.c hacks”。 123456$(suffix &lt;names...&gt; )名称：取后缀函数——suffix。功能：从文件名序列&lt;names&gt;中取出各个文件名的后缀。返回：返回文件名序列&lt;names&gt;的后缀序列，如果文件没有后缀，则返回空字串。示例：$(suffix src/foo.c src-1.0/bar.c hacks)返回值是“.c .c”。 1234567$(basename &lt;names...&gt; )名称：取前缀函数——basename。功能：从文件名序列&lt;names&gt;中取出各个文件名的前缀部分。返回：返回文件名序列&lt;names&gt;的前缀序列，如果文件没有前缀，则返回空字串。示例：$(basename src/foo.c src-1.0/bar.c hacks)返回值是“src/foo src-1.0/bar hacks”。 123456$(addsuffix &lt;suffix&gt;,&lt;names...&gt; )名称：加后缀函数——addsuffix。功能：把后缀&lt;suffix&gt;加到&lt;names&gt;中的每个单词后面。返回：返回加过后缀的文件名序列。示例：$(addsuffix .c,foo bar)返回值是“foo.c bar.c”。 123456$(addprefix &lt;prefix&gt;,&lt;names...&gt; )名称：加前缀函数——addprefix。功能：把前缀&lt;prefix&gt;加到&lt;names&gt;中的每个单词后面。返回：返回加过前缀的文件名序列。示例：$(addprefix src/,foo bar)返回值是“src/foo src/bar”。 12345678$(join &lt;list1&gt;,&lt;list2&gt; )名称：连接函数——join。功能：把&lt;list2&gt;中的单词对应地加到&lt;list1&gt;的单词后面。如果&lt;list1&gt;的单词个数要比&lt;list2&gt;的多，那么，&lt;list1&gt;中的多出来的单词将保持原样。如果&lt;list2&gt;的单词个数要比&lt;list1&gt;多，那么，&lt;list2&gt;多出来的单词将被复制到&lt;list2&gt;中。返回：返回连接过后的字符串。示例：$(join aaa bbb , 111 222 333)返回值是“aaa111 bbb222 333”。 4. foreach函数格式：$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt; ) 这个函数的意思是，把参数中的单词逐一取出放到参数所指定的变量中，然后再执行所包含的表达式。每一次会返回一个字符串，循环过程中，所返回的每个字符串会以空格分隔，最后当整个循环结束时，所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。 示例： 12345names := a b c dfiles := $(foreach n,$(names),$(n).o)上面的例子中，$(name)中的单词会被挨个取出，并存到变量“n”中，“$(n).o”每次根据“$(n)”计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以，$(files)的值是“a.o b.o c.o d.o”。 5. if 函数格式： 12345$(if &lt;condition&gt;,&lt;then-part&gt; )或是$(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt; ) 结合参考：《四、条件判断》 6. call 函数call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以用call函数来向这个表达式传递参数。其语法是： $(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;...) 当 make执行这个函数时，参数中的变量，如$(1)，$(2)，$(3)等，会被参数，，依次取代。而的返回值就是 call函数的返回值。例如： reverse &#x3D; $(1) $(2) foo &#x3D; $(call reverse,a,b) 那么，foo的值就是“a b”。当然，参数的次序是可以自定义的，不一定是顺序的，如： reverse &#x3D; $(2) $(1)foo &#x3D; $(call reverse,a,b) 此时的foo的值就是“b a”。 7. origin 函数格式：$(origin &lt;variable&gt; ) 告诉你你的这个变量是哪里来的。 其所有返回值情况： “undefined” 从来没有定义过 “default” 是一个默认的定义，比如“CC”这个变量 “environment” 是一个环境变量，并且当Makefile被执行时，“-e”参数没有被打开 “file” 这个变量被定义在Makefile中 “command line” 这个变量是被命令行定义的 “override” 是被override指示符重新定义的 “automatic” 是一个命令运行中的自动化变量 8. shell 函数shell函数把执行操作系统命令后的输出作为函数返回。 注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。 9. 控制make的函数调试信息，类似error、warning日志输出。 $(error &lt;text ...&gt; ) $(warning &lt;text ...&gt; ) 六、如何使用make命令一般来说，最简单的就是直接在命令行下输入make命令，make命令会找当前目录的makefile来执行，一切都是自动的。但也有时你也许只想让 make重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。本章节就是讲述如何使用make命令的。 1. make的返回值123450 —— 表示成功执行。1 —— 如果make运行时出现任何错误，其返回1。2 —— 如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。 2. 指定makefile前面我们说过，GNU make找寻默认的Makefile的规则是在当前目录下依次找三个文件——“GNUmakefile”、“makefile”和“Makefile”。其按顺序找这三个文件，一旦找到，就开始读取这个文件并执行。 我们也可以给make命令指定一个特殊名字的Makefile。要达到这个功能，我们要使用make的“-f”或是“–file”参数（“– makefile”参数也行）。例如，我们有个makefile的名字是“hchen.mk”，那么，我们可以这样来让make来执行这个文件： make –f hchen.mk 3. 指定目标一般来说，make的最终目标是makefile中的第一个目标，而其它目标一般是由这个目标连带出来的。这是make的默认行为。当然，一般来说，你的 makefile中的第一个目标是由许多个目标组成，你可以指示make，让其完成你所指定的目标。要达到这一目的很简单，在make命令后直接跟目标的名字就可以完成。 常见的指定目标操作： 12345678“all” 这个伪目标是所有目标的目标，其功能一般是编译所有的目标。“clean” 这个伪目标功能是删除所有被make创建的文件。“install” 这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。“print” 这个伪目标的功能是例出改变过的源文件。“tar” 这个伪目标功能是把源程序打包备份。也就是一个tar文件。“dist” 这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。“TAGS” 这个伪目标功能是更新所有的目标，以备完整地重编译使用。“check”和“test” 这两个伪目标一般用来测试makefile的流程。 4. 检查规则1234567891011121314151617181920212223242526有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用make命令的下述参数：“-n”“--just-print”“--dry-run”“--recon”不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试makefile很有用处。“-t”“--touch”这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。“-q”“--question”这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。“-W &lt;file&gt;”“--what-if=&lt;file&gt;”“--assume-new=&lt;file&gt;”“--new-file=&lt;file&gt;”这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件所发生的规则命令。 5. make 参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159下面列举了所有GNU make 3.80版的参数定义。其它版本和产商的make大同小异，不过其它产商的make的具体参数还是请参考各自的产品文档。“-b”“-m”这两个参数的作用是忽略和其它版本make的兼容性。“-B”“--always-make”认为所有的目标都需要更新（重编译）。“-C &lt;dir&gt;”“--directory=&lt;dir&gt;”指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make –C ~hchen/test –C prog”等价于“make –C ~hchen/test/prog”。“—debug[=&lt;options&gt;]”输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是&lt;options&gt;的取值：a —— 也就是all，输出所有的调试信息。（会非常的多）b —— 也就是basic，只输出简单的调试信息。即输出不需要重编译的目标。v —— 也就是verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等。i —— 也就是implicit，输出所以的隐含规则。j —— 也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等。m —— 也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息。“-d”相当于“--debug=a”。“-e”“--environment-overrides”指明环境变量的值覆盖makefile中定义的变量的值。“-f=&lt;file&gt;”“--file=&lt;file&gt;”“--makefile=&lt;file&gt;”指定需要执行的makefile。“-h”“--help”显示帮助信息。“-i”“--ignore-errors”在执行时忽略所有的错误。“-I &lt;dir&gt;”“--include-dir=&lt;dir&gt;”指定一个被包含makefile的搜索目标。可以使用多个“-I”参数来指定多个目录。“-j [&lt;jobsnum&gt;]”“--jobs[=&lt;jobsnum&gt;]”指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的“-j”参数，那么仅最后一个“-j”才是有效的。（注意这个参数在MS-DOS中是无用的）“-k”“--keep-going”出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。“-l &lt;load&gt;”“--load-average[=&lt;load]”“—max-load[=&lt;load&gt;]”指定make运行命令的负载。“-n”“--just-print”“--dry-run”“--recon”仅输出执行过程中的命令序列，但并不执行。“-o &lt;file&gt;”“--old-file=&lt;file&gt;”“--assume-old=&lt;file&gt;”不重新生成的指定的&lt;file&gt;，即使这个目标的依赖文件新于它。“-p”“--print-data-base”输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出一堆信息。如果你只是想输出信息而不想执行 makefile，你可以使用“make -qp”命令。如果你想查看执行makefile前的预设变量和规则，你可以使用“make –p –f /dev/null”。这个参数输出的信息会包含着你的makefile文件的文件名和行号，所以，用这个参数来调试你的makefile会是很有用的，特别是当你的环境变量很复杂的时候。“-q”“--question”不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说明有错误发生。“-r”“--no-builtin-rules”禁止make使用任何隐含规则。“-R”“--no-builtin-variabes”禁止make使用任何作用于变量上的隐含规则。“-s”“--silent”“--quiet”在命令运行时不输出命令的输出。“-S”“--no-keep-going”“--stop”取消“-k”选项的作用。因为有些时候，make的选项是从环境变量“MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效。“-t”“--touch”相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。“-v”“--version”输出make程序的版本、版权等关于make的信息。“-w”“--print-directory”输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用。“--no-print-directory”禁止“-w”选项。“-W &lt;file&gt;”“--what-if=&lt;file&gt;”“--new-file=&lt;file&gt;”“--assume-file=&lt;file&gt;”假定目标&lt;file&gt;需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“-n”那么就像运行UNIX的“touch”命令一样，使得&lt;file&gt;的修改时间为当前时间。“--warn-undefined-variables”只要make发现有未定义的变量，那么就输出警告信息。 七、隐含规则1. 使用隐含规则12foo : foo.o bar.occ –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS) 我们可以注意到，这个Makefile中并没有写下如何生成foo.o和bar.o这两目标的规则和命令。因为make的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成命令。 2. 常用的隐含规则1、编译C程序的隐含规则。“.o”的目标的依赖目标会自动推导为“.c”，并且其生成命令是“$(CC) –c $(CPPFLAGS) $(CFLAGS)” 2、编译C++程序的隐含规则。“.o” 的目标的依赖目标会自动推导为“.cc”或是“.C”，并且其生成命令是“$(CXX) –c $(CPPFLAGS) $(CFLAGS)”。（建议使用“.cc”作为C++源文件的后缀，而不是“.C”） 3、编译Pascal程序的隐含规则。“.o”的目标的依赖目标会自动推导为“.p”，并且其生成命令是“$(PC) –c $(PFLAGS)”。 4、编译Fortran&#x2F;Ratfor程序的隐含规则。“.o”的目标的依赖目标会自动推导为“.r”或“.F”或“.f”，并且其生成命令是:“.f” “$(FC) –c $(FFLAGS)”“.F” “$(FC) –c $(FFLAGS) $(CPPFLAGS)”“.f” “$(FC) –c $(FFLAGS) $(RFLAGS)” 5、预处理Fortran&#x2F;Ratfor程序的隐含规则。“.f”的目标的依赖目标会自动推导为“.r”或“.F”。这个规则只是转换Ratfor或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：“.F” “$(FC) –F $(CPPFLAGS) $(FFLAGS)”“.r” “$(FC) –F $(FFLAGS) $(RFLAGS)” 6、编译Modula-2程序的隐含规则。“.sym” 的目标的依赖目标会自动推导为“.def”，并且其生成命令是：“$(M2C) $(M2FLAGS) $(DEFFLAGS)”。“&lt;n.o&gt;” 的目标的依赖目标会自动推导为“.mod”，并且其生成命令是：“$(M2C) $(M2FLAGS) $(MODFLAGS)”。 7、汇编和汇编预处理的隐含规则。“.o” 的目标的依赖目标会自动推导为“.s”，默认使用编译品“as”，并且其生成命令是：“$(AS) $(ASFLAGS)”。“.s” 的目标的依赖目标会自动推导为“.S”，默认使用C预编译器“cpp”，并且其生成命令是：“$(AS) $(ASFLAGS)”。 8、链接Object文件的隐含规则。“” 目标依赖于“.o”，通过运行C的编译器来运行链接程序生成（一般是“ld”），其生成命令是：“$(CC) $(LDFLAGS) .o $(LOADLIBES) $(LDLIBS)”。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则： x : y.o z.o 并且“x.c”、“y.c”和“z.c”都存在时，隐含规则将执行如下命令： cc -c x.c -o x.occ -c y.c -o y.occ -c z.c -o z.occ x.o y.o z.o -o xrm -f x.orm -f y.orm -f z.o 如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。 9、Yacc C程序时的隐含规则。 “.c”的依赖文件被自动推导为“n.y”（Yacc生成的文件），其生成命令是：“$(YACC) $(YFALGS)”。（“Yacc”是一个语法分析器，关于其细节请查看相关资料） 10、Lex C程序时的隐含规则。“.c”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX) $(LFALGS)”。（关于“Lex”的细节请查看相关资料） 11、Lex Ratfor程序时的隐含规则。“.r”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX) $(LFALGS)”。 12、从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。“.ln” （lint生成的文件）的依赖文件被自动推导为“n.c”，其生成命令是：“$(LINT) $(LINTFALGS) $(CPPFLAGS) -i”。对于“.y”和“.l”也是同样的规则。 3. 隐含规则使用的变量在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的“-R”或“–no– builtin-variables”参数来取消你所定义的变量对隐含规则的作用。 我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如“CC”；一种是参数相的关，如“CFLAGS”。下面是所有隐含规则中会用到的变量： 1、关于命令的变量。 AR 函数库打包程序。默认命令是“ar”。AS汇编语言编译程序。默认命令是“as”。CCC语言编译程序。默认命令是“cc”。CXXC++语言编译程序。默认命令是“g++”。CO从 RCS文件中扩展文件程序。默认命令是“co”。CPPC程序的预处理器（输出是标准输出设备）。默认命令是“$(CC) –E”。FCFortran 和 Ratfor 的编译器和预处理程序。默认命令是“f77”。GET从SCCS文件中扩展文件的程序。默认命令是“get”。LEXLex方法分析器程序（针对于C或Ratfor）。默认命令是“lex”。PCPascal语言编译程序。默认命令是“pc”。YACCYacc文法分析器（针对于C程序）。默认命令是“yacc”。YACCRYacc文法分析器（针对于Ratfor程序）。默认命令是“yacc –r”。MAKEINFO转换Texinfo源文件（.texi）到Info文件程序。默认命令是“makeinfo”。TEX从TeX源文件创建TeX DVI文件的程序。默认命令是“tex”。TEXI2DVI从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是“texi2dvi”。WEAVE转换Web到TeX的程序。默认命令是“weave”。CWEAVE转换C Web 到 TeX的程序。默认命令是“cweave”。TANGLE转换Web到Pascal语言的程序。默认命令是“tangle”。CTANGLE转换C Web 到 C。默认命令是“ctangle”。RM删除文件命令。默认命令是“rm –f”。 2、关于命令参数的变量 下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。 ARFLAGS函数库打包程序AR命令的参数。默认值是“rv”。ASFLAGS汇编语言编译器参数。（当明显地调用“.s”或“.S”文件时）。CFLAGSC语言编译器参数。CXXFLAGSC++语言编译器参数。COFLAGSRCS命令参数。CPPFLAGSC预处理器参数。（ C 和 Fortran 编译器也会用到）。FFLAGSFortran语言编译器参数。GFLAGSSCCS “get”程序参数。LDFLAGS链接器参数。（如：“ld”）LFLAGSLex文法分析器参数。PFLAGSPascal语言编译器参数。RFLAGSRatfor 程序的Fortran 编译器参数。YFLAGSYacc文法分析器参数。 八、make其它使用对于上述所有的make的细节，我们不但可以利用make这个工具来编译我们的程序，还可以利用make来完成其它的工作，因为规则中的命令可以是任何Shell之下的命令，所以，在Unix下，你不一定只是使用程序语言的编译器，你还可以在Makefile中书写其它的命令，如：tar、awk、mail、sed、cvs、compress、ls、rm、yacc、rpm、 ftp……等等，等等，来完成诸如**”程序打包”、”程序备份”、”制作程序安装包”、”提交代码”、”使用程序模板”、”合并文件”**等等五花八门的功能，文件操作，文件管理，编程开发设计，或是其它一些异想天开的东西。","categories":[{"name":"notes","slug":"notes","permalink":"https://cxx001.gitee.io/categories/notes/"}],"tags":[{"name":"makefile","slug":"makefile","permalink":"https://cxx001.gitee.io/tags/makefile/"},{"name":"make","slug":"make","permalink":"https://cxx001.gitee.io/tags/make/"}],"keywords":[{"name":"notes","slug":"notes","permalink":"https://cxx001.gitee.io/categories/notes/"}]},{"title":"Linux共享内存","slug":"project/Linux共享内存","date":"2022-08-23T06:20:55.000Z","updated":"2023-03-14T05:34:41.930Z","comments":true,"path":"2022/08/23/project/Linux共享内存/","link":"","permalink":"https://cxx001.gitee.io/2022/08/23/project/Linux%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/","excerpt":"","text":"基础在linux系统开发当中，时常需要在多个进程之间交换数据，在多个进程之间交换数据，有很多方法，但最高效的方法莫过于共享内存。 linux共享内存是通过tmpfs这个文件系统来实现的，tmpfs文件系的目录为&#x2F;dev&#x2F;shm，&#x2F;dev&#x2F;shm是驻留在内存 RAM 当中的，因此读写速度与读写内存速度一样，&#x2F;dev&#x2F;shm的容量默认尺寸为系统内存大小的一半大小，使用df -h命令可以看到。但实际上它并不会真正的占用这块内存，如果&#x2F;dev&#x2F;shm&#x2F;下没有任何文件，它占用的内存实际上就是0字节，仅在使用shm_open文件时，&#x2F;dev&#x2F;shm才会真正占用内存。 在Linux系统使用共享内存，一般用到以下几个函数： 12345678910// 用于创建或者打开共享内存文件int shm_open(const char *name, int oflag, mode_t mode);// 将打开的文件映射到内存void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);// 取消内存映射int munmap(void *addr, size_t length);// 删除/dev/shm目录的文件int shm_unlink(const char *name);// 重置文件大小int ftruncate(int fd, off_t length); 示例1. 共享内存相关操作封装SimuShareMem.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#ifndef __SIMU_SHARE_MEM_#define __SIMU_SHARE_MEM_enum &#123; SIMU_MAX_SHM_BLOCK_QUEUE_LEN = 1024, // 队列长度 SIMU_MAX_SHM_BLOCK_BUFF_LEN = 2048 // 缓冲区数据长度&#125;;// 共享内存块typedef struct TagSimuShareMemBlock&#123; int ReadDataPtr; // 读下标 int WriteDataptr; // 写下标 unsigned long nCoverCount; // 写覆盖次数(好像不准确) unsigned long nRepeatCount; // 读重复次数(没用到) unsigned long nDataType[SIMU_MAX_SHM_BLOCK_QUEUE_LEN]; // 数据类型 unsigned long nDataLen[SIMU_MAX_SHM_BLOCK_QUEUE_LEN]; // 数据长度 char szData[SIMU_MAX_SHM_BLOCK_QUEUE_LEN][SIMU_MAX_SHM_BLOCK_BUFF_LEN]; // 数据区 &#125;SimuShareMemBlock_t;// 共享全双工节点typedef struct TagSimuShareMemNode &#123; int nReadShmfd; // 读共享内存文件句柄 int nWriteShmfd; // 写共享内存文件句柄 SimuShareMemBlock_t* pReadShm; // 读共享内存区块 SimuShareMemBlock_t* pWriteShm; // 写共享内存区块 char szReadShmName[128]; // 读共享内存块名称 char szWriteShmName[128]; // 写共享内存块名称&#125;SimuShareMemNode_t;// 共享内存数据typedef struct TagSimuShareMemData&#123; int nDataType; unsigned long ulDataLen; char* pData; unsigned long ulTsl; unsigned long ulTs2;&#125;SimuShareMemData_t;int CreateShareMemNode(SimuShareMemNode_t* pNode, const char* szWriteShmName, const char* szReadShmName);int OpenShareMemNode(SimuShareMemNode_t* pNode, const char* szWriteShmName, const char* szReadShmName);int CloseShareMemNode(SimuShareMemNode_t* pNode); // 取消内存映射int UnlinkShareMem(const char* szWriteShmName, const char* szReadShmName); // 删除/dev/shm目录的文件int IsNewShareMemData(SimuShareMemNode_t* pNode);int ReadShareMemData(SimuShareMemNode_t* pNode, SimuShareMemData_t* pShmData);int WriteShareMemData(SimuShareMemNode_t* pNode, int nDataType, const char* pData, unsigned long ulDataLen);#endif SimuShareMem.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242//#ifdef LINUX_PLATFORM#include &quot;SimuShareMem.h&quot;#include &lt;stdbool.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/mman.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;static SimuShareMemBlock_t* CreateShareMemBlock(int* pFd, const char* szBlockName);static SimuShareMemBlock_t* OpenShareMemBlock(int* pFd, const char* szBlockName);SimuShareMemBlock_t* CreateShareMemBlock(int* pFd, const char* szBlockName)&#123; SimuShareMemBlock_t* pBlock = NULL; int hFd = 0; if (pFd == NULL || szBlockName == NULL) &#123; return NULL; &#125; // 打开文件如果没有就创建, 存在则打开失败返回-1 hFd = shm_open(szBlockName, O_CREAT|O_EXCL|O_RDWR, S_IRWXU|S_IRWXG); if (hFd == -1) &#123; if (errno == EEXIST) &#123; hFd = shm_open(szBlockName, O_RDWR, S_IRWXU); if (hFd == -1) &#123; return NULL; &#125; &#125; else &#123; return NULL; &#125; &#125; // 重置文件大小 if (ftruncate(hFd, sizeof(SimuShareMemBlock_t)) == -1) &#123; close(hFd); return NULL; &#125; // 将打开的文件映射到内存 pBlock = (SimuShareMemBlock_t*)mmap(NULL, sizeof(SimuShareMemBlock_t), PROT_READ|PROT_WRITE, MAP_SHARED, hFd, 0); if (pBlock == NULL) &#123; close(hFd); return NULL; &#125; *pFd = hFd; return pBlock; // 共享内存地址&#125;SimuShareMemBlock_t* OpenShareMemBlock(int* pFd, const char* szBlockName)&#123; SimuShareMemBlock_t* pBlock = NULL; int hFd = shm_open(szBlockName, O_RDWR, S_IRWXU); if (hFd == -1) &#123; return NULL; &#125; pBlock = (SimuShareMemBlock_t*)mmap(NULL, sizeof(SimuShareMemBlock_t), PROT_READ|PROT_WRITE, MAP_SHARED, hFd, 0); if (pBlock == NULL) &#123; close(hFd); return NULL; &#125; *pFd = hFd; return pBlock;&#125;int CreateShareMemNode(SimuShareMemNode_t* pNode, const char* szWriteName, const char* szReadName)&#123; bool bError = false; if (pNode == NULL || szWriteName == NULL || szReadName == NULL) &#123; return -1; &#125; strcpy(pNode-&gt;szWriteShmName, szWriteName); strcpy(pNode-&gt;szReadShmName, szReadName); pNode-&gt;nReadShmfd = 0; pNode-&gt;nWriteShmfd = 0; do &#123; pNode-&gt;pReadShm = CreateShareMemBlock(&amp;pNode-&gt;nReadShmfd, pNode-&gt;szReadShmName); if (pNode-&gt;pReadShm == NULL) &#123; bError = true; break; &#125; pNode-&gt;pReadShm-&gt;nCoverCount = 0; pNode-&gt;pReadShm-&gt;nRepeatCount = 0; pNode-&gt;pReadShm-&gt;ReadDataPtr = 0; pNode-&gt;pReadShm-&gt;WriteDataptr = 0; pNode-&gt;pWriteShm = CreateShareMemBlock(&amp;pNode-&gt;nWriteShmfd, pNode-&gt;szWriteShmName); if (pNode-&gt;pWriteShm == NULL) &#123; bError = true; break; &#125; pNode-&gt;pWriteShm-&gt;nCoverCount = 0; pNode-&gt;pWriteShm-&gt;nRepeatCount = 0; pNode-&gt;pWriteShm-&gt;ReadDataPtr = 0; pNode-&gt;pWriteShm-&gt;WriteDataptr = 0; &#125; while(0); if(bError) &#123; CloseShareMemNode(pNode); return -1; &#125; return 0;&#125;int OpenShareMemNode(SimuShareMemNode_t* pNode, const char* szWriteName, const char* szReadName)&#123; bool bError = false; if (pNode == NULL || szWriteName == NULL || szReadName == NULL) &#123; return -1; &#125; strcpy(pNode-&gt;szWriteShmName, szWriteName); strcpy(pNode-&gt;szReadShmName, szReadName); pNode-&gt;nReadShmfd = 0; pNode-&gt;nWriteShmfd = 0; do &#123; pNode-&gt;pReadShm = OpenShareMemBlock(&amp;pNode-&gt;nReadShmfd, pNode-&gt;szReadShmName); if (pNode-&gt;pReadShm == NULL) &#123; bError = true; break; &#125; // 这里注释是因为写的测试程序起来就写数据了, 所以读的测试程序获取这块空间时不能重置了. // 正常程序这里不要注释，所有进程都要启动了，才能往共享内存里读写数据. /* pNode-&gt;pReadShm-&gt;nCoverCount = 0; pNode-&gt;pReadShm-&gt;nRepeatCount = 0; pNode-&gt;pReadShm-&gt;ReadDataPtr = 0; pNode-&gt;pReadShm-&gt;WriteDataptr = 0; */ pNode-&gt;pWriteShm = OpenShareMemBlock(&amp;pNode-&gt;nWriteShmfd, pNode-&gt;szWriteShmName); if (pNode-&gt;pWriteShm == NULL) &#123; bError = true; break; &#125; /* pNode-&gt;pWriteShm-&gt;nCoverCount = 0; pNode-&gt;pWriteShm-&gt;nRepeatCount = 0; pNode-&gt;pWriteShm-&gt;ReadDataPtr = 0; pNode-&gt;pWriteShm-&gt;WriteDataptr = 0; */ &#125; while(0); if(bError) &#123; CloseShareMemNode(pNode); return -1; &#125; return 0;&#125;int CloseShareMemNode(SimuShareMemNode_t* pNode)&#123; if (pNode == NULL) &#123; return -1; &#125; if (pNode-&gt;pReadShm != NULL) &#123; // 取消内存映射 munmap(pNode-&gt;pReadShm, sizeof(SimuShareMemBlock_t)); pNode-&gt;pReadShm = NULL; close(pNode-&gt;nReadShmfd); &#125; if (pNode-&gt;pWriteShm != NULL) &#123; // 取消内存映射 munmap(pNode-&gt;pWriteShm, sizeof(SimuShareMemBlock_t)); pNode-&gt;pWriteShm = NULL; close(pNode-&gt;nWriteShmfd); &#125; return 0;&#125;int UnlinkShareMem(const char* szWriteName, const char* szReadName)&#123; // 删除/dev/shm目录的文件 shm_unlink(szWriteName); shm_unlink(szReadName); return 0;&#125;int IsNewShareMemData(SimuShareMemNode_t* pNode)&#123; SimuShareMemBlock_t* pShm = pNode-&gt;pReadShm; if (pShm-&gt;ReadDataPtr % SIMU_MAX_SHM_BLOCK_QUEUE_LEN == pShm-&gt;WriteDataptr % SIMU_MAX_SHM_BLOCK_QUEUE_LEN) &#123; return -1; &#125; return 0;&#125;int ReadShareMemData(SimuShareMemNode_t* pNode, SimuShareMemData_t* pShmData)&#123; SimuShareMemBlock_t* pShm = pNode-&gt;pReadShm; unsigned long nReadIdx = 0; if (pShm-&gt;ReadDataPtr % SIMU_MAX_SHM_BLOCK_QUEUE_LEN == pShm-&gt;WriteDataptr % SIMU_MAX_SHM_BLOCK_QUEUE_LEN) &#123; return -1; &#125; nReadIdx = pShm-&gt;ReadDataPtr % SIMU_MAX_SHM_BLOCK_QUEUE_LEN; pShmData-&gt;nDataType = pShm-&gt;nDataType[nReadIdx]; pShmData-&gt;ulDataLen = pShm-&gt;nDataLen[nReadIdx]; pShmData-&gt;pData = (char*)malloc(pShmData-&gt;ulDataLen); memcpy((void*)pShmData-&gt;pData, pShm-&gt;szData[nReadIdx], pShmData-&gt;ulDataLen); pShm-&gt;ReadDataPtr += 1; pShm-&gt;ReadDataPtr %= SIMU_MAX_SHM_BLOCK_QUEUE_LEN; pShmData-&gt;ulTsl = time(NULL); return 0;&#125;int WriteShareMemData(SimuShareMemNode_t* pNode, int nDataType, const char* pData, unsigned long ulDataLen)&#123; SimuShareMemBlock_t* pShm = pNode-&gt;pWriteShm; unsigned long nWriteIdx = 0; if (pShm-&gt;ReadDataPtr == (pShm-&gt;WriteDataptr + 1) % SIMU_MAX_SHM_BLOCK_QUEUE_LEN) &#123; pShm-&gt;nCoverCount++; // 这里不知道啥意思 &#125; nWriteIdx = pShm-&gt;WriteDataptr % SIMU_MAX_SHM_BLOCK_QUEUE_LEN; memcpy(pShm-&gt;szData[nWriteIdx], pData, ulDataLen); pShm-&gt;nDataLen[nWriteIdx] = ulDataLen; pShm-&gt;nDataType[nWriteIdx] = nDataType; pShm-&gt;WriteDataptr++; pShm-&gt;WriteDataptr %= SIMU_MAX_SHM_BLOCK_QUEUE_LEN; return 0;&#125;//#endif 2. 使用示例共享内存写数据: writer.c 编译命令: g++ writer.c SimuShareMem.h SimuShareMem.cpp -o writer -lrt 注意最后的 -lrt链接库不能少，不然shm_open等相关函数不认识 ! 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &quot;SimuShareMem.h&quot;int main(int argc,char * argv[])&#123; SimuShareMemNode_t pNode; const char* szWriteShmName = &quot;shm_writer&quot;; const char* szReadShmName = &quot;shm_reader&quot;; CreateShareMemNode(&amp;pNode, szWriteShmName, szReadShmName); char writeData[] = &quot;test share memory writer.&quot;; int result = WriteShareMemData(&amp;pNode, 1, writeData, sizeof(writeData)); printf(&quot;result:%d, data:%s, len:%ld&quot;, result, writeData, sizeof(writeData)); getchar(); CloseShareMemNode(&amp;pNode); UnlinkShareMem(szWriteShmName, szReadShmName); return 0;&#125; 共享内存读数据：reader.c 编译命令: g++ reader.c SimuShareMem.h SimuShareMem.cpp -o reader -lrt 1234567891011121314151617#include &lt;stdio.h&gt;#include &quot;SimuShareMem.h&quot;int main(int argc,char * argv[])&#123; SimuShareMemNode_t pNode; const char* szWriteShmName = &quot;shm_writer&quot;; const char* szReadShmName = &quot;shm_reader&quot;; OpenShareMemNode(&amp;pNode, szReadShmName, szWriteShmName); // 这里的读是对面的写 SimuShareMemData_t srData; int result = ReadShareMemData(&amp;pNode, &amp;srData); printf(&quot;result: %d, data: %s, len: %ld&quot;, result, srData.pData, srData.ulDataLen); getchar(); return 0;&#125; 3. 测试结果 测试机器 分别启动writer&#x2F;reader程序读写结果 &#x2F;dev&#x2F;shm目录下新增对应两个共享内存文件","categories":[{"name":"project","slug":"project","permalink":"https://cxx001.gitee.io/categories/project/"}],"tags":[{"name":"共享内存","slug":"共享内存","permalink":"https://cxx001.gitee.io/tags/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"}],"keywords":[{"name":"project","slug":"project","permalink":"https://cxx001.gitee.io/categories/project/"}]},{"title":"虚拟地址到物理地址映射","slug":"computer system/虚拟地址到物理地址映射","date":"2022-08-19T16:32:55.000Z","updated":"2023-03-14T05:34:06.374Z","comments":true,"path":"2022/08/20/computer system/虚拟地址到物理地址映射/","link":"","permalink":"https://cxx001.gitee.io/2022/08/20/computer%20system/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/","excerpt":"","text":"前言程序在编译链接完成后所有指令虚拟地址就已经确定了，CPU在执行到某条指令，得到它的虚拟地址，然后通过其芯片里的MMU硬件将虚拟地址转换为物理地址，然后先去CPU芯片里的高速缓存中获取数据，如果没有再去内存中获取(这里程序会自动预测CPU下次指令要执行的数据，会提前把数据从内存传递到高速缓存中)。 其中虚拟地址映射到物理地址的实现大体经历了4次优化历程，下面依次分析。 名词约定： va: 虚拟地址 pa: 物理地址 一 “%”取模pa &#x3D; va % pa_max_len 最早就是用这种取模的方式来做映射的，它保证了虚拟地址映射不会越界。但是有个很明显的问题，就是地址冲突，同时只能运行一个程序，不能多开。 二 哈希后来为了解决地址冲突问题，我们想到了用哈希map来实现，va–&gt;hashmap–&gt;pa，它能保证每个va都能映射唯一的pa，解决了地址冲突的问题。 但是通过hashmap计算出的pa地址分布是凌乱的，这样寻址就会很低效。 三 段地址既然哈希算法转换的地址凌乱分布，导致寻址低效。那么有没有办法使得一段连续虚拟地址对应的物理地址也连续了？ 后面人们想到了用一段段连续空间来表示，如下图，程序p2分布在两个段空间内，段内地址是连续的，那么我们记录这样的段空间就可以用(va0, pa0, D)一个三元组来表示。va0是段虚拟地址的起始地址，pa0是物理地址的起始地址，D是段空间范围。 那么我们要映射某个物理地址va，过程是这样，先循环判断条件 va0 &lt;&#x3D; va &lt;&#x3D; va0 + D，找出va属于哪个段，然后 pa &#x3D; va - va0 + pa0; 这种方式解决了映射地址分布凌乱的问题，但是我们发现段的范围D是不固定的，根据当前内存使用情况决定。随着各种程序运行推移，一个程序很难找到一段比较长的空闲空间，他会分布到多个段空间中，碎片化越来越严重。 而且还一个问题是每次映射都要先查找属于哪个段的条件判断，这也是麻烦之一。 四 多级分页最终我们想到了让D保持不变，一般默认是4kb大小，这样的话我们描述映射表就只需要一个二元组了(va0, pa0)，甚至我们还可以直接用表的key索引来当va0字段，这样就只需要一个字段pa0记录了。 同时把内存分成一个个固定大小的页来作为最小的储存单元，这样相对不定长的段碎片也会少很多。 不过了光只是一层分页还不够，还可以再进一步优化，即多级分页，一般分到4层，每层4等分。那为什么要这么干了？下面我们来分析下其中缘由： 对于我们64位cpu一般va寻址范围是2^48，首先我们按4kb(2^12)分页，总共页数&#x3D; 2^48 &#x2F; 2^12 &#x3D; 2^36. 假设有个程序只分布在上图中的3个区域，那么这样就有个问题，这个程序有效数据其实只有图中的3个区域，但是我们却要申请2^36这么大一个数组来记录，大部分都是无效数据。 怎么优化了，那就是再往下分，每次4等分。 这样是不是这个程序的3个区域只在4(0~3)等分后的第1和第3个分区里。那么我们就只需要记录第1和第3个分区。依次类推再往下分，要记录的无效数据就会越来越少，即所要申请的记录数组越小。","categories":[{"name":"computer system","slug":"computer-system","permalink":"https://cxx001.gitee.io/categories/computer-system/"}],"tags":[{"name":"内存","slug":"内存","permalink":"https://cxx001.gitee.io/tags/%E5%86%85%E5%AD%98/"},{"name":"虚拟地址","slug":"虚拟地址","permalink":"https://cxx001.gitee.io/tags/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/"},{"name":"物理地址","slug":"物理地址","permalink":"https://cxx001.gitee.io/tags/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80/"}],"keywords":[{"name":"computer system","slug":"computer-system","permalink":"https://cxx001.gitee.io/categories/computer-system/"}]},{"title":"QuikPlatform Demo说明","slug":"project/QuikPlatform Demo说明","date":"2022-08-01T09:32:55.000Z","updated":"2022-09-07T00:27:39.177Z","comments":true,"path":"2022/08/01/project/QuikPlatform Demo说明/","link":"","permalink":"https://cxx001.gitee.io/2022/08/01/project/QuikPlatform%20Demo%E8%AF%B4%E6%98%8E/","excerpt":"","text":"QuikPaltformTest目录结构12345678910111213141516171819202122232425QuikPaltformTest |--&gt; bin // 打包后可执行程序 |--&gt; doc // 文档 |--&gt; trunk |--&gt; bin // 平台的动态库 |--&gt; include // 平台的头文件 |--&gt; CoreApp |--&gt; CoreLib |--&gt; CoreUi |--&gt; KIQtGui |--&gt; MyUI |--&gt; server |--&gt; server_imp |--&gt; ToolsLib |--&gt; lib // 平台的静态库 |--&gt; src // 自定义源码 |--&gt; plugins // 自定义插件 |--&gt; MyUI |--&gt; PluginGreetServer |--&gt; PluginUIA |--&gt; PluginUIB |--&gt; PluginUIC |--&gt; QuikPlatformIDE // 工程目录 |--&gt; QuikPlatformIDE.sln // vs启动文件 |--&gt; ... 创建插件 QuikPaltform平台封装了一套插件机制，通过开发各种插件然后组装起来就形成了一个软件。插件分为UI插件、Server插件、两者都有插件，他们遵循的规范都大同小异，分为声明接口、实现接口、注册这3个步骤。下面以Demo中”SayHello”服务接口为例： 1.声明对外提供的接口12345678910111213141516// IGreetServer.h...namespace Kcc &#123; namespace Greet &#123; class IGreetServer &#123; public： virtual ~IGreetServer() &#123;&#125; virtual void SayHello() = 0; // 对外提供的接口 &#125;; typedef QSharedPointer&lt;IGreetServer&gt; PIGreetServer; // 接口对象的智能指针 // 插件定义的通知事件类型 enum &#123; Notify_SayHello = 1 &#125;;&#125;&#125;... 2.实现接口1234567891011121314151617181920// GreetSever.h.../*如果想构建自己的服务，必须先继承ServerBase和自己自定义的服务接口（IGreetServer）*/class GreetServer : public ServerBase, public IGreetServer&#123;public: GreetServer(); ~GreetServer();public: // IServerInterfaceBase里的这几个接口必须要实现 virtual QString GetServerGroupName() const &#123; return SERVER_GROUP_IGREETSERVER_NAME; &#125; virtual QString GetInterfaceDefName() const &#123; return SERVER_INTERFACE_IGREETSERVER_NAME; &#125; virtual unsigned int GetVersion() const &#123; return SERVER_VERSION; &#125;public: // IGreetServer virtual void SayHello();&#125;;... 12345678910111213141516171819202122// GreetSever.cpp...void GreetServer::SayHello()&#123; //输出log日志 LOGOUT(QString(&quot;GreetServer SayHello&quot;), LOG_NORMAL); //1.发送通知：先请求对应的服务，这个服务对象类型为必须是PIServerInterfaceBase PIServerInterfaceBase pserver = RequestServer(SERVER_GROUP_IGREETSERVER_NAME, SERVER_INTERFACE_IGREETSERVER_NAME); //2.确定发送参数，发送命令（Notify_SayHello）是必须的，参数可以根据实际情况判断是否需要 NotifyStruct notifyStruct; notifyStruct.code = Notify_SayHello; notifyStruct.paramMap[&quot;Sender&quot;] = &quot;come from Greetserver&quot;; //3.发送通知 if (pserver) &#123; pserver-&gt;emitNotify(notifyStruct); &#125;&#125;... 3.插件注册123456789101112// PluginGreetServer.h...//每个被注册的模块都必须继承Moduleclass PluginGreetServer : public Module&#123; //每个模块都必须使用此宏 DEFINE_MODULEpublic: PluginGreetServer(QString strName); ~PluginGreetServer();&#125;;... 123456789101112131415...// 静态注册（当dll被加载时会调用），每个模块都必须使用此宏（第一个参数是当前类的类型；第二个是组的名称，一般为空；第三个是显示名称，一般是类型名称）REG_MODULE_BEGIN(PluginGreetServer, &quot;&quot;, &quot;PluginGreetServer&quot;)REG_MODULE_END(PluginGreetServer)//每个Module的参数一般情况为Module_Type_Normal，根据实际情况而定PluginGreetServer::PluginGreetServer(QString strName):Module(Module_Type_Normal, strName)&#123; /* 注册问候服务（服务都必须在构造的时候注册，请求服务一般都在所有模块构造之后，这样可以确保所有服务都已经被注册， 可以在每个模块的init()函数中请求，因为这个函数会在所有模块被构造之后被调用） */ RegServer&lt;GreetServer&gt;(new GreetServer());&#125;... 使用插件1. 通过直接获取插件对象指针来调用其接口123456789101112131415161718// PluginUIB.h...class PluginUIB :public QWidget, public Module&#123; Q_OBJECT DEFINE_MODULEpublic: PluginUIB(QString strName); ~PluginUIB();public: //Module virtual void init(KeyValueMap ¶ms); virtual void unInit(KeyValueMap &amp;saveParams);private: PIGreetServer m_pGreetServer; // 问候服务接口&#125;;... 12345678910111213141516171819202122232425262728// PluginUIB.cpp...void PluginUIB::init(KeyValueMap ¶ms)&#123; // 1. 获取要使用插件对象 m_pGreetServer = RequestServer&lt;IGreetServer&gt;(SERVER_GROUP_IGREETSERVER_NAME, SERVER_INTERFACE_IGREETSERVER_NAME); if (!m_pGreetServer) &#123; LOGOUT(&quot;IGreetServer未注册&quot;, LOG_ERROR); &#125;&#125;void PluginUIB::unInit(KeyValueMap &amp;saveParams)&#123; // 3. 使用插件对象释放 m_pGreetServer.clear();&#125;// 槽函数void PluginUIB::onPluginBTest()&#123; ui.textEdit-&gt;append(&quot;面板B的按钮已经被按下&quot;); if (m_pGreetServer) &#123; // 2. 调用插件对象对外提供的接口 m_pGreetServer-&gt;SayHello(); &#125;&#125; 2. 通过消息发布&#x2F;订阅的形式使用插件接口1234567891011121314151617181920// PluginUIC.cpp// 订阅消息(消息接收方)void PluginUIC::init(KeyValueMap &amp;params)&#123; // 1.请求问候服务 PIServerInterfaceBase pGreetserver = RequestServer(SERVER_GROUP_IGREETSERVER_NAME, SERVER_INTERFACE_IGREETSERVER_NAME); // 2.连接槽函数 pGreetserver-&gt;connectNotify(Notify_SayHello, this, SLOT(onRecieveGreetMsg(unsigned int, const NotifyStruct&amp;)));&#125;// 3. 槽函数消息响应void PluginUIC::onRecieveGreetMsg(unsigned int code, const NotifyStruct&amp; param)&#123; if (code == Notify_SayHello) &#123; QString strGreetMsg = param.paramMap[&quot;Sender&quot;].toString(); ui.textEdit-&gt;append(strGreetMsg); &#125; QMessageBox::about(this, tr(&quot;测试双击菜单&quot;), tr(&quot;双击响应！&quot;));&#125; 123456789101112131415161718192021// GreetSever.cpp// 发布消息(消息发送方)void GreetServer::SayHello()&#123; //输出log日志 LOGOUT(QString(&quot;GreetServer SayHello&quot;), LOG_NORMAL); //1.发送通知：先请求对应的服务，这个服务对象类型为必须是PIServerInterfaceBase PIServerInterfaceBase pserver = RequestServer(SERVER_GROUP_IGREETSERVER_NAME, SERVER_INTERFACE_IGREETSERVER_NAME); //2.确定发送参数，发送命令（Notify_SayHello）是必须的，参数可以根据实际情况判断是否需要 NotifyStruct notifyStruct; notifyStruct.code = Notify_SayHello; notifyStruct.paramMap[&quot;Sender&quot;] = &quot;come from Greetserver&quot;; //3.发送通知 if (pserver) &#123; pserver-&gt;emitNotify(notifyStruct); &#125;&#125;","categories":[{"name":"project","slug":"project","permalink":"https://cxx001.gitee.io/categories/project/"}],"tags":[{"name":"QT","slug":"QT","permalink":"https://cxx001.gitee.io/tags/QT/"},{"name":"软件架构","slug":"软件架构","permalink":"https://cxx001.gitee.io/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"}],"keywords":[{"name":"project","slug":"project","permalink":"https://cxx001.gitee.io/categories/project/"}]},{"title":"飞行仿真项目服务端设计","slug":"project/飞行仿真项目服务端设计","date":"2022-08-01T08:32:55.000Z","updated":"2023-03-14T05:33:25.028Z","comments":true,"path":"2022/08/01/project/飞行仿真项目服务端设计/","link":"","permalink":"https://cxx001.gitee.io/2022/08/01/project/%E9%A3%9E%E8%A1%8C%E4%BB%BF%E7%9C%9F%E9%A1%B9%E7%9B%AE%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"Table of Contents generated with DocToc 一 服务端架构概览 技术选型 整体架构 二 通信协议格式 1. 与前端通信 Package层 Message层 2. 与引擎通信 三 用户Gra4工程导入 Gra4格式 DB格式 下位机引擎生成代码平铺后的格式 一 服务端架构概览技术选型 nodejs + mongodb，多进程、分布式的服务器。 nodejs优势: io与可伸缩性的优势。io密集型的应用采用node.js是最合适的， 可达到最好的可伸缩性。 多进程单线程的应用架构。node.js天生采用单线程， 使它在处理复杂逻辑的时候无需考虑线程同步、锁、死锁等一系列问题， 减少了很多逻辑错误。 由多进程node.js组成的服务器群是最理想的应用架构之一。 语言优势。使用javascript开发可以实现快速迭代，如果客户端使用html 5，更可实现代码共用。 mongodb优势: 使用简单、方便。不需要预先定义表结构, 和写json配置一样自然。 整体架构 注： 上图中的方块表示进程， 定义上等同于“服务器“ 运行架构说明： 客户端登录网关服(gate), 网关服会根据connector服务器群负载情况，动态分配一个返回给客户端。 客户端通过websocket长连接连到connector服务器群。 connector负责承载连接，并把请求转发到后端的服务器群。 后端的服务器群主要包括引擎服务器(engine)、验证服务器(auth)等， 这些服务器负责各自的业务逻辑。后面还会有各种其它类型的服务器。 后端服务器处理完逻辑后把结果返回给connector， 再由connector广播回给客户端。 master负责统一管理这些服务器，包括各服务器的启动、监控和关闭等功能。 二 通信协议格式1. 与前端通信 基于tcp&#x2F;websocket方式通信, 底层使用的是二进制协议。协议包含两层编码: package和message。message层主要实现route压缩和protobuf压缩，message层的编码结果将传递给package层。package层主要实现应用基于二进制协议的握手过程，心跳和数据传输编码，package层的编码结果可以通过tcp，websocket等协议以二进制数据的形式进行传输。message层编码可选，也可替换成其他二进制编码格式，都不影响package层编码和发送。 协议层的结构如下图所示： Package层 package格式 package分为header和body两部分。header描述package包的类型和包的长度，body则是需要传输的数据内容。具体格式如下： type - package类型，1个byte，取值如下。 0x01: 客户端到服务器的握手请求以及服务器到客户端的握手响应 0x02: 客户端到服务器的握手ack 0x03: 心跳包 0x04: 数据包 0x05: 服务器主动断开连接通知 length - body内容长度，3个byte的大端整数，因此最大的包长度为2^24个byte。 body - 二进制的传输内容。 握手 握手流程主要提供一个机会，让客户端和服务器在连接建立后，进行一些初始化的数据交换。握手的内容为utf-8编码的json字符串（不压缩），通过body字段传输。 握手请求： 123456789&#123; &quot;sys&quot;: &#123; &quot;version&quot;: &quot;1.1.1&quot;, &quot;type&quot;: &quot;js-websocket&quot; &#125;, &quot;user&quot;: &#123; // any customized request data &#125;&#125; 握手响应: 1234567891011&#123; &quot;code&quot;: 200, // response code &quot;sys&quot;: &#123; &quot;heartbeat&quot;: 3, // heartbeat interval in second &quot;dict&quot;: &#123;&#125;, // route dictionary &quot;protos&quot;: &#123;&#125; // protobuf definition data &#125;, &quot;user&quot;: &#123; // any customized response data &#125;&#125; 握手流程如下: 当底层连接建立后，客户端向服务器发起握手请求，并附带必要的数据。服务器检验握手数据后，返回握手响应。如果握手成功，客户端向服务器发送一个握手ack，握手阶段至此成功结束。 心跳 心跳包的length字段为0，body为空。 心跳的流程如下： 服务器可以配置心跳时间间隔。当握手结束后，客户端发起第一个心跳。服务器和客户端收到心跳包后，延迟心跳间隔的时间后再向对方发送一个心跳包。 心跳超时时间为2倍的心跳间隔时间。服务器检测到心跳超时并不会主动断开客户端的连接。客户端检测到心跳超时，可以根据策略选择是否要主动断开连接。 数据 数据包用来在客户端和服务器之间传输数据所用。数据包的body是由上层传下来的任意二进制数据，package层不会对body内容做任何处理。 服务器主动断开 当服务器主动断开客户端连接时（如：踢掉某个在线用户），会先向客户端发送一个控制消息，然后再断开连接。客户端可以通过这个消息来判断是否是服务器主动断开连接的。 Message层message协议的主要作用是封装消息头，包括route和消息类型两部分，不同的消息类型有着不同的消息头，在消息头里面可能要打入message id(即requestId)和route信息。由于可能会有route压缩，而且对于服务端push的消息，message id为空，对于客户端请求的响应，route为空，因此message的头格式比较复杂。 消息头分为三部分，flag，message id，route。如下图所示： 从上图可以看出，消息头是可变的，会根据具体的消息类型和内容而改变。其中： flag位是必须的，占用一个byte，它决定了后面的消息类型和内容的格式; message id和route则是可选的。其中message id采用varints 128变长编码方式，根据值的大小，长度在0～5byte之间。route则根据消息类型以及内容的大小，长度在0～255byte之间。 标志位flag flag占用message头的第一个byte，其内容如下: 现在只用到了其中的4个bit，这四个bit包括两部分，占用3个bit的message type字段和占用1个bit的route标识，其中： message type用来标识消息类型,范围为0～7，现在消息共有四类，request，notify，response，push，值的范围是0～3。不同的消息类型有着不同的消息内容，下面会有详细分析。 最后一位的route表示route是否压缩，影响route字段的长度。 这两部分之间相互独立，互不影响。 消息类型 不同类型的消息，对应不同消息头，消息类型通过flag字段的第2-4位来确定，其对应关系以及相应的消息头如下图： route压缩标志位 route主要分为压缩和未压缩两种，由flag的最后一位（route压缩标志位）指定，当flag中的route标志为0时，表示未压缩的route，为1则表示是压缩route。route字段的编码会依赖flag的这一位，其格式如下图: 上图是不同的flag标志对应的route字段的内容： flag的最后一位为1时，后面跟的是一个uInt16表示的route字典编号，需要通过查询字典来获取route; flag最后一位为0是，后面route则由一个uInt8的byte，用来表示route的字节长度。之后是通过utf8编码后的route字符串，其长度就是前面一位byte的uInt8的值，因此route的长度最大支持256B。 2. 与引擎通信采用zmq通信，在后台服务器engine上起两个监听端口, 分别是zmq的Publisher模式(25150)和Pull模式(25151)。 服务端向下位机引擎发送消息: 1234567// Publisher模式:// 下位机引擎建立连接时，注册以uid为key的管道sock.connect(&quot;tcp://127.0.0.1:25150&quot;)sock.subscribe(&quot;uid&quot;)// 服务端向下位机引擎发送消息sock.send([&quot;uid&quot;, &quot;message&quot;]) 下位机引擎向服务端发送消息： 三 用户Gra4工程导入Gra4格式 主要的几个字段： 123UnitGroup: 当前画板模型列表IoportGroup: 输入/输出模块列表LineGroup: 连线列表 DB格式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 工程表 project&#123; id: String // 项目ID uid: String // 用户ID data: [sub] // 画板数组，每个元素对应一个画板&#125; sub: &#123; id: String // 画板ID name: String // 画板名称 pid: String // 画板关联的父ID block: [block] // 画板包含的模型 line: [line] // 画板包含的线&#125;block: &#123; id: String // 模型ID child: String // 模型关联的子画板ID(即子系统) modelId: String // 关联导入的数字模型ID (uid_dll_funcName) name: String // 模型名称 nodeType: Number // 模型类型(方形、圆形) position: Object // 模型位置 &#123; &quot;x&quot;: number, &quot;y&quot;: number &#125; size: Object // 模型大小 &#123; &quot;width&quot;: number), &quot;height&quot;: number &#125;; items: [&#123; &quot;id&quot;: &quot;out_0&quot;, &quot;group&quot;: &quot;in&quot; &#125;, &#123; &quot;id&quot;: &quot;in_0&quot;, &quot;group&quot;: &quot;out&quot; &#125;] // 端口描述 entity: String // 切换的实物ID, 默认null modifyAttr: &#123;&#125; // 修改的属性(和simulink逻辑一致, 先这里取修改的, 没有再去导入数字模型表中取)&#125;line: &#123; id: String // 连线ID lineType: Number // 连线类型 1: 细线 2: 粗线 source: Object // 线头 &#123;&quot;cell&quot;: 模型ID, &quot;port&quot;: 端口ID&#125; target: Object // 线尾 &#123;&quot;cell&quot;: 模型ID, &quot;port&quot;: 端口ID&#125; subLine: [] // 粗线详情 [&#123;source: Object, target: Object&#125;]&#125;// 示例结构&#123; id: string uid: string data: [ &#123; id: string, pid: string, name: string, block: [&#123; id: string, child: string, modelId: string, name: string, nodeType: int, position: Object, size: Object, items: [&#123; &quot;id&quot;: &quot;out_0&quot;, &quot;group&quot;: &quot;in&quot; &#125;, &#123; &quot;id&quot;: &quot;in_0&quot;, &quot;group&quot;: &quot;out&quot; &#125;], entity: null, modifyAttr: &#123;&#125; &#125;], line: [&#123; id: string, lineType: int, source: Object, target: Object, subLine: [] &#125;], &#125; ]&#125; 一个项目就是一个树结构，根节点就是顶层画板，子节点是子系统画板，叶子节点是最小的模型。 Gra4转DB整体思路： 读取解析项目中所有gra4文件，并找出顶层画板gra4对象(根据IoportGroup的Count属性为0判断)。 从顶层画板开始递归遍历。 首先确定当前遍历画板的中间模块和连线关系(不考虑Ioport相关模块与连线), 即下图圈起来部分: 然后确定当前遍历画板的IO模块和连线关系： 遍历与Ioport模块相关连的线，并记录连线端口信息。 然后在当前画板的父画板所有连线中找到与当前子系统连线端口一致的连线。 如果外边连线是粗线(一组线)，则需要判断是否展开，如果线连接的是子系统与子系统则不需要展开, 其它都展开。 如果是展开，则每条展开的线对应一个IO模块，以这条线对应的端口做为其ID。然后把连线关系建立起来。 如果不展开，则这条线会对应创建一个IO模块，如果这条线详情大于1条，则还会创建一个总线模块，IO模块ID同样根据线对应的端口确定，总线端口则根据线详情确定。最后把连线关系建立起来。 转换后的示意图: 下位机引擎生成代码平铺后的格式12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#123; &quot;PartitionGroup&quot;: [ &#123; &quot;Id&quot;: 0, &quot;CpuId&quot;: 0, &quot;Name&quot;: &quot;动力仿真子模型&quot;, &quot;BlockGroup&quot;: [ &#123; &quot;Id&quot;: 0, &quot;Name&quot;: &quot;发动机1&quot;, &quot;Model&quot;: &quot;Engine/EngineClass.json&quot;, &quot;Order&quot;: 0 &#125; ], &quot;BlcokCount&quot;: 5 &#125;, &#123; &quot;Id&quot;: 1, &quot;CpuId&quot;: 1, &quot;Name&quot;: &quot;弹道&quot;, &quot;BlockGroup&quot;: [ &#123; &quot;Id&quot;: 5, &quot;Name&quot;: &quot;部段1&quot;, &quot;Model&quot;: &quot;Mass/SegmentFunction.json&quot;, &quot;Order&quot;: 5 &#125; ], &quot;BlcokCount&quot;: 4 &#125; ], &quot;LineGroup&quot;: [ &#123; &quot;Src&quot;: 0, &quot;Dst&quot;: 1, &quot;SrcPort&quot;: 1, &quot;DstPort&quot;: 0, &quot;SrcName&quot;: &quot;发动机1&quot;, &quot;DstName&quot;: &quot;贮箱1&quot; &#125; ], &quot;IP&quot;: &quot;192.168.0.100&quot;, &quot;PartitionTotal&quot;: 2, &quot;BlockTotal&quot;: 9, &quot;LineTotal&quot;: 12&#125; DB转换engine平铺格式整体思路： 难点是生成LineGroup连线，其它信息获取比较简单，遍历DB树就能获取。下面主要记录下LineGroup连线生成的思路： 遍历所有最小模块，找出每个最小模块所有输出的连线。 然后遍历每条输出连线，递归查找出每条连线最后连的最小模块，即得到一条平铺后的连线。 递归逻辑： 如果线连的目标是子系统，则进入到子系统里边，依次找到连的目标递归。 如果线连的目标是IO&#x2F;总线模块，则找到线目标模块递归。 直到线连的目标是最小模块，跳出递归，确定连线。","categories":[{"name":"project","slug":"project","permalink":"https://cxx001.gitee.io/categories/project/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://cxx001.gitee.io/tags/nodejs/"},{"name":"服务器架构","slug":"服务器架构","permalink":"https://cxx001.gitee.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/"},{"name":"仿真","slug":"仿真","permalink":"https://cxx001.gitee.io/tags/%E4%BB%BF%E7%9C%9F/"}],"keywords":[{"name":"project","slug":"project","permalink":"https://cxx001.gitee.io/categories/project/"}]},{"title":"pomelo更新日志","slug":"pomelo/pomelo更新日志","date":"2022-08-01T08:05:16.000Z","updated":"2022-09-07T00:27:39.154Z","comments":true,"path":"2022/08/01/pomelo/pomelo更新日志/","link":"","permalink":"https://cxx001.gitee.io/2022/08/01/pomelo/pomelo%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/","excerpt":"","text":"Table of Contents generated with DocToc 1.0 日志 zookeeper集群管理 自动扩展插件 根据环境目录加载配置 客户端程序支持输入脚本命令 0.9 日志 rpc支持zeromq通信 客户端程序支持启动&#x2F;重启指定服务器 支持连接黑名单机制 支持protobuf原生的proto协议格式 websocket支持自动重连 0.8 日志 多个pushScheduler的配置及选择 rpc调用支持指定某台&#x2F;某类服务器 添加服务器生命周期回调 rpc也支持filter, 使用和handler的filter类似 servers.json配置新增集群简化配置 pomelo-logger支持动态日志级别 RPC调用的IP白名单 pomelo-admin的IP白名单 0.7日志 定时任务 新增全局filter 0.6日志 服务器与master之间的连接添加认证 plugin插件机制 连接加密 过载保护 0.5日志 master多机热备技术 分布式全局globalChannel 服务器自动重启 服务器绑定指定CPU 添加服务器关闭前事件 0.4日志 协议的编解码方式支持可配 支持同一账号多处登录 服务端检测心跳超时可配置是否断开连接 1.0 日志zookeeper集群管理 自动扩展插件 根据环境目录加载配置 默认先加载config根目录下的配置，当config目录下没有对应的文件时才会加载环境名称对应的目录下的配置。 客户端程序支持输入脚本命令 0.9 日志rpc支持zeromq通信 客户端程序支持启动&#x2F;重启指定服务器 支持连接黑名单机制 支持protobuf原生的proto协议格式 pomelo中使用步骤: 定义proto协议 用protobuf.js包自带命令将proto转js 加载js使用(protobuf.js本来是可以直接加载proto不需要转的，这里之所以转成js使用是考虑和pomelo原有的格式保持一致) websocket支持自动重连 0.8 日志多个pushScheduler的配置及选择 rpc调用支持指定某台&#x2F;某类服务器 添加服务器生命周期回调 rpc也支持filter, 使用和handler的filter类似 servers.json配置新增集群简化配置在0.8版的pomelo中对配置文件servers.json进行了精简，通过增加clusterCount字段将原有的配置进行了简化，这样将更加适合大规模应用的部署和运维管理。 原有的配置： 12345678910111213&quot;connector&quot;:[ &#123;&quot;id&quot;:&quot;connector-server-1&quot;, &quot;host&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:4050, &quot;clientPort&quot;: 3050, &quot;frontend&quot;: true&#125;, &#123;&quot;id&quot;:&quot;connector-server-2&quot;, &quot;host&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:4051, &quot;clientPort&quot;: 3051, &quot;frontend&quot;: true&#125;, &#123;&quot;id&quot;:&quot;connector-server-3&quot;, &quot;host&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:4052, &quot;clientPort&quot;: 3052, &quot;frontend&quot;: true&#125; ], &quot;chat&quot;:[ &#123;&quot;id&quot;:&quot;chat-server-1&quot;, &quot;host&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:6050&#125;, &#123;&quot;id&quot;:&quot;chat-server-2&quot;, &quot;host&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:6051&#125;, &#123;&quot;id&quot;:&quot;chat-server-3&quot;, &quot;host&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:6052&#125; ], &quot;gate&quot;:[ &#123;&quot;id&quot;: &quot;gate-server-1&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;clientPort&quot;: 3014, &quot;frontend&quot;: true&#125; ] 0.8版本pomelo支持的简化配置： 123456789&quot;connector&quot;:[ &#123;&quot;host&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:&quot;4050++&quot;, &quot;clientPort&quot;: &quot;3050++&quot;, &quot;frontend&quot;: true, &quot;clusterCount&quot;: 3&#125; ],&quot;chat&quot;:[ &#123;&quot;host&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:&quot;6050++&quot;, &quot;clusterCount&quot;: 3&#125; ],&quot;gate&quot;:[ &#123;&quot;host&quot;: &quot;127.0.0.1&quot;, &quot;clientPort&quot;: 3014, &quot;frontend&quot;: true, &quot;clusterCount&quot;: 1&#125; ] 同时在采用pomelo-cli进行动态增加服务器的时候，同样可以使用add host&#x3D;127.0.0.1 port&#x3D;9000++ serverType&#x3D;chat clusterCount&#x3D;3 这样的形式同时增加多台服务器。 pomelo-logger支持动态日志级别 RPC调用的IP白名单 pomelo-admin的IP白名单 0.7日志定时任务用户能够通过配置文件或者pomelo-cli的命令addCron和removeCron对定时任务进行动态调度。 定时任务是针对具体服务器而言，例如需要在chat服务器中配置定时任务： 首先在game-server&#x2F;app&#x2F;servers&#x2F;chat目录下增加cron目录，在game-server&#x2F;app&#x2F;servers&#x2F;chat&#x2F;cron目录下编写具体的执行的任务的代码chatCron.js，例如： 1234567891011module.exports = function(app) &#123; return new Cron(app);&#125;;var Cron = function(app) &#123; this.app = app;&#125;;var cron = Cron.prototype;cron.sendMoney = function() &#123; console.log(&#x27;%s server is sending money now!&#x27;, this.app.serverId);&#125;; 然后在game-server&#x2F;config&#x2F;目录下增加定时任务配置文件crons.json，具体配置文件如下所示： 1234567891011121314&#123; &quot;development&quot;:&#123; &quot;chat&quot;:[ &#123;&quot;id&quot;:1, &quot;time&quot;: &quot;0 30 10 * * *&quot;, &quot;action&quot;: &quot;chatCron.sendMoney&quot;&#125;, &#123;&quot;id&quot;:2, &quot;serverId&quot;:&quot;chat-server-1&quot;, &quot;time&quot;: &quot;0 30 10 * * *&quot;, &quot;action&quot;: &quot;chatCron.sendMoney&quot;&#125; ] &#125;, &quot;production&quot;:&#123; &quot;chat&quot;:[ &#123;&quot;id&quot;:1, &quot;time&quot;: &quot;0 30 10 * * *&quot;, &quot;action&quot;: &quot;chatCron.sendMoney&quot;&#125;, &#123;&quot;id&quot;:2, &quot;serverId&quot;:&quot;chat-server-1&quot;, &quot;time&quot;: &quot;0 30 10 * * *&quot;, &quot;action&quot;: &quot;chatCron.sendMoney&quot;&#125; ] &#125;&#125; 新增全局filter 0.6日志服务器与master之间的连接添加认证 plugin插件机制 连接加密 过载保护在pomelo之前的版本中有toobusy模块对服务器进行过载保护，在新版本中增加了一个对connector连接数的限制功能，开发者只需要在servers.json中对不同的connector进行最大连接数量的配置，当connector超过配置的最大数量，服务器会拒绝连接。配置可以参考如下代码： 1&#123;&quot;id&quot;:&quot;connector-server-1&quot;, &quot;host&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:4050, &quot;clientPort&quot;:3050, &quot;frontend&quot;:true, &quot;max-connections&quot;: 100&#125; 0.5日志master多机热备技术 分布式全局globalChannel 服务器自动重启 服务器绑定指定CPU为了更加充分的利用服务器的CPU，Pomelo在0.5版本中增加了服务器进程与指定CPU进行绑定，该功能限于linux系统的多核服务器，如果需要将服务器与具体CPU进行绑定，只需要在servers.json中进行配置，具体配置如下： 12345678910111213&#123; &quot;development&quot;:&#123; &quot;connector&quot;:[ &#123;&quot;id&quot;:&quot;connector-server-1&quot;, &quot;host&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:4050, &quot;clientPort&quot;: 3050, &quot;frontend&quot;: true, &quot;cpu&quot;: 2&#125; ] &quot;chat&quot;:[ &#123;&quot;id&quot;:&quot;chat-server-1&quot;, &quot;host&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:6050, &quot;cpu&quot;: 1&#125; ] &quot;gate&quot;:[ &#123;&quot;id&quot;: &quot;gate-server-1&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;clientPort&quot;: 3014, &quot;frontend&quot;: true, &quot;cpu&quot;: 3&#125; ] &#125;&#125; 添加服务器关闭前事件 0.4日志协议的编解码方式支持可配 支持同一账号多处登录 目前默认会挤号，应该是自己添加的逻辑。 服务端检测心跳超时可配置是否断开连接","categories":[{"name":"pomelo","slug":"pomelo","permalink":"https://cxx001.gitee.io/categories/pomelo/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://cxx001.gitee.io/tags/nodejs/"},{"name":"服务器架构","slug":"服务器架构","permalink":"https://cxx001.gitee.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/"}],"keywords":[{"name":"pomelo","slug":"pomelo","permalink":"https://cxx001.gitee.io/categories/pomelo/"}]},{"title":"npm包管理机制","slug":"nodejs/npm包管理机制","date":"2022-08-01T07:43:16.000Z","updated":"2022-09-07T00:27:39.151Z","comments":true,"path":"2022/08/01/nodejs/npm包管理机制/","link":"","permalink":"https://cxx001.gitee.io/2022/08/01/nodejs/npm%E5%8C%85%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/","excerpt":"","text":"一 package.json 组成： Dependencies依赖包支持的配置格式： &quot;core-js&quot;: &quot;^1.1.5&quot; 指定版本号，去npm服务器下载包 &quot;test2-js&quot;: &quot;http://cdn.com/test2-js.tar.gz&quot; 一个可下载的压缩包地址，去下载并解压安装 &quot;antd&quot;: &quot;ant-design/ant-design#4.0.0-alpha.8&quot; github用户名&#x2F;仓库名[#tag&#x2F;commitid]这种格式 git ulr形式下载安装，如：git+https://github.com/itwmike/axios.gitgit+ssh://git@github.com:itwmike/axios.git devDependencies属性与dependencies区别，dev是开发环境，只在开发环境使用，用户使用你的包时即使不安装这些依赖也可以正常运行，npm install时也会被安装和管理，但是不会被安装到生产环境。 scripts 用于配置一些脚本命令的缩写，各个脚本可以互相组合使用，这些脚本可以覆盖整个项目的生命周期，配置后可使用 npm run command 进行调用。如果是 npm 关键字，则可以直接调用。 二 npm包管理 npm view xxx version/versions 查看某个包最新版本&#x2F;所有发布的版本 ~: 当安装依赖时获取到有新版本时，安装到 x.y.z 中 z 的最新的版本。即保持主版本号、次版本号不变的情况下，保持修订号的最新版本。 ^: 当安装依赖时获取到有新版本时，安装到 x.y.z 中 y 和 z 都为最新版本。即保持主版本号不变的情况下，保持次版本号、修订版本号为最新版本。 package-lock.json文件，锁定依赖版本意味着在我们不手动执行更新的情况下，每次安装依赖都会安装固定版本。保证整个团队使用版本号一致的依赖。 使用 npm outdated 可以帮助我们列出有哪些还没有升级到最新版本的依赖： 黄色表示不符合我们指定的语意化版本范围 - 不需要升级 红色表示符合指定的语意化版本范围 - 需要升级 执行 npm update 会升级所有的红色依赖。 依赖变更 升级依赖: 修改 package.json文件的依赖版本，执行 npm install。 降级依赖: 执行 npm install package@version, 重新安装(改动package.json不会对依赖进行降级)。 注意改动依赖后提交lock文件 npm install执行原理 在执行 npm install 或 npm update命令下载依赖后，除了将依赖包安装在node_modules 目录下外，还会在本地的缓存目录缓存一份。查看缓存目录命令：npm config get cache npm 提供了几个命令来管理缓存数据： npm cache add：官方解释说这个命令主要是 npm 内部使用，但是也可以用来手动给一个指定的 package 添加缓存。 npm cache clean：删除缓存目录下的所有数据，为了保证缓存数据的完整性，需要加上 –force 参数。 npm cache verify：验证缓存数据的有效性和完整性，清理垃圾数据。 yarn yarn 是在 2016 年发布的，那时 npm 还处于 V3 时期，那时候还没有 package-lock.json 文件，就像上面我们提到的：不稳定性、安装速度慢等缺点经常会受到广大开发者吐槽。此时，yarn 诞生. yarn也有yarn.lock文件，原理大致和npm的一致，只是yarn.lock 中子依赖的版本号不是固定的，意味着单独一个 yarn.lock 确定不了 node_modules 目录结构，还需要和 package.json 文件进行配合。而 package-lock.json 只需要一个文件即可确定。 查看缓存目录：yarn cache dir删除缓存：yarn cache clean","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://cxx001.gitee.io/categories/nodejs/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://cxx001.gitee.io/tags/npm/"}],"keywords":[{"name":"nodejs","slug":"nodejs","permalink":"https://cxx001.gitee.io/categories/nodejs/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-07-06T20:42:52.000Z","updated":"2022-12-06T08:42:31.267Z","comments":true,"path":"2022/07/07/hello-world/","link":"","permalink":"https://cxx001.gitee.io/2022/07/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}