<!DOCTYPE HTML>
<html lang="zh-CN">

<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="Hexo">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.0.0">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="https://cxx001.gitee.io">
    <!--SEO-->

<meta name="keywords" content="c++20" />


<meta name="description" content="前言自C++11这个大版本更新以来，后来陆续有两次小版本迭代C++14、C++17，它们主要是对C++11的补充扩展，并没有增加太多大的特性。
而这次的C++20，和当年C++11一样，又是一次..." />


<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->

<title>
    
    c++20新特性 |
    
    Hexo
</title>

<link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">


<link rel="icon" href="/favicon.ico">

    


<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7.css">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.7.0.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash.css">

    
<div class="hide">
    <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script>
</div>




    

<meta name="generator" content="Hexo 6.2.0"></head>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->
<body>
    <header class="main-header"  style="background-image:url(
    https://hexo-theme-snippet-1251680922.cos.ap-beijing.myqcloud.com/img/banner.jpg)"
     >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='John Doe'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
            <!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
            <img src="/img/branding.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
        </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                        <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="https://cxx001.gitee.io">
                        Hexo</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                        <li role="presentation" class="text-center">
                            <a href="/"><i class="fa "></i>
                                首页</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/archives/"><i class="fa "></i>
                                时间轴</a>
                        </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="c++20新特性">
            
            c++20新特性
            
        </h1>
        <div class="post-meta">
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a class="category-link" href="/categories/c/">c++</a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            <a class="tag-none-link" href="/tags/c-20/" rel="tag">c++20</a>
            
        </span>
    </span>
    
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">
            2023/09/05</span>
    </span>
    
    <span class="fa-wrap">
        <i class="fa fa-eye"></i>
        <span id="busuanzi_value_page_pv"></span>
    </span>
    
    
</div>
        
        
    </div>
    
    <div class="post-body post-content">
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>自C++11这个大版本更新以来，后来陆续有两次小版本迭代C++14、C++17，它们主要是对C++11的补充扩展，并没有增加太多大的特性。</p>
<p>而这次的C++20，和当年C++11一样，又是一次重大更新，有人甚至说这是一门新语言。</p>
<h1 id="1-新增关键字"><a href="#1-新增关键字" class="headerlink" title="1. 新增关键字"></a>1. 新增关键字</h1><ul>
<li>concept 用于约束模板参数的类型范围，从而限制模板的实例化范围。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Arithmetic = std::is_arithmetic_v&lt;T&gt;;  <span class="comment">// 约束参数T只能是算术类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;Arithmetic T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">add</span>(<span class="number">5</span>, <span class="number">10</span>); <span class="comment">// 正确，int 是算术类型</span></span><br><span class="line">    <span class="comment">//double result = add(&quot;Hello&quot;, &quot;World&quot;);  // 错误，字符串不是算术类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一些常用的类型约束还有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::is_integral&lt;T&gt;::value：检查类型 T 是否为整数类型（包括有符号和无符号整数）。</span><br><span class="line">std::is_floating_point&lt;T&gt;::value：检查类型 T 是否为浮点类型。</span><br><span class="line">std::is_pointer&lt;T&gt;::value：检查类型 T 是否为指针类型。</span><br><span class="line">std::is_array&lt;T&gt;::value：检查类型 T 是否为数组类型。</span><br><span class="line">std::is_class&lt;T&gt;::value：检查类型 T 是否为类类型。</span><br><span class="line">std::is_enum&lt;T&gt;::value：检查类型 T 是否为枚举类型。</span><br><span class="line">std::is_function&lt;T&gt;::value：检查类型 T 是否为函数类型。</span><br><span class="line">std::is_same&lt;T, U&gt;::value：检查类型 T 是否与类型 U 相同。</span><br></pre></td></tr></table></figure>

<ul>
<li>requires 用于在concept中定义更复杂的约束条件。通过使用 <code>requires</code> 关键字，可以指定更多的条件，以进一步限制模板参数的属性。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Incrementable = <span class="built_in">requires</span>(T a) &#123;</span><br><span class="line">    &#123; ++a &#125; -&gt; std::same_as&lt;T&amp;&gt;;  <span class="comment">// 要求 a 可以递增，并返回 T&amp;</span></span><br><span class="line">    std::is_arithmetic_v&lt;T&gt;;      <span class="comment">// 要求 T 是算术类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;Incrementable T&gt;</span><br><span class="line"><span class="function">T <span class="title">increment</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    ++value;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">increment</span>(<span class="number">5</span>);  <span class="comment">// 正确，int 可以递增</span></span><br><span class="line">    <span class="comment">// double result = increment(3.14);  // 错误，double 不可递增</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>constinit 用于指定一个对象必须以静态初始化方式进行初始化，提高程序的性能和可预测性。</li>
</ul>
<p>在 C++ 中，对象的初始化可以分为两种方式：静态初始化和动态初始化。静态初始化是指在程序启动时或者在第一次使用之前，<strong>由编译器自动完成的初始化过程</strong>。动态初始化是指在<strong>运行时通过代码执行来完成的初始化过程</strong>。</p>
<p>使用 <code>constinit</code> 关键字可以确保对象以静态初始化方式进行初始化，从而避免了动态初始化的开销和潜在的不确定性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constinit</span> <span class="type">int</span> x = <span class="number">42</span>;   <span class="comment">// 编译器将确保 x 以静态初始化方式进行初始化。</span></span><br></pre></td></tr></table></figure>

<p>注意，<code>constinit</code> 关键字只能用于具有静态存储期的对象，例如全局变量、静态变量或者在命名空间作用域内定义的变量。它不能用于局部变量或者动态分配的对象。</p>
<ul>
<li>consteval 用于声明一个函数必须在编译时进行求值，编译器将在编译时执行该函数，并将结果替换到调用点。以提供更高的性能和优化机会。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意与C++11的<code>constexpr</code>区别，上面示例用这两个效果一样，都可以实现在编译期求值。不过<code>constexpr</code> 用于声明可以在编译时求值的常量表达式或函数，而<code>consteval</code> 关键字只能用于函数声明，不能用于变量或其他语句。</p>
<ul>
<li><p>co_await 、co_return、co_yield 这些是C++20引入协程编程新增的关键字，协程编程是一种轻量级的并发编程机制，<strong>它允许函数在执行过程中暂停和恢复。</strong>在后面会详细介绍。</p>
</li>
<li><p>char8_t  用于表示 UTF-8 编码的字符。<code>char8_t</code> 类型的大小为一个字节（8位），与 UTF-8 编码方式一致。可以使用 <code>char8_t</code> 类型的指针来遍历和操作 UTF-8 字符串，而无需进行字符集转换或编码处理。更加方便了。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char8_t</span>* utf8String = <span class="string">u8&quot;Hello, 世界!&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;UTF-8 String: &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(utf8String) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>import、module 这是C++20引入的又一重大特性，模块。后面详细介绍。(和js的模块机制很像~)</li>
</ul>
<h1 id="2-模块"><a href="#2-模块" class="headerlink" title="2. 模块"></a>2. 模块</h1><p>在C++20中，终于引入了模块化编程的概念，这和各脚本语言中的模块概念很类似。模块化编程旨在提供更好的代码组织、封装和可重用性。</p>
<p>模块化编程通过使用<code>module</code>关键字来定义模块，将相关的实体（变量、函数、类等）封装在一个单独的单元中，并使用<code>import</code>关键字在其他模块中导入所需的实体。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vs2022中添加模块文件math.ixx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> math;   <span class="comment">// 创建模块math</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">int</span> <span class="title">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> math;  <span class="comment">// 导入模块</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">add</span>(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    std::cout &lt;&lt; result;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用模块化编程可以带来许多优势，例如：</p>
<ul>
<li>更好的代码组织：模块将相关的实体封装在一起，使代码结构更清晰，易于维护和理解。</li>
<li>更好的封装：模块可以选择性地导出实体，控制对外部的可见性，提供更好的封装性。</li>
<li>更快的编译速度：由于模块只包含所需的实体，而不是整个头文件，编译速度可能会更快。</li>
<li>避免头文件的预处理器宏：模块不需要使用预处理器宏来处理头文件的重复包含和条件编译。</li>
</ul>
<h1 id="3-新增ranges标准库组件"><a href="#3-新增ranges标准库组件" class="headerlink" title="3. 新增ranges标准库组件"></a>3. 新增ranges标准库组件</h1><p>C++20引入了一种新的标准库组件，称为Ranges（范围），<strong>用于简化和增强对序列（包括容器、数组、迭代器等）的操作和处理。</strong></p>
<p>Ranges的设计目标是通过使用管道操作符（<code>|</code>）和函数式编程的风格，提供一种更现代、更可读、更易于组合的方式来操作序列。使用Ranges，你可以将多个操作链接在一起，形成一个连续的操作链，每个操作都是对序列进行转换、筛选、排序等操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ranges&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// 首先对numbers数组中每个元素*2变为&#123;2, 4, 6, 8, 10&#125;,然后筛选被3整除的元素。</span></span><br><span class="line">    <span class="comment">// 整个操作流程使用管道符&quot;|&quot;连接。</span></span><br><span class="line">    <span class="keyword">auto</span> result = numbers | std::views::<span class="built_in">transform</span>([](<span class="type">int</span> n) &#123; <span class="keyword">return</span> n * <span class="number">2</span>; &#125;)</span><br><span class="line">                          | std::views::<span class="built_in">filter</span>([](<span class="type">int</span> n) &#123; <span class="keyword">return</span> n % <span class="number">3</span> == <span class="number">0</span>; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : result) &#123;</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出: 6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，使用Ranges需要包含头文件<code>&lt;ranges&gt;</code>，并使用命名空间<code>std::views</code>和<code>std::ranges</code>来访问Ranges的操作。</p>
<p>下面列出Ranges的一些常用的操作：</p>
<ul>
<li><p>转换序列：使用<code>std::views::transform</code>将序列中的元素进行转换，例如将整数序列转换为字符串序列或进行数值计算。</p>
</li>
<li><p>筛选元素：使用<code>std::views::filter</code>根据特定条件筛选序列中的元素，例如筛选出满足某个谓词的元素。</p>
</li>
<li><p>排序序列：使用<code>std::views::sort</code>对序列进行排序操作，可以根据元素的某个属性进行排序。</p>
</li>
<li><p>分组元素：使用<code>std::views::group_by</code>将序列中的元素按照某个条件进行分组，例如按照元素的奇偶性进行分组。</p>
</li>
<li><p>聚合操作：使用<code>std::views::reduce</code>或<code>std::views::transform_reduce</code>对序列中的元素进行聚合操作，例如计算序列的总和、平均值等。</p>
</li>
<li><p>切片操作：使用<code>std::views::take</code>、<code>std::views::drop</code>或<code>std::views::slice</code>对序列进行切片操作，例如获取前几个元素或跳过前几个元素。</p>
</li>
<li><p>迭代操作：使用<code>std::ranges::for_each</code>对序列中的每个元素进行迭代操作，例如打印序列中的所有元素。</p>
</li>
<li><p>查找元素：使用<code>std::ranges::find</code>或<code>std::ranges::find_if</code>在序列中查找特定的元素或满足某个条件的元素。</p>
</li>
<li><p>合并序列：使用<code>std::views::concat</code>将多个序列合并为一个序列，方便进行统一的操作。</p>
</li>
<li><p>转换为容器：使用<code>std::ranges::to</code>将序列转换为特定类型的容器，例如将范围视图转换为<code>std::vector</code>或<code>std::list</code>。</p>
</li>
</ul>
<p>注意std::views::xx和std::ranges::xx区别，std::views下的操作是懒操作，在用到时才执行，并且不会修改原序列，返回一个操作后的新视图。而std::ranges下的操作是立即执行，操作修改原序列，不返回任何值。</p>
<h1 id="4-协程"><a href="#4-协程" class="headerlink" title="4. 协程"></a>4. 协程</h1><p>这特性又是一大干货哈，终于是引入标准了。也是很多脚本语言常用特性，感觉越往后发展，C++编码门槛会越来越低哈，会和写脚本一样丝滑~~</p>
<p>协程是一种轻量级的并发编程机制，本质是一个特殊函数，只是<strong>它允许函数在执行过程中暂停和恢复</strong>。协程通常用于处理异步操作，例如网络请求、文件读写等。</p>
<p>主要关键字：</p>
<ol>
<li><code>co_await</code>：<ul>
<li><code>co_await</code> 用于在协程内部暂停执行，通常用于等待异步操作完成。</li>
<li>当协程遇到 <code>co_await</code> 表达式时，它将被暂停，并在异步操作完成后恢复执行。</li>
</ul>
</li>
<li><code>co_yield</code>：<ul>
<li><code>co_yield</code> 用于生成值并将其发送给调用者。它通常用于生成序列中的下一个值。</li>
<li>当协程遇到 <code>co_yield</code> 表达式时，它会生成值并将其返回给调用者，然后暂停协程的执行，以便在需要时继续生成更多值。</li>
</ul>
</li>
<li><code>co_return</code>：<ul>
<li><code>co_return</code> 用于结束协程的执行并返回一个值。它通常用于返回协程的最终结果。</li>
<li>当协程遇到 <code>co_return</code> 表达式时，它将结束执行，并将指定的值返回给调用者。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//! coro_ret 协程函数的返回值，内部定义promise_type，承诺对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">coro_ret</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span>;</span><br><span class="line">    <span class="keyword">using</span> handle_type = std::coroutine_handle&lt;promise_type&gt;;</span><br><span class="line">    <span class="comment">//! 协程句柄</span></span><br><span class="line">    handle_type coro_handle_;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">coro_ret</span>(handle_type h)</span><br><span class="line">        : <span class="built_in">coro_handle_</span>(h)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">coro_ret</span>(<span class="type">const</span> coro_ret&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">coro_ret</span>(coro_ret&amp;&amp; s)</span><br><span class="line">        : <span class="built_in">coro_handle_</span>(s.coro_)</span><br><span class="line">    &#123;</span><br><span class="line">        s.coro_handle_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">coro_ret</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//! 自行销毁</span></span><br><span class="line">        <span class="keyword">if</span> (coro_handle_)</span><br><span class="line">            coro_handle_.<span class="built_in">destroy</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    coro_ret&amp; <span class="keyword">operator</span>=(<span class="type">const</span> coro_ret&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    coro_ret&amp; <span class="keyword">operator</span>=(coro_ret&amp;&amp; s)</span><br><span class="line">    &#123;</span><br><span class="line">        coro_handle_ = s.coro_handle_;</span><br><span class="line">        s.coro_handle_ = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! 恢复协程，返回是否结束</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">move_next</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        coro_handle_.<span class="built_in">resume</span>();</span><br><span class="line">        <span class="keyword">return</span> coro_handle_.<span class="built_in">done</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//! 通过promise获取数据，返回值</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coro_handle_.<span class="built_in">promise</span>().return_data_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//! promise_type就是承诺对象，承诺对象用于协程内外交流</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        <span class="built_in">promise_type</span>() = <span class="keyword">default</span>;</span><br><span class="line">        ~<span class="built_in">promise_type</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! 生成协程返回值</span></span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">get_return_object</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> coro_ret&lt;T&gt; &#123; handle_type::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>) &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! 注意这个函数,返回的就是awaiter</span></span><br><span class="line">        <span class="comment">//! 如果返回std::suspend_never&#123;&#125;，就不挂起，</span></span><br><span class="line">        <span class="comment">//! 返回std::suspend_always&#123;&#125; 挂起</span></span><br><span class="line">        <span class="comment">//! 当然你也可以返回其他awaiter</span></span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">initial_suspend</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// return std::suspend_never&#123;&#125;;</span></span><br><span class="line">            <span class="keyword">return</span> std::suspend_always &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//! co_return 后这个函数会被调用</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(T v)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            return_data_ = v;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//!</span></span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">yield_value</span><span class="params">(T v)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;yield_value invoked.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            return_data_ = v;</span><br><span class="line">            <span class="keyword">return</span> std::suspend_always &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//! 在协程最后退出后调用的接口。</span></span><br><span class="line">        <span class="comment">//! 若 final_suspend 返回 std::suspend_always 则需要用户自行调用</span></span><br><span class="line">        <span class="comment">//! handle.destroy() 进行销毁，但注意final_suspend被调用时协程已经结束</span></span><br><span class="line">        <span class="comment">//! 返回std::suspend_always并不会挂起协程（实测 VSC++ 2022）</span></span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;final_suspend invoked.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> std::suspend_always &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            std::<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回值</span></span><br><span class="line">        T return_data_;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这就是一个协程函数</span></span><br><span class="line"><span class="function">coro_ret&lt;<span class="type">int</span>&gt; <span class="title">coroutine_7in7out</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 进入协程看initial_suspend，返回std::suspend_always&#123;&#125;;会有一次挂起</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Coroutine co_await std::suspend_never&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// co_await std::suspend_never&#123;&#125; 不会挂起</span></span><br><span class="line">    <span class="keyword">co_await</span> std::suspend_never &#123;&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Coroutine co_await std::suspend_always&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">co_await</span> std::suspend_always &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Coroutine stage 1 ,co_yield&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">co_yield</span> <span class="number">101</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Coroutine stage 2 ,co_yield&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">co_yield</span> <span class="number">202</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Coroutine stage 3 ,co_yield&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">co_yield</span> <span class="number">303</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Coroutine stage end, co_return&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">co_return</span> <span class="number">808</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> done = <span class="literal">false</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Start coroutine_7in7out ()\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 调用协程,得到返回值c_r，后面使用这个返回值来管理协程。</span></span><br><span class="line">    <span class="keyword">auto</span> c_r = <span class="built_in">coroutine_7in7out</span>();</span><br><span class="line">    <span class="comment">// 第一次停止因为initial_suspend 返回的是suspend_always</span></span><br><span class="line">    <span class="comment">// 此时没有进入Stage 1</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Coroutine &quot;</span> &lt;&lt; (done ? <span class="string">&quot;is done &quot;</span> : <span class="string">&quot;isn&#x27;t done &quot;</span>)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;ret =&quot;</span> &lt;&lt; c_r.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    done = c_r.<span class="built_in">move_next</span>();</span><br><span class="line">    <span class="comment">// 此时是，co_await std::suspend_always&#123;&#125;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Coroutine &quot;</span> &lt;&lt; (done ? <span class="string">&quot;is done &quot;</span> : <span class="string">&quot;isn&#x27;t done &quot;</span>)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;ret =&quot;</span> &lt;&lt; c_r.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    done = c_r.<span class="built_in">move_next</span>();</span><br><span class="line">    <span class="comment">// 此时打印Stage 1</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Coroutine &quot;</span> &lt;&lt; (done ? <span class="string">&quot;is done &quot;</span> : <span class="string">&quot;isn&#x27;t done &quot;</span>)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;ret =&quot;</span> &lt;&lt; c_r.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    done = c_r.<span class="built_in">move_next</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Coroutine &quot;</span> &lt;&lt; (done ? <span class="string">&quot;is done &quot;</span> : <span class="string">&quot;isn&#x27;t done &quot;</span>)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;ret =&quot;</span> &lt;&lt; c_r.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    done = c_r.<span class="built_in">move_next</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Coroutine &quot;</span> &lt;&lt; (done ? <span class="string">&quot;is done &quot;</span> : <span class="string">&quot;isn&#x27;t done &quot;</span>)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;ret =&quot;</span> &lt;&lt; c_r.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    done = c_r.<span class="built_in">move_next</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Coroutine &quot;</span> &lt;&lt; (done ? <span class="string">&quot;is done &quot;</span> : <span class="string">&quot;isn&#x27;t done &quot;</span>)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;ret =&quot;</span> &lt;&lt; c_r.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Start coroutine_7in7out ()</span><br><span class="line">Coroutine isn&#x27;t done ret =0</span><br><span class="line">Coroutine co_await std::suspend_never</span><br><span class="line">Coroutine co_await std::suspend_always</span><br><span class="line">Coroutine isn&#x27;t done ret =0</span><br><span class="line">Coroutine stage 1 ,co_yield</span><br><span class="line">yield_value invoked.</span><br><span class="line">Coroutine isn&#x27;t done ret =101</span><br><span class="line">Coroutine stage 2 ,co_yield</span><br><span class="line">yield_value invoked.</span><br><span class="line">Coroutine isn&#x27;t done ret =202</span><br><span class="line">Coroutine stage 3 ,co_yield</span><br><span class="line">yield_value invoked.</span><br><span class="line">Coroutine isn&#x27;t done ret =303</span><br><span class="line">Coroutine stage end, co_return</span><br><span class="line">final_suspend invoked.</span><br><span class="line">Coroutine is done ret =808</span><br></pre></td></tr></table></figure>



<h1 id="5-Lambda表达式更新"><a href="#5-Lambda表达式更新" class="headerlink" title="5. Lambda表达式更新"></a>5. Lambda表达式更新</h1><p>就是进行了些小扩展，具体细节这个不介绍了，本质就是一个匿名函数。</p>
<h1 id="6-constexpr常量表达式更新"><a href="#6-constexpr常量表达式更新" class="headerlink" title="6. constexpr常量表达式更新"></a>6. constexpr常量表达式更新</h1><p>也是增强了，限制更少了，具体细节这个也不介绍了，本质就是常量化，编译期求值。</p>
<h1 id="7-原子-Atomic-智能指针"><a href="#7-原子-Atomic-智能指针" class="headerlink" title="7.原子(Atomic)智能指针"></a>7.原子(Atomic)智能指针</h1><p>C++20引入了原子智能指针，这是对C++原子操作的一种扩展。原子智能指针允许你在多线程环境中安全地共享和操作智能指针。<code>std::atomic</code>原子智能指针可以保证对智能指针的操作是线程安全的，并且可以防止数据竞争。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享的数据结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">Data</span>(<span class="type">int</span> val)</span><br><span class="line">        : <span class="built_in">value</span>(val)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局共享的std::shared_ptr，使用std::atomic包装</span></span><br><span class="line">std::atomic&lt;std::shared_ptr&lt;Data&gt;&gt; sharedData;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数，从共享的std::shared_ptr中读取数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(<span class="type">int</span> threadId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从原子std::shared_ptr中加载数据</span></span><br><span class="line">    std::shared_ptr&lt;Data&gt; localPtr = std::<span class="built_in">atomic_load</span>(&amp;sharedData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用本地副本进行操作</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; threadId &lt;&lt; <span class="string">&quot; read value: &quot;</span> &lt;&lt; localPtr-&gt;value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化共享的std::shared_ptr</span></span><br><span class="line">    sharedData.<span class="built_in">store</span>(std::<span class="built_in">make_shared</span>&lt;Data&gt;(<span class="number">42</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(worker, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (std::thread&amp; thread : threads) &#123;</span><br><span class="line">        thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread 2 read value: 42Thread</span><br><span class="line">Thread 1 read value: 0 read value: 42</span><br><span class="line">42</span><br><span class="line">Thread 3 read value: 42</span><br></pre></td></tr></table></figure>

<p>由于我们使用原子操作来加载<code>std::shared_ptr</code>，多个线程可以同时访问和操作它而不会发生竞态条件。所以打印的结果是随机的。</p>
<h1 id="8-原子引用类型std-atomic-ref"><a href="#8-原子引用类型std-atomic-ref" class="headerlink" title="8.原子引用类型std::atomic_ref"></a>8.原子引用类型std::atomic_ref</h1><p>C++20 中引入的一种引用类型，用于支持原子操作。它允许您在不使用指针的情况下对共享数据进行原子操作。<code>std::atomic_ref</code> 可以用于提供线程安全的访问和修改共享变量的能力。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sharedValue = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::atomic_ref&lt;<span class="type">int</span>&gt; <span class="title">atomicSharedValue</span><span class="params">(sharedValue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">thread1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            atomicSharedValue.fetch_add(<span class="number">1</span>, std::memory_order_relaxed);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">thread2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            atomicSharedValue.fetch_add(<span class="number">1</span>, std::memory_order_relaxed);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    thread1.<span class="built_in">join</span>();</span><br><span class="line">    thread2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final shared value: &quot;</span> &lt;&lt; sharedValue &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Final shared value: 200000</span><br></pre></td></tr></table></figure>





<h1 id="9-自动合流和可中断的线程"><a href="#9-自动合流和可中断的线程" class="headerlink" title="9. 自动合流和可中断的线程"></a>9. 自动合流和可中断的线程</h1><ul>
<li>线程自动合流是指在线程执行完毕后，程序自动等待线程的结束并回收线程资源，而无需显式调用线程的 <code>join()</code> 方法。这使得线程的合流变得更加便捷和安全，避免了忘记合流或手动合流时出现的问题。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread is done.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::jthread <span class="title">myThread</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread is doing some work.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不需要手动调用 join()，std::jthread 会自动合流</span></span><br><span class="line">    <span class="comment">// 线程会在这里自动合流</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread is done.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Main thread is doing some work.</span><br><span class="line">Main thread is done.</span><br><span class="line">Thread is done.</span><br></pre></td></tr></table></figure>



<ul>
<li>可中断线程是指线程具有一种机制，允许它在执行过程中被其他线程或外部事件中断，然后执行特定的操作。这使得可以更灵活地控制线程的执行。以前一般都是用一个全局变量来外部控制线程中断，容易出错，也不灵活。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stop_token&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(std::stop_token token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!token.<span class="built_in">stop_requested</span>()) &#123;</span><br><span class="line">        <span class="comment">// 执行工作</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread is interrupted.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::jthread <span class="title">t</span><span class="params">(worker)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程等待一段时间后请求线程停止</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    t.<span class="built_in">request_stop</span>();</span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">join</span>();   <span class="comment">// 阻塞，等待线程返回后往下执行</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread is done.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread is interrupted.</span><br><span class="line">Main thread is done.</span><br></pre></td></tr></table></figure>



<h1 id="10-新的同步库"><a href="#10-新的同步库" class="headerlink" title="10. 新的同步库"></a>10. 新的同步库</h1><p>C++20引入了新的同步库，该库提供了多种同步工具，以帮助开发人员编写并发和多线程代码。</p>
<p>下面是一些C++20同步库的主要组件：</p>
<ol>
<li>**<code>std::latch</code>**：<code>std::latch</code>是一个计数器，它允许您等待某个事件发生。当计数器归零时，所有等待的线程都将被唤醒。使用<code>std::latch::wait()</code>等待计数器归零。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;latch&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(std::latch&amp; lt, <span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is done.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    lt.<span class="built_in">count_down</span>(); <span class="comment">// 减少计数器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> numThreads = <span class="number">3</span>;</span><br><span class="line">    <span class="function">std::latch <span class="title">latch</span><span class="params">(numThreads)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; ++i) &#123;</span><br><span class="line">        std::<span class="built_in">thread</span>(worker, std::<span class="built_in">ref</span>(latch), i).<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成，即当计数器为0时才往下执行</span></span><br><span class="line">    latch.<span class="built_in">wait</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;All threads are done. &quot;</span>  &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread 1 is done.</span><br><span class="line">Thread 0 is done.Thread 2 is done.</span><br><span class="line"></span><br><span class="line">All threads are done.</span><br></pre></td></tr></table></figure>

<p><code>std::latch</code> 可以用于控制一组线程的同步点，等待它们都完成后再进行下一步操作。这对于需要等待多个线程完成某项任务后再继续的情况非常有用。</p>
<ol start="2">
<li><p><strong><code>std::barrier</code><strong>：<code>std::barrier</code>是一个同步原语，它允许一组线程相互等待，直到所有线程都到达某个点。只有当所有线程都到达</strong>屏障点</strong>时，这些线程才能继续执行。</p>
<p>与 <code>std::latch</code> 不同，<code>std::barrier</code> 允许线程多次参与同步，即在达到同步点后，线程可以再次加入到下一轮同步中。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;barrier&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> numThreads = <span class="number">3</span>;</span><br><span class="line"><span class="function">std::barrier <span class="title">barrier</span><span class="params">(numThreads)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is ready.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    barrier.<span class="built_in">arrive_and_wait</span>(); <span class="comment">// 等待所有线程达到同步点</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; continues.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    barrier.<span class="built_in">arrive_and_wait</span>(); <span class="comment">// 再次等待所有线程达到同步点</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is done.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(worker, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (std::thread&amp; thread : threads) &#123;</span><br><span class="line">        thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;All threads are done.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread 1 is ready.Thread 2 is ready.</span><br><span class="line"></span><br><span class="line">Thread 0 is ready.</span><br><span class="line">Thread 0Thread  continues.Thread</span><br><span class="line">2 continues.1</span><br><span class="line"> continues.</span><br><span class="line">Thread Thread 1Thread 0 is done. is done.</span><br><span class="line">2 is done.</span><br><span class="line"></span><br><span class="line">All threads are done.</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用了两次同步点。<code>std::barrier</code> 允许线程多次参与同步，适用于需要多轮协作的情况，例如迭代式的并行计算或其他需要多次同步的场景。在每个同步点，所有线程都会等待，直到所有线程都到达同步点后才会继续执行。这可以用于更复杂的多线程协作任务。</p>
<ol start="3">
<li>**<code>std::promise</code> 和 <code>std::future</code>**：<code>std::promise</code> 和 <code>std::future</code> 提供了一种在不同线程之间传递数据的方式。<code>std::promise</code> 允许您在一个线程中设置一个值或异常，而 <code>std::future</code> 可以在另一个线程中获取该值或异常。您可以使用 <code>std::promise::set_value()</code> 设置值，使用 <code>std::promise::set_exception()</code> 设置异常，并使用 <code>std::future::get()</code> 获取值。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_work</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt;&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">42</span>; <span class="comment">// 执行一些工作并产生一个结果</span></span><br><span class="line">    p.<span class="built_in">set_value</span>(result); <span class="comment">// 设置结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; f = p.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">thread</span>(do_work, std::<span class="built_in">ref</span>(p)).<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = f.<span class="built_in">get</span>(); <span class="comment">// 阻塞等待并获取结果</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Result: 42</span><br></pre></td></tr></table></figure>

<p>这在多线程之间通信和协作非常有用。</p>
<ol start="4">
<li>**<code>std::semaphore</code>**：<code>std::semaphore</code> 是一种信号量，可以用于控制并发访问共享资源的线程，确保同时只有有限数量的线程可以访问共享资源，从而避免竞争条件和提高多线程程序的性能。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::counting_semaphore&lt;10&gt; <span class="title">sem</span><span class="params">(<span class="number">2</span>)</span></span>; <span class="comment">// 创建一个初始计数为2的信号量, 10是最大值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sem.<span class="built_in">acquire</span>(); <span class="comment">// 获取资源，如果没有资源则等待</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; acquired resource.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟工作</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    sem.<span class="built_in">release</span>(); <span class="comment">// 释放资源</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; released resource.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(worker, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (std::thread&amp; thread : threads) &#123;</span><br><span class="line">        thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread 1 acquired resource.Thread</span><br><span class="line">0 acquired resource.</span><br><span class="line">Thread Thread 4 acquired resource.1 released resource.Thread</span><br><span class="line"></span><br><span class="line">Thread 0 released resource.2</span><br><span class="line"> acquired resource.</span><br><span class="line">Thread Thread 3 acquired resource.2 released resource.Thread 4</span><br><span class="line"> released resource.</span><br><span class="line"></span><br><span class="line">Thread 3 released resource.</span><br></pre></td></tr></table></figure>



<h1 id="11-其它更新"><a href="#11-其它更新" class="headerlink" title="11. 其它更新"></a>11. 其它更新</h1><h2 id="1-指定初始化"><a href="#1-指定初始化" class="headerlink" title="1. 指定初始化"></a>1. 指定初始化</h2><p>它允许您在初始化复合数据结构（如结构体和数组）时，为特定的成员或元素提供初始化值，而不必按顺序初始化所有成员或元素。并且可以直接在声明时初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> z = <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point p1 = &#123; .x = <span class="number">10</span>, .y = <span class="number">20</span> &#125;;</span><br><span class="line">    Point p2 = &#123; .y = <span class="number">70</span>, .z = <span class="number">80</span> &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p1: x=&quot;</span> &lt;&lt; p1.x &lt;&lt; <span class="string">&quot; y=&quot;</span> &lt;&lt; p1.y &lt;&lt; <span class="string">&quot; z=&quot;</span> &lt;&lt; p1.z &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p2: x=&quot;</span> &lt;&lt; p2.x &lt;&lt; <span class="string">&quot; y=&quot;</span> &lt;&lt; p2.y &lt;&lt; <span class="string">&quot; z=&quot;</span> &lt;&lt; p2.z &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1: x=10 y=20 z=3</span><br><span class="line">p2: x=1 y=70 z=80</span><br></pre></td></tr></table></figure>



<h2 id="2-航天飞机操作符-lt-x3D-gt"><a href="#2-航天飞机操作符-lt-x3D-gt" class="headerlink" title="2. 航天飞机操作符&lt;&#x3D;&gt;"></a>2. 航天飞机操作符&lt;&#x3D;&gt;</h2><p>也叫三路比较运算符，用于比较两个对象的关系，返回值是<code>std::strong_ordering</code>类型，该类型包括三个可能的值，<code>std::strong_ordering::less</code>、<code>std::strong_ordering::equal</code>和<code>std::strong_ordering::greater</code>，分别表示左操作数小于、等于或大于右操作数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;compare&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    std::strong_ordering result = a &lt;=&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == std::strong_ordering::less) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;a is less than b&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result == std::strong_ordering::equal) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;a is equal to b&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result == std::strong_ordering::greater) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;a is greater than b&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&lt;&#x3D;&gt;三路比较运算符对比传统的&lt;, &#x3D;, &gt;，更加方便简洁，内部实现了3种关系比较，不需要分别一个个手动判断了。例如<code>std::strong_ordering</code> 类型的结果可以直接用于排序算法，对于自定义类型排序只需要重载<code>operator&lt;=&gt;</code>运算符一次，然后可以轻松地进行比较操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;compare&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">	<span class="comment">// 按年龄大小排序，std::sort内部自动按这个排序算法</span></span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> Person&amp; other) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age &lt;=&gt; other.age; <span class="comment">// 如果要按从大到小反过来就行了， other.age &lt;=&gt; age</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;Person&gt; people = &#123;</span><br><span class="line">        &#123; <span class="string">&quot;Alice&quot;</span>, <span class="number">30</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;Bob&quot;</span>, <span class="number">25</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;Charlie&quot;</span>, <span class="number">35</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;David&quot;</span>, <span class="number">28</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::sort 对容器进行排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出排序后的结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; person : people) &#123;</span><br><span class="line">        std::cout &lt;&lt; person.name &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; person.age &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bob - 25</span><br><span class="line">David - 28</span><br><span class="line">Alice - 30</span><br><span class="line">Charlie - 35</span><br></pre></td></tr></table></figure>



<h2 id="3-范围for循环支持初始化语句"><a href="#3-范围for循环支持初始化语句" class="headerlink" title="3.范围for循环支持初始化语句"></a>3.范围for循环支持初始化语句</h2><p>在前面C++17中我们讲了<code>if-switch</code>支持初始化语句，现在for循环语句遍历容器时也支持初始化语句了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 C++20 范围 for 循环的初始化语句</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; <span class="type">int</span> value : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value at index &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">        ++i; <span class="comment">// 初始化语句中声明的 i 变量用于记录索引</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Value at index 0: 1</span><br><span class="line">Value at index 1: 2</span><br><span class="line">Value at index 2: 3</span><br><span class="line">Value at index 3: 4</span><br><span class="line">Value at index 4: 5</span><br></pre></td></tr></table></figure>



<h2 id="4-非类型模板形参支持字符串"><a href="#4-非类型模板形参支持字符串" class="headerlink" title="4. 非类型模板形参支持字符串"></a>4. 非类型模板形参支持字符串</h2><p>这意味着您可以在模板中使用字符串作为模板参数，以实现更灵活的泛型编程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">const</span> <span class="type">char</span>* str&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">char</span>* message = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="built_in">printString</span>&lt;message&gt;();   <span class="comment">// 以字符串作为模板参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：在vs2022上编译不过，可能是这个特性在当前编译器上还没有完美支持。</p>
<h2 id="5-likely-unlikely-标记"><a href="#5-likely-unlikely-标记" class="headerlink" title="5. [[likely]], [[unlikely]]标记"></a>5. [[likely]], [[unlikely]]标记</h2><p>它们是用于标记代码分支的建议性属性，以帮助编译器优化执行路径。这些属性的主要目的是告诉编译器哪些分支更可能被执行，以便它可以更好地进行优化。</p>
<ol>
<li><code>[[likely]]</code>属性：用于标记代码分支，表示这个分支更可能被执行。这有助于编译器在生成机器代码时对这个分支进行更好的优化。</li>
<li><code>[[unlikely]]</code>属性：用于标记代码分支，表示这个分支更不可能被执行。这有助于编译器避免在生成机器代码时对这个分支进行过多的优化，以提高性能。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) [[likely]] &#123;</span><br><span class="line">    <span class="comment">// 告诉编译器这个分支很可能会执行</span></span><br><span class="line">    <span class="comment">// 在性能敏感的代码路径上使用</span></span><br><span class="line">&#125; <span class="keyword">else</span> [[unlikely]] &#123;</span><br><span class="line">    <span class="comment">// 告诉编译器这个分支不太可能会执行</span></span><br><span class="line">    <span class="comment">// 在不太可能执行的代码路径上使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些属性是可选的，编译器可以根据它们来进行代码优化，但不是必需的。它们主要用于提高性能，并且<strong>在性能敏感的代码路径上使用得最多</strong>，以确保编译器对这些路径进行更好的优化。</p>
<p>请注意，这些属性的效果取决于编译器的实现，不同的编译器可能会有不同的优化策略。因此，在使用这些属性时，最好进行性能测试，以确保它们对代码的性能产生了预期的影响。</p>
<h2 id="6-日历和时区功能"><a href="#6-日历和时区功能" class="headerlink" title="6. 日历和时区功能"></a>6. 日历和时区功能</h2><p>C++20引入了标准库中的<code>&lt;chrono&gt;</code>头文件的重大更新，其中包括了对日历和时区的新功能。这些功能使得在C++中处理日期、时间和时区更加容易和灵活。</p>
<p>以下是C++20中日历和时区功能的主要亮点：</p>
<ol>
<li><strong>日历支持</strong>：C++20引入了<code>std::chrono::year_month_day</code>、<code>std::chrono::year_month</code>和<code>std::chrono::weekday</code>等类型，以更方便地表示日期和时间。这些类型可以帮助您执行日期算术操作，如添加或减去日期、计算两个日期之间的时间间隔等。</li>
<li><strong>格式化和解析</strong>：C++20引入了<code>std::format</code>函数和<code>std::chrono::from_stream</code>函数，用于方便地格式化和解析日期和时间。这些函数可以将日期和时间以不同的格式进行字符串表示，并将字符串解析为日期和时间对象。</li>
<li><strong>时区支持</strong>：C++20引入了<code>std::chrono::zoned_time</code>类型，用于表示带有时区信息的日期和时间。这使得在不同的时区之间进行转换和比较变得更容易。此外，C++20还引入了<code>std::chrono::current_zone()</code>函数，用于获取当前的本地时区。</li>
<li><strong><code>std::chrono::sys_time</code>类型</strong>：<code>std::chrono::sys_time</code>是一个系统级别的时钟，用于表示与特定时钟不相关的时间点。这对于在不同时钟之间进行时间计算和比较非常有用。</li>
<li><strong>时钟和时钟间隔</strong>：C++20引入了<code>std::chrono::leap</code>时钟，用于处理闰秒，以及<code>std::chrono::den</code>时钟间隔，用于表示任意固定时钟周期。这些时钟和时钟间隔类型增加了时间计算的灵活性。</li>
<li><strong>时区数据库</strong>：C++20的<code>std::chrono</code>库中包含了一个时区数据库，其中包含了大量的时区信息，允许您轻松地执行与时区相关的操作。</li>
</ol>
<p>这些功能的引入使得C++在日期、时间和时区处理方面变得更加强大和标准化。使用这些功能，您可以更容易地处理不同时区的时间、执行日期算术操作、进行时间间隔计算等。</p>
<h2 id="7-std-span"><a href="#7-std-span" class="headerlink" title="7. std::span"></a>7. std::span</h2><p>这是一个用于表示一段连续内存的非拥有式、轻量级的容器。<code>std::span</code>的目的是提供对现有内存的安全<strong>引用</strong>，而不进行内存分配或拷贝。通过它来引用数组传递使用就不会有越界风险，它内部自动实现了边界检查。它配合STL容器一起使用，更加灵活。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;span&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">std::span&lt;<span class="type">int</span>&gt; <span class="title">span</span><span class="params">(data.data(), data.size())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::span 遍历数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> value : span) &#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改数据，span 反映了原始数据的更改</span></span><br><span class="line">    span[<span class="number">2</span>] = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次遍历数据，看看修改后的结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> value : span) &#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5</span><br><span class="line">1 2 99 4 5</span><br></pre></td></tr></table></figure>



<h2 id="8-新增特性测试宏"><a href="#8-新增特性测试宏" class="headerlink" title="8. 新增特性测试宏"></a>8. 新增特性测试宏</h2><p>C++20引入了一组特性测试宏，用于在代码中检测编译器是否支持特定的C++20功能或库。</p>
<p>以下是一些常用的C++20特性测试宏：</p>
<ol>
<li><p><code>__cpp_concepts</code>：用于测试是否支持C++20的概念（Concepts）特性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cpp_concepts</span></span><br><span class="line"><span class="comment">// 在支持概念的编译器中编写的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>__cpp_consteval</code>：用于测试是否支持C++20的<code>consteval</code>特性，该特性允许在编译时执行函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cpp_consteval</span></span><br><span class="line"><span class="comment">// 在支持 consteval 的编译器中编写的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>__cpp_modules</code>：用于测试是否支持C++20的模块（Modules）特性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cpp_modules</span></span><br><span class="line"><span class="comment">// 在支持模块的编译器中编写的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>__cpp_ranges</code>：用于测试是否支持C++20的范围（Ranges）库特性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cpp_ranges</span></span><br><span class="line"><span class="comment">// 在支持范围库的编译器中编写的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>__cpp_coroutines</code>：用于测试是否支持C++20的协程（Coroutines）特性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cpp_coroutines</span></span><br><span class="line"><span class="comment">// 在支持协程的编译器中编写的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>__cpp_lib_concepts</code>、<code>__cpp_lib_consteval</code>、<code>__cpp_lib_modules</code>、<code>__cpp_lib_ranges</code>、<code>__cpp_lib_coroutines</code>等：用于测试编译器是否支持C++20库中的相关功能。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cpp_lib_ranges</span></span><br><span class="line"><span class="comment">// 在支持范围库的编译器中编写的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="9-using可以为enum类型取别名"><a href="#9-using可以为enum类型取别名" class="headerlink" title="9. using可以为enum类型取别名"></a>9. using可以为enum类型取别名</h2><p>它允许您为枚举类型定义更具有意义的别名，这可以帮助提高代码的可读性和可维护性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个枚举类</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green,</span><br><span class="line">    Blue</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 using 引用枚举类类型</span></span><br><span class="line">    <span class="keyword">using</span> ColorType = Color;</span><br><span class="line"></span><br><span class="line">    ColorType color = Color::Red;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用引用的别名来声明变量</span></span><br><span class="line">    <span class="keyword">if</span> (color == ColorType::Red) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Color is Red&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Color is not Red&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="10-std-format格式化库"><a href="#10-std-format格式化库" class="headerlink" title="10. std::format格式化库"></a>10. std::format格式化库</h2><p>类似于C语言中的<code>printf</code>函数或Python中的<code>str.format()</code>方法。<code>std::format</code>库的目标是提供一种类型安全、可扩展和国际化友好的方式来构建格式化字符串。</p>
<p>使用<code>&#123;&#125;</code>作为占位符，并且支持添加格式说明符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;format&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> age = <span class="number">30</span>;</span><br><span class="line">    std::string name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">    <span class="type">double</span> pi = <span class="number">3.14159265359</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::format 格式化字符串</span></span><br><span class="line">    std::string formatted = std::format(<span class="string">&quot;Name: &#123;&#125;, Age: &#123;&#125;, Pi: &#123;:.2f&#125;&quot;</span>, name, age, pi);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; formatted &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="11-增加数学常量"><a href="#11-增加数学常量" class="headerlink" title="11. 增加数学常量"></a>11. 增加数学常量</h2><p>在C++20中，标准库引入了一组常见的数学常量，这些常量定义在<code>&lt;numbers&gt;</code>头文件中。这些数学常量是通过<code>std::numbers</code>命名空间提供的，可以用于进行数学计算，例如π、自然对数的底数e等。</p>
<p>以下是一些C++20中引入的数学常量示例：</p>
<ol>
<li><p>π（圆周率）：可以使用<code>std::numbers::pi</code>访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> pi = std::numbers::pi;</span><br></pre></td></tr></table></figure>
</li>
<li><p>e（自然对数的底数）：可以使用<code>std::numbers::e</code>访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> e = std::numbers::e;</span><br></pre></td></tr></table></figure>
</li>
<li><p>黄金比例：可以使用<code>std::numbers::phi</code>访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> phi = std::numbers::phi;</span><br></pre></td></tr></table></figure>
</li>
<li><p>平方根2：可以使用<code>std::numbers::sqrt2</code>访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> sqrt2 = std::numbers::sqrt2;</span><br></pre></td></tr></table></figure>
</li>
<li><p>平方根3：可以使用<code>std::numbers::sqrt3</code>访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> sqrt3 = std::numbers::sqrt3;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自然对数的2：可以使用<code>std::numbers::ln2</code>访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> ln2 = std::numbers::ln2;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自然对数的10：可以使用<code>std::numbers::ln10</code>访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> ln10 = std::numbers::ln10;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些数学常量使得在C++中执行常见的数学计算更加方便和可读。它们以类型安全的方式提供了数学常数，避免了传统的宏定义或手动输入常数值的问题。</p>
<h2 id="12-std-source-location"><a href="#12-std-source-location" class="headerlink" title="12. std::source_location"></a>12. std::source_location</h2><p>它允许在代码中获取当前文件的名称、当前行号、当前列号以及调用点的函数名称。这对于调试和日志记录非常有用，可以帮助定位代码中的问题。</p>
<p><code>std::source_location</code>定义在<code>&lt;source_location&gt;</code>头文件中，并提供了以下常用成员函数：</p>
<ol>
<li><code>file_name()</code>：返回当前源文件的名称。</li>
<li><code>line()</code>：返回当前源文件的行号。</li>
<li><code>column()</code>：返回当前源文件的列号。</li>
<li><code>function_name()</code>：返回调用点的函数名称。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;source_location&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSourceLocation</span><span class="params">(<span class="type">const</span> std::source_location&amp; loc = std::source_location::current())</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;File: &quot;</span> &lt;&lt; loc.<span class="built_in">file_name</span>()</span><br><span class="line">              &lt;&lt; <span class="string">&quot; Line: &quot;</span> &lt;&lt; loc.<span class="built_in">line</span>()</span><br><span class="line">              &lt;&lt; <span class="string">&quot; Column: &quot;</span> &lt;&lt; loc.<span class="built_in">column</span>()</span><br><span class="line">              &lt;&lt; <span class="string">&quot; Function: &quot;</span> &lt;&lt; loc.<span class="built_in">function_name</span>()</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printSourceLocation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File: C:\Users\cxx\Desktop\ConsoleApplication1\ConsoleApplication1\ConsoleApplication1.cpp Line: 18 Column: 5 Function: main</span><br></pre></td></tr></table></figure>



<h2 id="13-nodiscard-reason"><a href="#13-nodiscard-reason" class="headerlink" title="13. [[nodiscard(reason)]]"></a>13. [[nodiscard(reason)]]</h2><p>在C++17和C++20中，可以使用<code>[[nodiscard]]</code>属性来告诉编译器应该注意忽略函数的返回值。C++20进一步扩展了这个特性，允许您提供一个可选的字符串参数，以解释为什么返回值应该被注意忽略。如果返回值没有被使用，编译则会给出这个警告信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">[[<span class="built_in">nodiscard</span>(<span class="string">&quot;Please check the return value for error handling&quot;</span>)]] <span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 返回值应该用于错误处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">divide</span>(<span class="number">10</span>, <span class="number">2</span>); <span class="comment">// 正确使用返回值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">divide</span>(<span class="number">10</span>, <span class="number">0</span>); <span class="comment">// 忽略返回值，但编译器会发出警告</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">已启动重新生成...</span><br><span class="line">1&gt;------ 已启动全部重新生成: 项目: ConsoleApplication1, 配置: Debug x64 ------</span><br><span class="line">1&gt;正在扫描源以查找模块依赖项...</span><br><span class="line">1&gt;math.ixx</span><br><span class="line">1&gt;正在编译...</span><br><span class="line">1&gt;math.ixx</span><br><span class="line">1&gt;ConsoleApplication1.cpp</span><br><span class="line">1&gt;C:\Users\cxx\Desktop\ConsoleApplication1\ConsoleApplication1\ConsoleApplication1.cpp(20,11): warning C4858: 正在放弃返回值: Please check the return value for error handling</span><br><span class="line">1&gt;ConsoleApplication1.vcxproj -&gt; C:\Users\cxx\Desktop\ConsoleApplication1\x64\Debug\ConsoleApplication1.exe</span><br><span class="line">1&gt;已完成生成项目“ConsoleApplication1.vcxproj”的操作。</span><br><span class="line">========== “全部重新生成”: 1 成功，0 失败，0已跳过 ==========</span><br><span class="line">========= 重新生成 开始于 3:04 PM，并花费了 01.026 秒 ==========</span><br></pre></td></tr></table></figure>



<h2 id="14-增加循环移位，计算位中0和1数量等功能"><a href="#14-增加循环移位，计算位中0和1数量等功能" class="headerlink" title="14. 增加循环移位，计算位中0和1数量等功能"></a>14. 增加循环移位，计算位中0和1数量等功能</h2><p>这些功能是通过C++20的标准库中的<code>&lt;bit&gt;</code>头文件引入的。</p>
<ol>
<li><strong>循环左移和循环右移</strong>：<code>std::rotl</code>用于执行循环左移操作，<code>std::rotr</code>用于执行循环右移操作。注意普通左移2位会将位移出并丢弃，而循环左移2位会将位重新循环回来，保持位数不变，即将移除的最高位的位数添加回数的最低位。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bit&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> value = <span class="number">0b1100</span>; <span class="comment">// 二进制表示 1100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环左移两位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> result_left = std::<span class="built_in">rotl</span>(value, <span class="number">2</span>); <span class="comment">// 结果为 0b0011，二进制表示 0011</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环右移两位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> result_right = std::<span class="built_in">rotr</span>(value, <span class="number">2</span>); <span class="comment">// 结果为 0b0011，二进制表示 0011</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Left Rotation: &quot;</span> &lt;&lt; result_left &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Right Rotation: &quot;</span> &lt;&lt; result_right &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>计算位中0和1的数量</strong>：<code>std::countr_zero</code>用于计算从右侧开始的连续0的数量，<code>std::countr_one</code>用于计算从右侧开始的连续1的数量。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bit&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> value = <span class="number">0b11001100</span>; <span class="comment">// 二进制表示 11001100</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> zeros = std::<span class="built_in">countr_zero</span>(value); <span class="comment">// 连续0的数量为 2</span></span><br><span class="line">    <span class="type">int</span> ones = std::<span class="built_in">countr_one</span>(value);   <span class="comment">// 连续1的数量为 2</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Count of Zeros: &quot;</span> &lt;&lt; zeros &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Count of Ones: &quot;</span> &lt;&lt; ones &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>以上就是C++20的主要新增特性了，当然还一些细节扩展，那些就待使用时再查阅相关文档了。总结下来，C++11主要是引入了类型自动推导的auto，智能指针。C++20主要是模块、协程、原子操作。总体发展线路可以看出，C++编码风格在向脚本语言靠拢了。</p>

    </div>
    
    <div class="post-footer">
        <div>
            
            转载声明：
            商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">cxx</a>
            
            
        </div>
        <div>
            
        </div>
    </div>
</article>
<div class="article-nav prev-next-wrap clearfix">
    
    
    <a href="/2023/08/31/c++/c++17%E6%96%B0%E7%89%B9%E6%80%A7/" class="next-post btn btn-default" title='c++17新特性'>
        <span class="hidden-lg">下一篇</span>
        <span class="hidden-xs">
            c++17新特性</span><i class="fa fa-angle-right fa-fw"></i>
    </a>
    
</div>

<div id="comments">
    
    
<div class="utteranc">
  
  <script
    src='https://utteranc.es/client.js'
    repo='cxx001/myblog-comment'
    issue-term='pathname'
    issue-number=''
    theme='github-light'
    label=''
    crossorigin='anonymous'
    async
  ></script>
</div>



</div>

                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">
            文章目录
        </h3>
        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%96%B0%E5%A2%9E%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">1. 新增关键字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%A8%A1%E5%9D%97"><span class="toc-text">2. 模块</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%96%B0%E5%A2%9Eranges%E6%A0%87%E5%87%86%E5%BA%93%E7%BB%84%E4%BB%B6"><span class="toc-text">3. 新增ranges标准库组件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%8D%8F%E7%A8%8B"><span class="toc-text">4. 协程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9B%B4%E6%96%B0"><span class="toc-text">5. Lambda表达式更新</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-constexpr%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9B%B4%E6%96%B0"><span class="toc-text">6. constexpr常量表达式更新</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%8E%9F%E5%AD%90-Atomic-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">7.原子(Atomic)智能指针</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8Bstd-atomic-ref"><span class="toc-text">8.原子引用类型std::atomic_ref</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E8%87%AA%E5%8A%A8%E5%90%88%E6%B5%81%E5%92%8C%E5%8F%AF%E4%B8%AD%E6%96%AD%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-text">9. 自动合流和可中断的线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E6%96%B0%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BA%93"><span class="toc-text">10. 新的同步库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E5%85%B6%E5%AE%83%E6%9B%B4%E6%96%B0"><span class="toc-text">11. 其它更新</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">1. 指定初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%88%AA%E5%A4%A9%E9%A3%9E%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%AC%A6-lt-x3D-gt"><span class="toc-text">2. 航天飞机操作符&lt;&#x3D;&gt;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%8C%83%E5%9B%B4for%E5%BE%AA%E7%8E%AF%E6%94%AF%E6%8C%81%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%AD%E5%8F%A5"><span class="toc-text">3.范围for循环支持初始化语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%9D%9E%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF%E5%BD%A2%E5%8F%82%E6%94%AF%E6%8C%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">4. 非类型模板形参支持字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-likely-unlikely-%E6%A0%87%E8%AE%B0"><span class="toc-text">5. [[likely]], [[unlikely]]标记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%97%A5%E5%8E%86%E5%92%8C%E6%97%B6%E5%8C%BA%E5%8A%9F%E8%83%BD"><span class="toc-text">6. 日历和时区功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-std-span"><span class="toc-text">7. std::span</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E5%AE%8F"><span class="toc-text">8. 新增特性测试宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-using%E5%8F%AF%E4%BB%A5%E4%B8%BAenum%E7%B1%BB%E5%9E%8B%E5%8F%96%E5%88%AB%E5%90%8D"><span class="toc-text">9. using可以为enum类型取别名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-std-format%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%BA%93"><span class="toc-text">10. std::format格式化库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E5%A2%9E%E5%8A%A0%E6%95%B0%E5%AD%A6%E5%B8%B8%E9%87%8F"><span class="toc-text">11. 增加数学常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-std-source-location"><span class="toc-text">12. std::source_location</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-nodiscard-reason"><span class="toc-text">13. [[nodiscard(reason)]]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E5%A2%9E%E5%8A%A0%E5%BE%AA%E7%8E%AF%E7%A7%BB%E4%BD%8D%EF%BC%8C%E8%AE%A1%E7%AE%97%E4%BD%8D%E4%B8%AD0%E5%92%8C1%E6%95%B0%E9%87%8F%E7%AD%89%E5%8A%9F%E8%83%BD"><span class="toc-text">14. 增加循环移位，计算位中0和1数量等功能</span></a></li></ol></li></ol>
        
    </div>
</aside>
                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>
<a id="back-to-top" class="icon-btn hide">
    <i class="fa fa-chevron-up"></i>
</a>
    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
    访问量:
    <strong id="busuanzi_value_site_pv">
        <i class="fa fa-spinner fa-spin"></i>
    </strong>
    &nbsp; | &nbsp;
    访客数:
    <strong id="busuanzi_value_site_uv">
        <i class="fa fa-spinner fa-spin"></i>
    </strong>
    
</div>
            </div>
            <div class="col-sm-12">
                <span>Copyright &copy;
                    2022
                    
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<script src="/js/app.js?rev=@@hash.js"></script>

</body>
</html>